#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Fri Oct 23 17:03:25 2020 by generateDS.py version 2.36.4.
# Python 3.8.5 (tags/v3.8.5:580fbb0, Jul 20 2020, 15:43:08) [MSC v.1926 32 bit (Intel)]
#
# Command line options:
#   ('-o', 'visio12_main.py')
#   ('-s', 'visio12_subs.py')
#
# Command line arguments:
#   1 - XML Schemas\Visio2010XSDFiles\visio12.xsd
#
# Command line:
#   generateDS.py -o "visio12_main.py" -s "visio12_subs.py" 1 - XML Schemas\Visio2010XSDFiles\visio12.xsd
#
# Current working directory (os.getcwd()):
#   3 - generateDS
#

from six.moves import zip_longest
import os
import sys
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ImportError:

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class ISOBoolean(str, Enum):
    _0='0'
    _1='1'


class Row_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Del=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Del = _cast(int, Del)
        self.Del_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Row_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Row_Type.subclass:
            return Row_Type.subclass(*args_, **kwargs_)
        else:
            return Row_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Del(self):
        return self.Del
    def set_Del(self, Del):
        self.Del = Del
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ISOBoolean(self, value):
        # Validate type ISOBoolean, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [0, 1]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ISOBoolean' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Row_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Row_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Row_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Row_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Row_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Row_Type'):
        if self.Del is not None and 'Del' not in already_processed:
            already_processed.add('Del')
            outfile.write(' Del="%s"' % self.gds_format_integer(self.Del, input_name='Del'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Row_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Del', node)
        if value is not None and 'Del' not in already_processed:
            already_processed.add('Del')
            self.Del = self.gds_parse_integer(value, node, 'Del')
            self.validate_ISOBoolean(self.Del)    # validate type ISOBoolean
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Row_Type


class IndexedRow_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, IX=None, Del=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.IX = _cast(int, IX)
        self.IX_nsprefix_ = None
        self.Del = _cast(int, Del)
        self.Del_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndexedRow_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndexedRow_Type.subclass:
            return IndexedRow_Type.subclass(*args_, **kwargs_)
        else:
            return IndexedRow_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IX(self):
        return self.IX
    def set_IX(self, IX):
        self.IX = IX
    def get_Del(self):
        return self.Del
    def set_Del(self, Del):
        self.Del = Del
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ISOBoolean(self, value):
        # Validate type ISOBoolean, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [0, 1]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ISOBoolean' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IndexedRow_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IndexedRow_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IndexedRow_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IndexedRow_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IndexedRow_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IndexedRow_Type'):
        if self.IX is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            outfile.write(' IX="%s"' % self.gds_format_integer(self.IX, input_name='IX'))
        if self.Del is not None and 'Del' not in already_processed:
            already_processed.add('Del')
            outfile.write(' Del="%s"' % self.gds_format_integer(self.Del, input_name='Del'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IndexedRow_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IX', node)
        if value is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            self.IX = self.gds_parse_integer(value, node, 'IX')
        value = find_attr_value_('Del', node)
        if value is not None and 'Del' not in already_processed:
            already_processed.add('Del')
            self.Del = self.gds_parse_integer(value, node, 'Del')
            self.validate_ISOBoolean(self.Del)    # validate type ISOBoolean
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class IndexedRow_Type


class NamedRow_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Name=None, NameU=None, Del=None, ID=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Name = _cast(None, Name)
        self.Name_nsprefix_ = None
        self.NameU = _cast(None, NameU)
        self.NameU_nsprefix_ = None
        self.Del = _cast(int, Del)
        self.Del_nsprefix_ = None
        self.ID = _cast(int, ID)
        self.ID_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamedRow_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamedRow_Type.subclass:
            return NamedRow_Type.subclass(*args_, **kwargs_)
        else:
            return NamedRow_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_NameU(self):
        return self.NameU
    def set_NameU(self, NameU):
        self.NameU = NameU
    def get_Del(self):
        return self.Del
    def set_Del(self, Del):
        self.Del = Del
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ISOBoolean(self, value):
        # Validate type ISOBoolean, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [0, 1]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ISOBoolean' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NamedRow_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamedRow_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NamedRow_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NamedRow_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NamedRow_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NamedRow_Type'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Name), input_name='Name')), ))
        if self.NameU is not None and 'NameU' not in already_processed:
            already_processed.add('NameU')
            outfile.write(' NameU=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NameU), input_name='NameU')), ))
        if self.Del is not None and 'Del' not in already_processed:
            already_processed.add('Del')
            outfile.write(' Del="%s"' % self.gds_format_integer(self.Del, input_name='Del'))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NamedRow_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('NameU', node)
        if value is not None and 'NameU' not in already_processed:
            already_processed.add('NameU')
            self.NameU = value
        value = find_attr_value_('Del', node)
        if value is not None and 'Del' not in already_processed:
            already_processed.add('Del')
            self.Del = self.gds_parse_integer(value, node, 'Del')
            self.validate_ISOBoolean(self.Del)    # validate type ISOBoolean
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = self.gds_parse_integer(value, node, 'ID')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NamedRow_Type


class NamedIndexedRow_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Name=None, NameU=None, Del=None, ID=None, IX=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Name = _cast(None, Name)
        self.Name_nsprefix_ = None
        self.NameU = _cast(None, NameU)
        self.NameU_nsprefix_ = None
        self.Del = _cast(int, Del)
        self.Del_nsprefix_ = None
        self.ID = _cast(int, ID)
        self.ID_nsprefix_ = None
        self.IX = _cast(int, IX)
        self.IX_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamedIndexedRow_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamedIndexedRow_Type.subclass:
            return NamedIndexedRow_Type.subclass(*args_, **kwargs_)
        else:
            return NamedIndexedRow_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_NameU(self):
        return self.NameU
    def set_NameU(self, NameU):
        self.NameU = NameU
    def get_Del(self):
        return self.Del
    def set_Del(self, Del):
        self.Del = Del
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_IX(self):
        return self.IX
    def set_IX(self, IX):
        self.IX = IX
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ISOBoolean(self, value):
        # Validate type ISOBoolean, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [0, 1]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ISOBoolean' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NamedIndexedRow_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamedIndexedRow_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NamedIndexedRow_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NamedIndexedRow_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NamedIndexedRow_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NamedIndexedRow_Type'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Name), input_name='Name')), ))
        if self.NameU is not None and 'NameU' not in already_processed:
            already_processed.add('NameU')
            outfile.write(' NameU=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NameU), input_name='NameU')), ))
        if self.Del is not None and 'Del' not in already_processed:
            already_processed.add('Del')
            outfile.write(' Del="%s"' % self.gds_format_integer(self.Del, input_name='Del'))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.IX is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            outfile.write(' IX="%s"' % self.gds_format_integer(self.IX, input_name='IX'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NamedIndexedRow_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('NameU', node)
        if value is not None and 'NameU' not in already_processed:
            already_processed.add('NameU')
            self.NameU = value
        value = find_attr_value_('Del', node)
        if value is not None and 'Del' not in already_processed:
            already_processed.add('Del')
            self.Del = self.gds_parse_integer(value, node, 'Del')
            self.validate_ISOBoolean(self.Del)    # validate type ISOBoolean
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = self.gds_parse_integer(value, node, 'ID')
        value = find_attr_value_('IX', node)
        if value is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            self.IX = self.gds_parse_integer(value, node, 'IX')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NamedIndexedRow_Type


class GeomSection_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, IX=None, Del=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.IX = _cast(int, IX)
        self.IX_nsprefix_ = None
        self.Del = _cast(int, Del)
        self.Del_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeomSection_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeomSection_Type.subclass:
            return GeomSection_Type.subclass(*args_, **kwargs_)
        else:
            return GeomSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IX(self):
        return self.IX
    def set_IX(self, IX):
        self.IX = IX
    def get_Del(self):
        return self.Del
    def set_Del(self, Del):
        self.Del = Del
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ISOBoolean(self, value):
        # Validate type ISOBoolean, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [0, 1]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ISOBoolean' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GeomSection_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeomSection_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GeomSection_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeomSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GeomSection_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GeomSection_Type'):
        if self.IX is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            outfile.write(' IX="%s"' % self.gds_format_integer(self.IX, input_name='IX'))
        if self.Del is not None and 'Del' not in already_processed:
            already_processed.add('Del')
            outfile.write(' Del="%s"' % self.gds_format_integer(self.Del, input_name='Del'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GeomSection_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IX', node)
        if value is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            self.IX = self.gds_parse_integer(value, node, 'IX')
        value = find_attr_value_('Del', node)
        if value is not None and 'Del' not in already_processed:
            already_processed.add('Del')
            self.Del = self.gds_parse_integer(value, node, 'Del')
            self.validate_ISOBoolean(self.Del)    # validate type ISOBoolean
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class GeomSection_Type


class Cell_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Unit = _cast(None, Unit)
        self.Unit_nsprefix_ = None
        self.F = _cast(None, F)
        self.F_nsprefix_ = None
        self.Err = _cast(None, Err)
        self.Err_nsprefix_ = None
        self.V = _cast(None, V)
        self.V_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cell_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cell_Type.subclass:
            return Cell_Type.subclass(*args_, **kwargs_)
        else:
            return Cell_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Unit(self):
        return self.Unit
    def set_Unit(self, Unit):
        self.Unit = Unit
    def get_F(self):
        return self.F
    def set_F(self, F):
        self.F = F
    def get_Err(self):
        return self.Err
    def set_Err(self, Err):
        self.Err = Err
    def get_V(self):
        return self.V
    def set_V(self, V):
        self.V = V
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Cell_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Cell_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Cell_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Cell_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Cell_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Cell_Type'):
        if self.Unit is not None and 'Unit' not in already_processed:
            already_processed.add('Unit')
            outfile.write(' Unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Unit), input_name='Unit')), ))
        if self.F is not None and 'F' not in already_processed:
            already_processed.add('F')
            outfile.write(' F=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.F), input_name='F')), ))
        if self.Err is not None and 'Err' not in already_processed:
            already_processed.add('Err')
            outfile.write(' Err=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Err), input_name='Err')), ))
        if self.V is not None and 'V' not in already_processed:
            already_processed.add('V')
            outfile.write(' V=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.V), input_name='V')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Cell_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Unit', node)
        if value is not None and 'Unit' not in already_processed:
            already_processed.add('Unit')
            self.Unit = value
        value = find_attr_value_('F', node)
        if value is not None and 'F' not in already_processed:
            already_processed.add('F')
            self.F = value
        value = find_attr_value_('Err', node)
        if value is not None and 'Err' not in already_processed:
            already_processed.add('Err')
            self.Err = value
        value = find_attr_value_('V', node)
        if value is not None and 'V' not in already_processed:
            already_processed.add('V')
            self.V = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Cell_Type


class ExtendableCell_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Unit=None, F=None, Err=None, V=None, SolutionXML=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Unit = _cast(None, Unit)
        self.Unit_nsprefix_ = None
        self.F = _cast(None, F)
        self.F_nsprefix_ = None
        self.Err = _cast(None, Err)
        self.Err_nsprefix_ = None
        self.V = _cast(None, V)
        self.V_nsprefix_ = None
        if SolutionXML is None:
            self.SolutionXML = []
        else:
            self.SolutionXML = SolutionXML
        self.SolutionXML_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExtendableCell_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExtendableCell_Type.subclass:
            return ExtendableCell_Type.subclass(*args_, **kwargs_)
        else:
            return ExtendableCell_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SolutionXML(self):
        return self.SolutionXML
    def set_SolutionXML(self, SolutionXML):
        self.SolutionXML = SolutionXML
    def add_SolutionXML(self, value):
        self.SolutionXML.append(value)
    def insert_SolutionXML_at(self, index, value):
        self.SolutionXML.insert(index, value)
    def replace_SolutionXML_at(self, index, value):
        self.SolutionXML[index] = value
    def get_Unit(self):
        return self.Unit
    def set_Unit(self, Unit):
        self.Unit = Unit
    def get_F(self):
        return self.F
    def set_F(self, F):
        self.F = F
    def get_Err(self):
        return self.Err
    def set_Err(self, Err):
        self.Err = Err
    def get_V(self):
        return self.V
    def set_V(self, V):
        self.V = V
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.SolutionXML or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='ExtendableCell_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExtendableCell_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ExtendableCell_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExtendableCell_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExtendableCell_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExtendableCell_Type'):
        if self.Unit is not None and 'Unit' not in already_processed:
            already_processed.add('Unit')
            outfile.write(' Unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Unit), input_name='Unit')), ))
        if self.F is not None and 'F' not in already_processed:
            already_processed.add('F')
            outfile.write(' F=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.F), input_name='F')), ))
        if self.Err is not None and 'Err' not in already_processed:
            already_processed.add('Err')
            outfile.write(' Err=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Err), input_name='Err')), ))
        if self.V is not None and 'V' not in already_processed:
            already_processed.add('V')
            outfile.write(' V=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.V), input_name='V')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='ExtendableCell_Type', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SolutionXML_ in self.SolutionXML:
            namespaceprefix_ = self.SolutionXML_nsprefix_ + ':' if (UseCapturedNS_ and self.SolutionXML_nsprefix_) else ''
            SolutionXML_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SolutionXML', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Unit', node)
        if value is not None and 'Unit' not in already_processed:
            already_processed.add('Unit')
            self.Unit = value
        value = find_attr_value_('F', node)
        if value is not None and 'F' not in already_processed:
            already_processed.add('F')
            self.F = value
        value = find_attr_value_('Err', node)
        if value is not None and 'Err' not in already_processed:
            already_processed.add('Err')
            self.Err = value
        value = find_attr_value_('V', node)
        if value is not None and 'V' not in already_processed:
            already_processed.add('V')
            self.V = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SolutionXML':
            obj_ = SolutionXML_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'SolutionXML', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_SolutionXML'):
              self.add_SolutionXML(obj_.value)
            elif hasattr(self, 'set_SolutionXML'):
              self.set_SolutionXML(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class ExtendableCell_Type


class SolutionXML_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Name=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Name = _cast(None, Name)
        self.Name_nsprefix_ = None
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SolutionXML_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SolutionXML_Type.subclass:
            return SolutionXML_Type.subclass(*args_, **kwargs_)
        else:
            return SolutionXML_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='SolutionXML_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SolutionXML_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SolutionXML_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SolutionXML_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SolutionXML_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SolutionXML_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Name), input_name='Name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='SolutionXML_Type', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == '':
            obj_ = __ANY__.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class SolutionXML_Type


class TextCell_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, cp=None, pp=None, tp=None, fld=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if cp is None:
            self.cp = []
        else:
            self.cp = cp
        self.cp_nsprefix_ = None
        if pp is None:
            self.pp = []
        else:
            self.pp = pp
        self.pp_nsprefix_ = None
        if tp is None:
            self.tp = []
        else:
            self.tp = tp
        self.tp_nsprefix_ = None
        if fld is None:
            self.fld = []
        else:
            self.fld = fld
        self.fld_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextCell_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextCell_Type.subclass:
            return TextCell_Type.subclass(*args_, **kwargs_)
        else:
            return TextCell_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cp(self):
        return self.cp
    def set_cp(self, cp):
        self.cp = cp
    def add_cp(self, value):
        self.cp.append(value)
    def insert_cp_at(self, index, value):
        self.cp.insert(index, value)
    def replace_cp_at(self, index, value):
        self.cp[index] = value
    def get_pp(self):
        return self.pp
    def set_pp(self, pp):
        self.pp = pp
    def add_pp(self, value):
        self.pp.append(value)
    def insert_pp_at(self, index, value):
        self.pp.insert(index, value)
    def replace_pp_at(self, index, value):
        self.pp[index] = value
    def get_tp(self):
        return self.tp
    def set_tp(self, tp):
        self.tp = tp
    def add_tp(self, value):
        self.tp.append(value)
    def insert_tp_at(self, index, value):
        self.tp.insert(index, value)
    def replace_tp_at(self, index, value):
        self.tp[index] = value
    def get_fld(self):
        return self.fld
    def set_fld(self, fld):
        self.fld = fld
    def add_fld(self, value):
        self.fld.append(value)
    def insert_fld_at(self, index, value):
        self.fld.insert(index, value)
    def replace_fld_at(self, index, value):
        self.fld[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.cp or
            self.pp or
            self.tp or
            self.fld or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='TextCell_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextCell_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextCell_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextCell_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextCell_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextCell_Type'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='TextCell_Type', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cp_ in self.cp:
            namespaceprefix_ = self.cp_nsprefix_ + ':' if (UseCapturedNS_ and self.cp_nsprefix_) else ''
            cp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cp', pretty_print=pretty_print)
        for pp_ in self.pp:
            namespaceprefix_ = self.pp_nsprefix_ + ':' if (UseCapturedNS_ and self.pp_nsprefix_) else ''
            pp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pp', pretty_print=pretty_print)
        for tp_ in self.tp:
            namespaceprefix_ = self.tp_nsprefix_ + ':' if (UseCapturedNS_ and self.tp_nsprefix_) else ''
            tp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tp', pretty_print=pretty_print)
        for fld_ in self.fld:
            namespaceprefix_ = self.fld_nsprefix_ + ':' if (UseCapturedNS_ and self.fld_nsprefix_) else ''
            fld_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fld', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cp':
            obj_ = cp_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'cp', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_cp'):
              self.add_cp(obj_.value)
            elif hasattr(self, 'set_cp'):
              self.set_cp(obj_.value)
        elif nodeName_ == 'pp':
            obj_ = pp_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'pp', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_pp'):
              self.add_pp(obj_.value)
            elif hasattr(self, 'set_pp'):
              self.set_pp(obj_.value)
        elif nodeName_ == 'tp':
            obj_ = tp_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'tp', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_tp'):
              self.add_tp(obj_.value)
            elif hasattr(self, 'set_tp'):
              self.set_tp(obj_.value)
        elif nodeName_ == 'fld':
            obj_ = fld_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'fld', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_fld'):
              self.add_fld(obj_.value)
            elif hasattr(self, 'set_fld'):
              self.set_fld(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class TextCell_Type


class cp_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, IX=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.IX = _cast(int, IX)
        self.IX_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cp_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cp_Type.subclass:
            return cp_Type.subclass(*args_, **kwargs_)
        else:
            return cp_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IX(self):
        return self.IX
    def set_IX(self, IX):
        self.IX = IX
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cp_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cp_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cp_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cp_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cp_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cp_Type'):
        if self.IX is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            outfile.write(' IX="%s"' % self.gds_format_integer(self.IX, input_name='IX'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cp_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IX', node)
        if value is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            self.IX = self.gds_parse_integer(value, node, 'IX')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class cp_Type


class pp_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, IX=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.IX = _cast(int, IX)
        self.IX_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pp_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pp_Type.subclass:
            return pp_Type.subclass(*args_, **kwargs_)
        else:
            return pp_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IX(self):
        return self.IX
    def set_IX(self, IX):
        self.IX = IX
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='pp_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pp_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'pp_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='pp_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='pp_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='pp_Type'):
        if self.IX is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            outfile.write(' IX="%s"' % self.gds_format_integer(self.IX, input_name='IX'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='pp_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IX', node)
        if value is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            self.IX = self.gds_parse_integer(value, node, 'IX')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class pp_Type


class tp_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, IX=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.IX = _cast(int, IX)
        self.IX_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tp_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tp_Type.subclass:
            return tp_Type.subclass(*args_, **kwargs_)
        else:
            return tp_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IX(self):
        return self.IX
    def set_IX(self, IX):
        self.IX = IX
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tp_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tp_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tp_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tp_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tp_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tp_Type'):
        if self.IX is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            outfile.write(' IX="%s"' % self.gds_format_integer(self.IX, input_name='IX'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tp_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IX', node)
        if value is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            self.IX = self.gds_parse_integer(value, node, 'IX')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class tp_Type


class fld_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, IX=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.IX = _cast(int, IX)
        self.IX_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fld_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fld_Type.subclass:
            return fld_Type.subclass(*args_, **kwargs_)
        else:
            return fld_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IX(self):
        return self.IX
    def set_IX(self, IX):
        self.IX = IX
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fld_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fld_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fld_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fld_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fld_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fld_Type'):
        if self.IX is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            outfile.write(' IX="%s"' % self.gds_format_integer(self.IX, input_name='IX'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fld_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IX', node)
        if value is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            self.IX = self.gds_parse_integer(value, node, 'IX')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class fld_Type


class XPropsCell_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, XProp=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if XProp is None:
            self.XProp = []
        else:
            self.XProp = XProp
        self.XProp_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XPropsCell_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XPropsCell_Type.subclass:
            return XPropsCell_Type.subclass(*args_, **kwargs_)
        else:
            return XPropsCell_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_XProp(self):
        return self.XProp
    def set_XProp(self, XProp):
        self.XProp = XProp
    def add_XProp(self, value):
        self.XProp.append(value)
    def insert_XProp_at(self, index, value):
        self.XProp.insert(index, value)
    def replace_XProp_at(self, index, value):
        self.XProp[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.XProp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='XPropsCell_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XPropsCell_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'XPropsCell_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XPropsCell_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XPropsCell_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XPropsCell_Type'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='XPropsCell_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for XProp_ in self.XProp:
            namespaceprefix_ = self.XProp_nsprefix_ + ':' if (UseCapturedNS_ and self.XProp_nsprefix_) else ''
            XProp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XProp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'XProp':
            obj_ = XProp_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XProp.append(obj_)
            obj_.original_tagname_ = 'XProp'
# end class XPropsCell_Type


class XProp_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Name=None, Unit=None, ID=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Name = _cast(None, Name)
        self.Name_nsprefix_ = None
        self.Unit = _cast(None, Unit)
        self.Unit_nsprefix_ = None
        self.ID = _cast(int, ID)
        self.ID_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XProp_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XProp_Type.subclass:
            return XProp_Type.subclass(*args_, **kwargs_)
        else:
            return XProp_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_Unit(self):
        return self.Unit
    def set_Unit(self, Unit):
        self.Unit = Unit
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XProp_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XProp_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'XProp_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XProp_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XProp_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XProp_Type'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Name), input_name='Name')), ))
        if self.Unit is not None and 'Unit' not in already_processed:
            already_processed.add('Unit')
            outfile.write(' Unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Unit), input_name='Unit')), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XProp_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('Unit', node)
        if value is not None and 'Unit' not in already_processed:
            already_processed.add('Unit')
            self.Unit = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = self.gds_parse_integer(value, node, 'ID')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class XProp_Type


class Text_Type(TextCell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = TextCell_Type
    def __init__(self, cp=None, pp=None, tp=None, fld=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Text_Type, self).__init__(cp, pp, tp, fld, valueOf_, mixedclass_, content_,  **kwargs_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Text_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Text_Type.subclass:
            return Text_Type.subclass(*args_, **kwargs_)
        else:
            return Text_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(Text_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Text_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Text_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Text_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Text_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Text_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Text_Type'):
        super(Text_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Text_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Text_Type', fromsubclass_=False, pretty_print=True):
        super(Text_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Text_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(Text_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Text_Type


class XForm_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, PinX=None, PinY=None, Width=None, Height=None, LocPinX=None, LocPinY=None, Angle=None, FlipX=None, FlipY=None, ResizeMode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(XForm_Type, self).__init__(Del,  **kwargs_)
        if PinX is None:
            self.PinX = []
        else:
            self.PinX = PinX
        self.PinX_nsprefix_ = None
        if PinY is None:
            self.PinY = []
        else:
            self.PinY = PinY
        self.PinY_nsprefix_ = None
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        self.Width_nsprefix_ = None
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        self.Height_nsprefix_ = None
        if LocPinX is None:
            self.LocPinX = []
        else:
            self.LocPinX = LocPinX
        self.LocPinX_nsprefix_ = None
        if LocPinY is None:
            self.LocPinY = []
        else:
            self.LocPinY = LocPinY
        self.LocPinY_nsprefix_ = None
        if Angle is None:
            self.Angle = []
        else:
            self.Angle = Angle
        self.Angle_nsprefix_ = None
        if FlipX is None:
            self.FlipX = []
        else:
            self.FlipX = FlipX
        self.FlipX_nsprefix_ = None
        if FlipY is None:
            self.FlipY = []
        else:
            self.FlipY = FlipY
        self.FlipY_nsprefix_ = None
        if ResizeMode is None:
            self.ResizeMode = []
        else:
            self.ResizeMode = ResizeMode
        self.ResizeMode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XForm_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XForm_Type.subclass:
            return XForm_Type.subclass(*args_, **kwargs_)
        else:
            return XForm_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PinX(self):
        return self.PinX
    def set_PinX(self, PinX):
        self.PinX = PinX
    def add_PinX(self, value):
        self.PinX.append(value)
    def insert_PinX_at(self, index, value):
        self.PinX.insert(index, value)
    def replace_PinX_at(self, index, value):
        self.PinX[index] = value
    def get_PinY(self):
        return self.PinY
    def set_PinY(self, PinY):
        self.PinY = PinY
    def add_PinY(self, value):
        self.PinY.append(value)
    def insert_PinY_at(self, index, value):
        self.PinY.insert(index, value)
    def replace_PinY_at(self, index, value):
        self.PinY[index] = value
    def get_Width(self):
        return self.Width
    def set_Width(self, Width):
        self.Width = Width
    def add_Width(self, value):
        self.Width.append(value)
    def insert_Width_at(self, index, value):
        self.Width.insert(index, value)
    def replace_Width_at(self, index, value):
        self.Width[index] = value
    def get_Height(self):
        return self.Height
    def set_Height(self, Height):
        self.Height = Height
    def add_Height(self, value):
        self.Height.append(value)
    def insert_Height_at(self, index, value):
        self.Height.insert(index, value)
    def replace_Height_at(self, index, value):
        self.Height[index] = value
    def get_LocPinX(self):
        return self.LocPinX
    def set_LocPinX(self, LocPinX):
        self.LocPinX = LocPinX
    def add_LocPinX(self, value):
        self.LocPinX.append(value)
    def insert_LocPinX_at(self, index, value):
        self.LocPinX.insert(index, value)
    def replace_LocPinX_at(self, index, value):
        self.LocPinX[index] = value
    def get_LocPinY(self):
        return self.LocPinY
    def set_LocPinY(self, LocPinY):
        self.LocPinY = LocPinY
    def add_LocPinY(self, value):
        self.LocPinY.append(value)
    def insert_LocPinY_at(self, index, value):
        self.LocPinY.insert(index, value)
    def replace_LocPinY_at(self, index, value):
        self.LocPinY[index] = value
    def get_Angle(self):
        return self.Angle
    def set_Angle(self, Angle):
        self.Angle = Angle
    def add_Angle(self, value):
        self.Angle.append(value)
    def insert_Angle_at(self, index, value):
        self.Angle.insert(index, value)
    def replace_Angle_at(self, index, value):
        self.Angle[index] = value
    def get_FlipX(self):
        return self.FlipX
    def set_FlipX(self, FlipX):
        self.FlipX = FlipX
    def add_FlipX(self, value):
        self.FlipX.append(value)
    def insert_FlipX_at(self, index, value):
        self.FlipX.insert(index, value)
    def replace_FlipX_at(self, index, value):
        self.FlipX[index] = value
    def get_FlipY(self):
        return self.FlipY
    def set_FlipY(self, FlipY):
        self.FlipY = FlipY
    def add_FlipY(self, value):
        self.FlipY.append(value)
    def insert_FlipY_at(self, index, value):
        self.FlipY.insert(index, value)
    def replace_FlipY_at(self, index, value):
        self.FlipY[index] = value
    def get_ResizeMode(self):
        return self.ResizeMode
    def set_ResizeMode(self, ResizeMode):
        self.ResizeMode = ResizeMode
    def add_ResizeMode(self, value):
        self.ResizeMode.append(value)
    def insert_ResizeMode_at(self, index, value):
        self.ResizeMode.insert(index, value)
    def replace_ResizeMode_at(self, index, value):
        self.ResizeMode[index] = value
    def hasContent_(self):
        if (
            self.PinX or
            self.PinY or
            self.Width or
            self.Height or
            self.LocPinX or
            self.LocPinY or
            self.Angle or
            self.FlipX or
            self.FlipY or
            self.ResizeMode or
            super(XForm_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='XForm_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XForm_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'XForm_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XForm_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XForm_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XForm_Type'):
        super(XForm_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XForm_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='XForm_Type', fromsubclass_=False, pretty_print=True):
        super(XForm_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PinX_ in self.PinX:
            namespaceprefix_ = self.PinX_nsprefix_ + ':' if (UseCapturedNS_ and self.PinX_nsprefix_) else ''
            PinX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PinX', pretty_print=pretty_print)
        for PinY_ in self.PinY:
            namespaceprefix_ = self.PinY_nsprefix_ + ':' if (UseCapturedNS_ and self.PinY_nsprefix_) else ''
            PinY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PinY', pretty_print=pretty_print)
        for Width_ in self.Width:
            namespaceprefix_ = self.Width_nsprefix_ + ':' if (UseCapturedNS_ and self.Width_nsprefix_) else ''
            Width_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Width', pretty_print=pretty_print)
        for Height_ in self.Height:
            namespaceprefix_ = self.Height_nsprefix_ + ':' if (UseCapturedNS_ and self.Height_nsprefix_) else ''
            Height_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Height', pretty_print=pretty_print)
        for LocPinX_ in self.LocPinX:
            namespaceprefix_ = self.LocPinX_nsprefix_ + ':' if (UseCapturedNS_ and self.LocPinX_nsprefix_) else ''
            LocPinX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocPinX', pretty_print=pretty_print)
        for LocPinY_ in self.LocPinY:
            namespaceprefix_ = self.LocPinY_nsprefix_ + ':' if (UseCapturedNS_ and self.LocPinY_nsprefix_) else ''
            LocPinY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocPinY', pretty_print=pretty_print)
        for Angle_ in self.Angle:
            namespaceprefix_ = self.Angle_nsprefix_ + ':' if (UseCapturedNS_ and self.Angle_nsprefix_) else ''
            Angle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Angle', pretty_print=pretty_print)
        for FlipX_ in self.FlipX:
            namespaceprefix_ = self.FlipX_nsprefix_ + ':' if (UseCapturedNS_ and self.FlipX_nsprefix_) else ''
            FlipX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FlipX', pretty_print=pretty_print)
        for FlipY_ in self.FlipY:
            namespaceprefix_ = self.FlipY_nsprefix_ + ':' if (UseCapturedNS_ and self.FlipY_nsprefix_) else ''
            FlipY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FlipY', pretty_print=pretty_print)
        for ResizeMode_ in self.ResizeMode:
            namespaceprefix_ = self.ResizeMode_nsprefix_ + ':' if (UseCapturedNS_ and self.ResizeMode_nsprefix_) else ''
            ResizeMode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ResizeMode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(XForm_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PinX':
            obj_ = PinX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PinX.append(obj_)
            obj_.original_tagname_ = 'PinX'
        elif nodeName_ == 'PinY':
            obj_ = PinY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PinY.append(obj_)
            obj_.original_tagname_ = 'PinY'
        elif nodeName_ == 'Width':
            obj_ = Width_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Width.append(obj_)
            obj_.original_tagname_ = 'Width'
        elif nodeName_ == 'Height':
            obj_ = Height_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Height.append(obj_)
            obj_.original_tagname_ = 'Height'
        elif nodeName_ == 'LocPinX':
            obj_ = LocPinX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocPinX.append(obj_)
            obj_.original_tagname_ = 'LocPinX'
        elif nodeName_ == 'LocPinY':
            obj_ = LocPinY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocPinY.append(obj_)
            obj_.original_tagname_ = 'LocPinY'
        elif nodeName_ == 'Angle':
            obj_ = Angle_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Angle.append(obj_)
            obj_.original_tagname_ = 'Angle'
        elif nodeName_ == 'FlipX':
            obj_ = FlipX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FlipX.append(obj_)
            obj_.original_tagname_ = 'FlipX'
        elif nodeName_ == 'FlipY':
            obj_ = FlipY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FlipY.append(obj_)
            obj_.original_tagname_ = 'FlipY'
        elif nodeName_ == 'ResizeMode':
            obj_ = ResizeMode_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ResizeMode.append(obj_)
            obj_.original_tagname_ = 'ResizeMode'
        super(XForm_Type, self).buildChildren(child_, node, nodeName_, True)
# end class XForm_Type


class PinX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PinX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PinX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PinX_Type.subclass:
            return PinX_Type.subclass(*args_, **kwargs_)
        else:
            return PinX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PinX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PinX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PinX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PinX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PinX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PinX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PinX_Type'):
        super(PinX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PinX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PinX_Type', fromsubclass_=False, pretty_print=True):
        super(PinX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PinX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PinX_Type


class PinY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PinY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PinY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PinY_Type.subclass:
            return PinY_Type.subclass(*args_, **kwargs_)
        else:
            return PinY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PinY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PinY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PinY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PinY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PinY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PinY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PinY_Type'):
        super(PinY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PinY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PinY_Type', fromsubclass_=False, pretty_print=True):
        super(PinY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PinY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PinY_Type


class Width_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Width_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Width_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Width_Type.subclass:
            return Width_Type.subclass(*args_, **kwargs_)
        else:
            return Width_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Width_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Width_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Width_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Width_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Width_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Width_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Width_Type'):
        super(Width_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Width_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Width_Type', fromsubclass_=False, pretty_print=True):
        super(Width_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Width_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Width_Type


class Height_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Height_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Height_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Height_Type.subclass:
            return Height_Type.subclass(*args_, **kwargs_)
        else:
            return Height_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Height_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Height_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Height_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Height_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Height_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Height_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Height_Type'):
        super(Height_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Height_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Height_Type', fromsubclass_=False, pretty_print=True):
        super(Height_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Height_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Height_Type


class LocPinX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LocPinX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocPinX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocPinX_Type.subclass:
            return LocPinX_Type.subclass(*args_, **kwargs_)
        else:
            return LocPinX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LocPinX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LocPinX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocPinX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LocPinX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocPinX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LocPinX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LocPinX_Type'):
        super(LocPinX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocPinX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LocPinX_Type', fromsubclass_=False, pretty_print=True):
        super(LocPinX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LocPinX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LocPinX_Type


class LocPinY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LocPinY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocPinY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocPinY_Type.subclass:
            return LocPinY_Type.subclass(*args_, **kwargs_)
        else:
            return LocPinY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LocPinY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LocPinY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocPinY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LocPinY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocPinY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LocPinY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LocPinY_Type'):
        super(LocPinY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocPinY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LocPinY_Type', fromsubclass_=False, pretty_print=True):
        super(LocPinY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LocPinY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LocPinY_Type


class Angle_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Angle_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Angle_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Angle_Type.subclass:
            return Angle_Type.subclass(*args_, **kwargs_)
        else:
            return Angle_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Angle_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Angle_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Angle_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Angle_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Angle_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Angle_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Angle_Type'):
        super(Angle_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Angle_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Angle_Type', fromsubclass_=False, pretty_print=True):
        super(Angle_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Angle_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Angle_Type


class FlipX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FlipX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlipX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlipX_Type.subclass:
            return FlipX_Type.subclass(*args_, **kwargs_)
        else:
            return FlipX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(FlipX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FlipX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlipX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FlipX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlipX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlipX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FlipX_Type'):
        super(FlipX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlipX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FlipX_Type', fromsubclass_=False, pretty_print=True):
        super(FlipX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FlipX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FlipX_Type


class FlipY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FlipY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlipY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlipY_Type.subclass:
            return FlipY_Type.subclass(*args_, **kwargs_)
        else:
            return FlipY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(FlipY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FlipY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlipY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FlipY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlipY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlipY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FlipY_Type'):
        super(FlipY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlipY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FlipY_Type', fromsubclass_=False, pretty_print=True):
        super(FlipY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FlipY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FlipY_Type


class ResizeMode_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ResizeMode_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResizeMode_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResizeMode_Type.subclass:
            return ResizeMode_Type.subclass(*args_, **kwargs_)
        else:
            return ResizeMode_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ResizeMode_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ResizeMode_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResizeMode_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ResizeMode_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResizeMode_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResizeMode_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResizeMode_Type'):
        super(ResizeMode_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResizeMode_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ResizeMode_Type', fromsubclass_=False, pretty_print=True):
        super(ResizeMode_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ResizeMode_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ResizeMode_Type


class Line_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, LineWeight=None, LineColor=None, LinePattern=None, Rounding=None, EndArrowSize=None, BeginArrow=None, EndArrow=None, LineCap=None, BeginArrowSize=None, LineColorTrans=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Line_Type, self).__init__(Del,  **kwargs_)
        if LineWeight is None:
            self.LineWeight = []
        else:
            self.LineWeight = LineWeight
        self.LineWeight_nsprefix_ = None
        if LineColor is None:
            self.LineColor = []
        else:
            self.LineColor = LineColor
        self.LineColor_nsprefix_ = None
        if LinePattern is None:
            self.LinePattern = []
        else:
            self.LinePattern = LinePattern
        self.LinePattern_nsprefix_ = None
        if Rounding is None:
            self.Rounding = []
        else:
            self.Rounding = Rounding
        self.Rounding_nsprefix_ = None
        if EndArrowSize is None:
            self.EndArrowSize = []
        else:
            self.EndArrowSize = EndArrowSize
        self.EndArrowSize_nsprefix_ = None
        if BeginArrow is None:
            self.BeginArrow = []
        else:
            self.BeginArrow = BeginArrow
        self.BeginArrow_nsprefix_ = None
        if EndArrow is None:
            self.EndArrow = []
        else:
            self.EndArrow = EndArrow
        self.EndArrow_nsprefix_ = None
        if LineCap is None:
            self.LineCap = []
        else:
            self.LineCap = LineCap
        self.LineCap_nsprefix_ = None
        if BeginArrowSize is None:
            self.BeginArrowSize = []
        else:
            self.BeginArrowSize = BeginArrowSize
        self.BeginArrowSize_nsprefix_ = None
        if LineColorTrans is None:
            self.LineColorTrans = []
        else:
            self.LineColorTrans = LineColorTrans
        self.LineColorTrans_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Line_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Line_Type.subclass:
            return Line_Type.subclass(*args_, **kwargs_)
        else:
            return Line_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LineWeight(self):
        return self.LineWeight
    def set_LineWeight(self, LineWeight):
        self.LineWeight = LineWeight
    def add_LineWeight(self, value):
        self.LineWeight.append(value)
    def insert_LineWeight_at(self, index, value):
        self.LineWeight.insert(index, value)
    def replace_LineWeight_at(self, index, value):
        self.LineWeight[index] = value
    def get_LineColor(self):
        return self.LineColor
    def set_LineColor(self, LineColor):
        self.LineColor = LineColor
    def add_LineColor(self, value):
        self.LineColor.append(value)
    def insert_LineColor_at(self, index, value):
        self.LineColor.insert(index, value)
    def replace_LineColor_at(self, index, value):
        self.LineColor[index] = value
    def get_LinePattern(self):
        return self.LinePattern
    def set_LinePattern(self, LinePattern):
        self.LinePattern = LinePattern
    def add_LinePattern(self, value):
        self.LinePattern.append(value)
    def insert_LinePattern_at(self, index, value):
        self.LinePattern.insert(index, value)
    def replace_LinePattern_at(self, index, value):
        self.LinePattern[index] = value
    def get_Rounding(self):
        return self.Rounding
    def set_Rounding(self, Rounding):
        self.Rounding = Rounding
    def add_Rounding(self, value):
        self.Rounding.append(value)
    def insert_Rounding_at(self, index, value):
        self.Rounding.insert(index, value)
    def replace_Rounding_at(self, index, value):
        self.Rounding[index] = value
    def get_EndArrowSize(self):
        return self.EndArrowSize
    def set_EndArrowSize(self, EndArrowSize):
        self.EndArrowSize = EndArrowSize
    def add_EndArrowSize(self, value):
        self.EndArrowSize.append(value)
    def insert_EndArrowSize_at(self, index, value):
        self.EndArrowSize.insert(index, value)
    def replace_EndArrowSize_at(self, index, value):
        self.EndArrowSize[index] = value
    def get_BeginArrow(self):
        return self.BeginArrow
    def set_BeginArrow(self, BeginArrow):
        self.BeginArrow = BeginArrow
    def add_BeginArrow(self, value):
        self.BeginArrow.append(value)
    def insert_BeginArrow_at(self, index, value):
        self.BeginArrow.insert(index, value)
    def replace_BeginArrow_at(self, index, value):
        self.BeginArrow[index] = value
    def get_EndArrow(self):
        return self.EndArrow
    def set_EndArrow(self, EndArrow):
        self.EndArrow = EndArrow
    def add_EndArrow(self, value):
        self.EndArrow.append(value)
    def insert_EndArrow_at(self, index, value):
        self.EndArrow.insert(index, value)
    def replace_EndArrow_at(self, index, value):
        self.EndArrow[index] = value
    def get_LineCap(self):
        return self.LineCap
    def set_LineCap(self, LineCap):
        self.LineCap = LineCap
    def add_LineCap(self, value):
        self.LineCap.append(value)
    def insert_LineCap_at(self, index, value):
        self.LineCap.insert(index, value)
    def replace_LineCap_at(self, index, value):
        self.LineCap[index] = value
    def get_BeginArrowSize(self):
        return self.BeginArrowSize
    def set_BeginArrowSize(self, BeginArrowSize):
        self.BeginArrowSize = BeginArrowSize
    def add_BeginArrowSize(self, value):
        self.BeginArrowSize.append(value)
    def insert_BeginArrowSize_at(self, index, value):
        self.BeginArrowSize.insert(index, value)
    def replace_BeginArrowSize_at(self, index, value):
        self.BeginArrowSize[index] = value
    def get_LineColorTrans(self):
        return self.LineColorTrans
    def set_LineColorTrans(self, LineColorTrans):
        self.LineColorTrans = LineColorTrans
    def add_LineColorTrans(self, value):
        self.LineColorTrans.append(value)
    def insert_LineColorTrans_at(self, index, value):
        self.LineColorTrans.insert(index, value)
    def replace_LineColorTrans_at(self, index, value):
        self.LineColorTrans[index] = value
    def hasContent_(self):
        if (
            self.LineWeight or
            self.LineColor or
            self.LinePattern or
            self.Rounding or
            self.EndArrowSize or
            self.BeginArrow or
            self.EndArrow or
            self.LineCap or
            self.BeginArrowSize or
            self.LineColorTrans or
            super(Line_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Line_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Line_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Line_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Line_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Line_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Line_Type'):
        super(Line_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Line_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Line_Type', fromsubclass_=False, pretty_print=True):
        super(Line_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LineWeight_ in self.LineWeight:
            namespaceprefix_ = self.LineWeight_nsprefix_ + ':' if (UseCapturedNS_ and self.LineWeight_nsprefix_) else ''
            LineWeight_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineWeight', pretty_print=pretty_print)
        for LineColor_ in self.LineColor:
            namespaceprefix_ = self.LineColor_nsprefix_ + ':' if (UseCapturedNS_ and self.LineColor_nsprefix_) else ''
            LineColor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineColor', pretty_print=pretty_print)
        for LinePattern_ in self.LinePattern:
            namespaceprefix_ = self.LinePattern_nsprefix_ + ':' if (UseCapturedNS_ and self.LinePattern_nsprefix_) else ''
            LinePattern_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LinePattern', pretty_print=pretty_print)
        for Rounding_ in self.Rounding:
            namespaceprefix_ = self.Rounding_nsprefix_ + ':' if (UseCapturedNS_ and self.Rounding_nsprefix_) else ''
            Rounding_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Rounding', pretty_print=pretty_print)
        for EndArrowSize_ in self.EndArrowSize:
            namespaceprefix_ = self.EndArrowSize_nsprefix_ + ':' if (UseCapturedNS_ and self.EndArrowSize_nsprefix_) else ''
            EndArrowSize_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EndArrowSize', pretty_print=pretty_print)
        for BeginArrow_ in self.BeginArrow:
            namespaceprefix_ = self.BeginArrow_nsprefix_ + ':' if (UseCapturedNS_ and self.BeginArrow_nsprefix_) else ''
            BeginArrow_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BeginArrow', pretty_print=pretty_print)
        for EndArrow_ in self.EndArrow:
            namespaceprefix_ = self.EndArrow_nsprefix_ + ':' if (UseCapturedNS_ and self.EndArrow_nsprefix_) else ''
            EndArrow_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EndArrow', pretty_print=pretty_print)
        for LineCap_ in self.LineCap:
            namespaceprefix_ = self.LineCap_nsprefix_ + ':' if (UseCapturedNS_ and self.LineCap_nsprefix_) else ''
            LineCap_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineCap', pretty_print=pretty_print)
        for BeginArrowSize_ in self.BeginArrowSize:
            namespaceprefix_ = self.BeginArrowSize_nsprefix_ + ':' if (UseCapturedNS_ and self.BeginArrowSize_nsprefix_) else ''
            BeginArrowSize_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BeginArrowSize', pretty_print=pretty_print)
        for LineColorTrans_ in self.LineColorTrans:
            namespaceprefix_ = self.LineColorTrans_nsprefix_ + ':' if (UseCapturedNS_ and self.LineColorTrans_nsprefix_) else ''
            LineColorTrans_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineColorTrans', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Line_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LineWeight':
            obj_ = LineWeight_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineWeight.append(obj_)
            obj_.original_tagname_ = 'LineWeight'
        elif nodeName_ == 'LineColor':
            obj_ = LineColor_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineColor.append(obj_)
            obj_.original_tagname_ = 'LineColor'
        elif nodeName_ == 'LinePattern':
            obj_ = LinePattern_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LinePattern.append(obj_)
            obj_.original_tagname_ = 'LinePattern'
        elif nodeName_ == 'Rounding':
            obj_ = Rounding_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Rounding.append(obj_)
            obj_.original_tagname_ = 'Rounding'
        elif nodeName_ == 'EndArrowSize':
            obj_ = EndArrowSize_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EndArrowSize.append(obj_)
            obj_.original_tagname_ = 'EndArrowSize'
        elif nodeName_ == 'BeginArrow':
            obj_ = BeginArrow_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BeginArrow.append(obj_)
            obj_.original_tagname_ = 'BeginArrow'
        elif nodeName_ == 'EndArrow':
            obj_ = EndArrow_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EndArrow.append(obj_)
            obj_.original_tagname_ = 'EndArrow'
        elif nodeName_ == 'LineCap':
            obj_ = LineCap_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineCap.append(obj_)
            obj_.original_tagname_ = 'LineCap'
        elif nodeName_ == 'BeginArrowSize':
            obj_ = BeginArrowSize_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BeginArrowSize.append(obj_)
            obj_.original_tagname_ = 'BeginArrowSize'
        elif nodeName_ == 'LineColorTrans':
            obj_ = LineColorTrans_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineColorTrans.append(obj_)
            obj_.original_tagname_ = 'LineColorTrans'
        super(Line_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Line_Type


class LineWeight_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineWeight_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineWeight_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineWeight_Type.subclass:
            return LineWeight_Type.subclass(*args_, **kwargs_)
        else:
            return LineWeight_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LineWeight_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineWeight_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineWeight_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineWeight_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineWeight_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineWeight_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineWeight_Type'):
        super(LineWeight_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineWeight_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineWeight_Type', fromsubclass_=False, pretty_print=True):
        super(LineWeight_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineWeight_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LineWeight_Type


class LineColor_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineColor_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineColor_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineColor_Type.subclass:
            return LineColor_Type.subclass(*args_, **kwargs_)
        else:
            return LineColor_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LineColor_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineColor_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineColor_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineColor_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineColor_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineColor_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineColor_Type'):
        super(LineColor_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineColor_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineColor_Type', fromsubclass_=False, pretty_print=True):
        super(LineColor_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineColor_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LineColor_Type


class LinePattern_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LinePattern_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinePattern_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinePattern_Type.subclass:
            return LinePattern_Type.subclass(*args_, **kwargs_)
        else:
            return LinePattern_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LinePattern_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LinePattern_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LinePattern_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LinePattern_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LinePattern_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LinePattern_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LinePattern_Type'):
        super(LinePattern_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LinePattern_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LinePattern_Type', fromsubclass_=False, pretty_print=True):
        super(LinePattern_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LinePattern_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LinePattern_Type


class Rounding_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Rounding_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Rounding_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Rounding_Type.subclass:
            return Rounding_Type.subclass(*args_, **kwargs_)
        else:
            return Rounding_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Rounding_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Rounding_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Rounding_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Rounding_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Rounding_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Rounding_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Rounding_Type'):
        super(Rounding_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Rounding_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Rounding_Type', fromsubclass_=False, pretty_print=True):
        super(Rounding_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Rounding_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Rounding_Type


class EndArrowSize_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EndArrowSize_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndArrowSize_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndArrowSize_Type.subclass:
            return EndArrowSize_Type.subclass(*args_, **kwargs_)
        else:
            return EndArrowSize_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EndArrowSize_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndArrowSize_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EndArrowSize_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EndArrowSize_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndArrowSize_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EndArrowSize_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EndArrowSize_Type'):
        super(EndArrowSize_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndArrowSize_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndArrowSize_Type', fromsubclass_=False, pretty_print=True):
        super(EndArrowSize_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EndArrowSize_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EndArrowSize_Type


class BeginArrow_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BeginArrow_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BeginArrow_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BeginArrow_Type.subclass:
            return BeginArrow_Type.subclass(*args_, **kwargs_)
        else:
            return BeginArrow_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(BeginArrow_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BeginArrow_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BeginArrow_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BeginArrow_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BeginArrow_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BeginArrow_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BeginArrow_Type'):
        super(BeginArrow_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BeginArrow_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BeginArrow_Type', fromsubclass_=False, pretty_print=True):
        super(BeginArrow_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BeginArrow_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BeginArrow_Type


class EndArrow_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EndArrow_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndArrow_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndArrow_Type.subclass:
            return EndArrow_Type.subclass(*args_, **kwargs_)
        else:
            return EndArrow_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EndArrow_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndArrow_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EndArrow_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EndArrow_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndArrow_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EndArrow_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EndArrow_Type'):
        super(EndArrow_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndArrow_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndArrow_Type', fromsubclass_=False, pretty_print=True):
        super(EndArrow_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EndArrow_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EndArrow_Type


class LineCap_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineCap_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineCap_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineCap_Type.subclass:
            return LineCap_Type.subclass(*args_, **kwargs_)
        else:
            return LineCap_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LineCap_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineCap_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineCap_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineCap_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineCap_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineCap_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineCap_Type'):
        super(LineCap_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineCap_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineCap_Type', fromsubclass_=False, pretty_print=True):
        super(LineCap_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineCap_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LineCap_Type


class BeginArrowSize_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BeginArrowSize_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BeginArrowSize_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BeginArrowSize_Type.subclass:
            return BeginArrowSize_Type.subclass(*args_, **kwargs_)
        else:
            return BeginArrowSize_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(BeginArrowSize_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BeginArrowSize_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BeginArrowSize_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BeginArrowSize_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BeginArrowSize_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BeginArrowSize_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BeginArrowSize_Type'):
        super(BeginArrowSize_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BeginArrowSize_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BeginArrowSize_Type', fromsubclass_=False, pretty_print=True):
        super(BeginArrowSize_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BeginArrowSize_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BeginArrowSize_Type


class LineColorTrans_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineColorTrans_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineColorTrans_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineColorTrans_Type.subclass:
            return LineColorTrans_Type.subclass(*args_, **kwargs_)
        else:
            return LineColorTrans_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LineColorTrans_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineColorTrans_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineColorTrans_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineColorTrans_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineColorTrans_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineColorTrans_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineColorTrans_Type'):
        super(LineColorTrans_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineColorTrans_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineColorTrans_Type', fromsubclass_=False, pretty_print=True):
        super(LineColorTrans_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineColorTrans_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LineColorTrans_Type


class Fill_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, FillForegnd=None, FillBkgnd=None, FillPattern=None, ShdwForegnd=None, ShdwBkgnd=None, ShdwPattern=None, FillForegndTrans=None, FillBkgndTrans=None, ShdwForegndTrans=None, ShdwBkgndTrans=None, ShapeShdwType=None, ShapeShdwOffsetX=None, ShapeShdwOffsetY=None, ShapeShdwObliqueAngle=None, ShapeShdwScaleFactor=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Fill_Type, self).__init__(Del,  **kwargs_)
        if FillForegnd is None:
            self.FillForegnd = []
        else:
            self.FillForegnd = FillForegnd
        self.FillForegnd_nsprefix_ = None
        if FillBkgnd is None:
            self.FillBkgnd = []
        else:
            self.FillBkgnd = FillBkgnd
        self.FillBkgnd_nsprefix_ = None
        if FillPattern is None:
            self.FillPattern = []
        else:
            self.FillPattern = FillPattern
        self.FillPattern_nsprefix_ = None
        if ShdwForegnd is None:
            self.ShdwForegnd = []
        else:
            self.ShdwForegnd = ShdwForegnd
        self.ShdwForegnd_nsprefix_ = None
        if ShdwBkgnd is None:
            self.ShdwBkgnd = []
        else:
            self.ShdwBkgnd = ShdwBkgnd
        self.ShdwBkgnd_nsprefix_ = None
        if ShdwPattern is None:
            self.ShdwPattern = []
        else:
            self.ShdwPattern = ShdwPattern
        self.ShdwPattern_nsprefix_ = None
        if FillForegndTrans is None:
            self.FillForegndTrans = []
        else:
            self.FillForegndTrans = FillForegndTrans
        self.FillForegndTrans_nsprefix_ = None
        if FillBkgndTrans is None:
            self.FillBkgndTrans = []
        else:
            self.FillBkgndTrans = FillBkgndTrans
        self.FillBkgndTrans_nsprefix_ = None
        if ShdwForegndTrans is None:
            self.ShdwForegndTrans = []
        else:
            self.ShdwForegndTrans = ShdwForegndTrans
        self.ShdwForegndTrans_nsprefix_ = None
        if ShdwBkgndTrans is None:
            self.ShdwBkgndTrans = []
        else:
            self.ShdwBkgndTrans = ShdwBkgndTrans
        self.ShdwBkgndTrans_nsprefix_ = None
        if ShapeShdwType is None:
            self.ShapeShdwType = []
        else:
            self.ShapeShdwType = ShapeShdwType
        self.ShapeShdwType_nsprefix_ = None
        if ShapeShdwOffsetX is None:
            self.ShapeShdwOffsetX = []
        else:
            self.ShapeShdwOffsetX = ShapeShdwOffsetX
        self.ShapeShdwOffsetX_nsprefix_ = None
        if ShapeShdwOffsetY is None:
            self.ShapeShdwOffsetY = []
        else:
            self.ShapeShdwOffsetY = ShapeShdwOffsetY
        self.ShapeShdwOffsetY_nsprefix_ = None
        if ShapeShdwObliqueAngle is None:
            self.ShapeShdwObliqueAngle = []
        else:
            self.ShapeShdwObliqueAngle = ShapeShdwObliqueAngle
        self.ShapeShdwObliqueAngle_nsprefix_ = None
        if ShapeShdwScaleFactor is None:
            self.ShapeShdwScaleFactor = []
        else:
            self.ShapeShdwScaleFactor = ShapeShdwScaleFactor
        self.ShapeShdwScaleFactor_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Fill_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Fill_Type.subclass:
            return Fill_Type.subclass(*args_, **kwargs_)
        else:
            return Fill_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FillForegnd(self):
        return self.FillForegnd
    def set_FillForegnd(self, FillForegnd):
        self.FillForegnd = FillForegnd
    def add_FillForegnd(self, value):
        self.FillForegnd.append(value)
    def insert_FillForegnd_at(self, index, value):
        self.FillForegnd.insert(index, value)
    def replace_FillForegnd_at(self, index, value):
        self.FillForegnd[index] = value
    def get_FillBkgnd(self):
        return self.FillBkgnd
    def set_FillBkgnd(self, FillBkgnd):
        self.FillBkgnd = FillBkgnd
    def add_FillBkgnd(self, value):
        self.FillBkgnd.append(value)
    def insert_FillBkgnd_at(self, index, value):
        self.FillBkgnd.insert(index, value)
    def replace_FillBkgnd_at(self, index, value):
        self.FillBkgnd[index] = value
    def get_FillPattern(self):
        return self.FillPattern
    def set_FillPattern(self, FillPattern):
        self.FillPattern = FillPattern
    def add_FillPattern(self, value):
        self.FillPattern.append(value)
    def insert_FillPattern_at(self, index, value):
        self.FillPattern.insert(index, value)
    def replace_FillPattern_at(self, index, value):
        self.FillPattern[index] = value
    def get_ShdwForegnd(self):
        return self.ShdwForegnd
    def set_ShdwForegnd(self, ShdwForegnd):
        self.ShdwForegnd = ShdwForegnd
    def add_ShdwForegnd(self, value):
        self.ShdwForegnd.append(value)
    def insert_ShdwForegnd_at(self, index, value):
        self.ShdwForegnd.insert(index, value)
    def replace_ShdwForegnd_at(self, index, value):
        self.ShdwForegnd[index] = value
    def get_ShdwBkgnd(self):
        return self.ShdwBkgnd
    def set_ShdwBkgnd(self, ShdwBkgnd):
        self.ShdwBkgnd = ShdwBkgnd
    def add_ShdwBkgnd(self, value):
        self.ShdwBkgnd.append(value)
    def insert_ShdwBkgnd_at(self, index, value):
        self.ShdwBkgnd.insert(index, value)
    def replace_ShdwBkgnd_at(self, index, value):
        self.ShdwBkgnd[index] = value
    def get_ShdwPattern(self):
        return self.ShdwPattern
    def set_ShdwPattern(self, ShdwPattern):
        self.ShdwPattern = ShdwPattern
    def add_ShdwPattern(self, value):
        self.ShdwPattern.append(value)
    def insert_ShdwPattern_at(self, index, value):
        self.ShdwPattern.insert(index, value)
    def replace_ShdwPattern_at(self, index, value):
        self.ShdwPattern[index] = value
    def get_FillForegndTrans(self):
        return self.FillForegndTrans
    def set_FillForegndTrans(self, FillForegndTrans):
        self.FillForegndTrans = FillForegndTrans
    def add_FillForegndTrans(self, value):
        self.FillForegndTrans.append(value)
    def insert_FillForegndTrans_at(self, index, value):
        self.FillForegndTrans.insert(index, value)
    def replace_FillForegndTrans_at(self, index, value):
        self.FillForegndTrans[index] = value
    def get_FillBkgndTrans(self):
        return self.FillBkgndTrans
    def set_FillBkgndTrans(self, FillBkgndTrans):
        self.FillBkgndTrans = FillBkgndTrans
    def add_FillBkgndTrans(self, value):
        self.FillBkgndTrans.append(value)
    def insert_FillBkgndTrans_at(self, index, value):
        self.FillBkgndTrans.insert(index, value)
    def replace_FillBkgndTrans_at(self, index, value):
        self.FillBkgndTrans[index] = value
    def get_ShdwForegndTrans(self):
        return self.ShdwForegndTrans
    def set_ShdwForegndTrans(self, ShdwForegndTrans):
        self.ShdwForegndTrans = ShdwForegndTrans
    def add_ShdwForegndTrans(self, value):
        self.ShdwForegndTrans.append(value)
    def insert_ShdwForegndTrans_at(self, index, value):
        self.ShdwForegndTrans.insert(index, value)
    def replace_ShdwForegndTrans_at(self, index, value):
        self.ShdwForegndTrans[index] = value
    def get_ShdwBkgndTrans(self):
        return self.ShdwBkgndTrans
    def set_ShdwBkgndTrans(self, ShdwBkgndTrans):
        self.ShdwBkgndTrans = ShdwBkgndTrans
    def add_ShdwBkgndTrans(self, value):
        self.ShdwBkgndTrans.append(value)
    def insert_ShdwBkgndTrans_at(self, index, value):
        self.ShdwBkgndTrans.insert(index, value)
    def replace_ShdwBkgndTrans_at(self, index, value):
        self.ShdwBkgndTrans[index] = value
    def get_ShapeShdwType(self):
        return self.ShapeShdwType
    def set_ShapeShdwType(self, ShapeShdwType):
        self.ShapeShdwType = ShapeShdwType
    def add_ShapeShdwType(self, value):
        self.ShapeShdwType.append(value)
    def insert_ShapeShdwType_at(self, index, value):
        self.ShapeShdwType.insert(index, value)
    def replace_ShapeShdwType_at(self, index, value):
        self.ShapeShdwType[index] = value
    def get_ShapeShdwOffsetX(self):
        return self.ShapeShdwOffsetX
    def set_ShapeShdwOffsetX(self, ShapeShdwOffsetX):
        self.ShapeShdwOffsetX = ShapeShdwOffsetX
    def add_ShapeShdwOffsetX(self, value):
        self.ShapeShdwOffsetX.append(value)
    def insert_ShapeShdwOffsetX_at(self, index, value):
        self.ShapeShdwOffsetX.insert(index, value)
    def replace_ShapeShdwOffsetX_at(self, index, value):
        self.ShapeShdwOffsetX[index] = value
    def get_ShapeShdwOffsetY(self):
        return self.ShapeShdwOffsetY
    def set_ShapeShdwOffsetY(self, ShapeShdwOffsetY):
        self.ShapeShdwOffsetY = ShapeShdwOffsetY
    def add_ShapeShdwOffsetY(self, value):
        self.ShapeShdwOffsetY.append(value)
    def insert_ShapeShdwOffsetY_at(self, index, value):
        self.ShapeShdwOffsetY.insert(index, value)
    def replace_ShapeShdwOffsetY_at(self, index, value):
        self.ShapeShdwOffsetY[index] = value
    def get_ShapeShdwObliqueAngle(self):
        return self.ShapeShdwObliqueAngle
    def set_ShapeShdwObliqueAngle(self, ShapeShdwObliqueAngle):
        self.ShapeShdwObliqueAngle = ShapeShdwObliqueAngle
    def add_ShapeShdwObliqueAngle(self, value):
        self.ShapeShdwObliqueAngle.append(value)
    def insert_ShapeShdwObliqueAngle_at(self, index, value):
        self.ShapeShdwObliqueAngle.insert(index, value)
    def replace_ShapeShdwObliqueAngle_at(self, index, value):
        self.ShapeShdwObliqueAngle[index] = value
    def get_ShapeShdwScaleFactor(self):
        return self.ShapeShdwScaleFactor
    def set_ShapeShdwScaleFactor(self, ShapeShdwScaleFactor):
        self.ShapeShdwScaleFactor = ShapeShdwScaleFactor
    def add_ShapeShdwScaleFactor(self, value):
        self.ShapeShdwScaleFactor.append(value)
    def insert_ShapeShdwScaleFactor_at(self, index, value):
        self.ShapeShdwScaleFactor.insert(index, value)
    def replace_ShapeShdwScaleFactor_at(self, index, value):
        self.ShapeShdwScaleFactor[index] = value
    def hasContent_(self):
        if (
            self.FillForegnd or
            self.FillBkgnd or
            self.FillPattern or
            self.ShdwForegnd or
            self.ShdwBkgnd or
            self.ShdwPattern or
            self.FillForegndTrans or
            self.FillBkgndTrans or
            self.ShdwForegndTrans or
            self.ShdwBkgndTrans or
            self.ShapeShdwType or
            self.ShapeShdwOffsetX or
            self.ShapeShdwOffsetY or
            self.ShapeShdwObliqueAngle or
            self.ShapeShdwScaleFactor or
            super(Fill_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Fill_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Fill_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Fill_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Fill_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Fill_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Fill_Type'):
        super(Fill_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Fill_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Fill_Type', fromsubclass_=False, pretty_print=True):
        super(Fill_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FillForegnd_ in self.FillForegnd:
            namespaceprefix_ = self.FillForegnd_nsprefix_ + ':' if (UseCapturedNS_ and self.FillForegnd_nsprefix_) else ''
            FillForegnd_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FillForegnd', pretty_print=pretty_print)
        for FillBkgnd_ in self.FillBkgnd:
            namespaceprefix_ = self.FillBkgnd_nsprefix_ + ':' if (UseCapturedNS_ and self.FillBkgnd_nsprefix_) else ''
            FillBkgnd_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FillBkgnd', pretty_print=pretty_print)
        for FillPattern_ in self.FillPattern:
            namespaceprefix_ = self.FillPattern_nsprefix_ + ':' if (UseCapturedNS_ and self.FillPattern_nsprefix_) else ''
            FillPattern_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FillPattern', pretty_print=pretty_print)
        for ShdwForegnd_ in self.ShdwForegnd:
            namespaceprefix_ = self.ShdwForegnd_nsprefix_ + ':' if (UseCapturedNS_ and self.ShdwForegnd_nsprefix_) else ''
            ShdwForegnd_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShdwForegnd', pretty_print=pretty_print)
        for ShdwBkgnd_ in self.ShdwBkgnd:
            namespaceprefix_ = self.ShdwBkgnd_nsprefix_ + ':' if (UseCapturedNS_ and self.ShdwBkgnd_nsprefix_) else ''
            ShdwBkgnd_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShdwBkgnd', pretty_print=pretty_print)
        for ShdwPattern_ in self.ShdwPattern:
            namespaceprefix_ = self.ShdwPattern_nsprefix_ + ':' if (UseCapturedNS_ and self.ShdwPattern_nsprefix_) else ''
            ShdwPattern_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShdwPattern', pretty_print=pretty_print)
        for FillForegndTrans_ in self.FillForegndTrans:
            namespaceprefix_ = self.FillForegndTrans_nsprefix_ + ':' if (UseCapturedNS_ and self.FillForegndTrans_nsprefix_) else ''
            FillForegndTrans_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FillForegndTrans', pretty_print=pretty_print)
        for FillBkgndTrans_ in self.FillBkgndTrans:
            namespaceprefix_ = self.FillBkgndTrans_nsprefix_ + ':' if (UseCapturedNS_ and self.FillBkgndTrans_nsprefix_) else ''
            FillBkgndTrans_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FillBkgndTrans', pretty_print=pretty_print)
        for ShdwForegndTrans_ in self.ShdwForegndTrans:
            namespaceprefix_ = self.ShdwForegndTrans_nsprefix_ + ':' if (UseCapturedNS_ and self.ShdwForegndTrans_nsprefix_) else ''
            ShdwForegndTrans_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShdwForegndTrans', pretty_print=pretty_print)
        for ShdwBkgndTrans_ in self.ShdwBkgndTrans:
            namespaceprefix_ = self.ShdwBkgndTrans_nsprefix_ + ':' if (UseCapturedNS_ and self.ShdwBkgndTrans_nsprefix_) else ''
            ShdwBkgndTrans_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShdwBkgndTrans', pretty_print=pretty_print)
        for ShapeShdwType_ in self.ShapeShdwType:
            namespaceprefix_ = self.ShapeShdwType_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapeShdwType_nsprefix_) else ''
            ShapeShdwType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapeShdwType', pretty_print=pretty_print)
        for ShapeShdwOffsetX_ in self.ShapeShdwOffsetX:
            namespaceprefix_ = self.ShapeShdwOffsetX_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapeShdwOffsetX_nsprefix_) else ''
            ShapeShdwOffsetX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapeShdwOffsetX', pretty_print=pretty_print)
        for ShapeShdwOffsetY_ in self.ShapeShdwOffsetY:
            namespaceprefix_ = self.ShapeShdwOffsetY_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapeShdwOffsetY_nsprefix_) else ''
            ShapeShdwOffsetY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapeShdwOffsetY', pretty_print=pretty_print)
        for ShapeShdwObliqueAngle_ in self.ShapeShdwObliqueAngle:
            namespaceprefix_ = self.ShapeShdwObliqueAngle_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapeShdwObliqueAngle_nsprefix_) else ''
            ShapeShdwObliqueAngle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapeShdwObliqueAngle', pretty_print=pretty_print)
        for ShapeShdwScaleFactor_ in self.ShapeShdwScaleFactor:
            namespaceprefix_ = self.ShapeShdwScaleFactor_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapeShdwScaleFactor_nsprefix_) else ''
            ShapeShdwScaleFactor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapeShdwScaleFactor', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Fill_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FillForegnd':
            obj_ = FillForegnd_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FillForegnd.append(obj_)
            obj_.original_tagname_ = 'FillForegnd'
        elif nodeName_ == 'FillBkgnd':
            obj_ = FillBkgnd_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FillBkgnd.append(obj_)
            obj_.original_tagname_ = 'FillBkgnd'
        elif nodeName_ == 'FillPattern':
            obj_ = FillPattern_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FillPattern.append(obj_)
            obj_.original_tagname_ = 'FillPattern'
        elif nodeName_ == 'ShdwForegnd':
            obj_ = ShdwForegnd_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShdwForegnd.append(obj_)
            obj_.original_tagname_ = 'ShdwForegnd'
        elif nodeName_ == 'ShdwBkgnd':
            obj_ = ShdwBkgnd_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShdwBkgnd.append(obj_)
            obj_.original_tagname_ = 'ShdwBkgnd'
        elif nodeName_ == 'ShdwPattern':
            obj_ = ShdwPattern_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShdwPattern.append(obj_)
            obj_.original_tagname_ = 'ShdwPattern'
        elif nodeName_ == 'FillForegndTrans':
            obj_ = FillForegndTrans_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FillForegndTrans.append(obj_)
            obj_.original_tagname_ = 'FillForegndTrans'
        elif nodeName_ == 'FillBkgndTrans':
            obj_ = FillBkgndTrans_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FillBkgndTrans.append(obj_)
            obj_.original_tagname_ = 'FillBkgndTrans'
        elif nodeName_ == 'ShdwForegndTrans':
            obj_ = ShdwForegndTrans_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShdwForegndTrans.append(obj_)
            obj_.original_tagname_ = 'ShdwForegndTrans'
        elif nodeName_ == 'ShdwBkgndTrans':
            obj_ = ShdwBkgndTrans_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShdwBkgndTrans.append(obj_)
            obj_.original_tagname_ = 'ShdwBkgndTrans'
        elif nodeName_ == 'ShapeShdwType':
            obj_ = ShapeShdwType_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapeShdwType.append(obj_)
            obj_.original_tagname_ = 'ShapeShdwType'
        elif nodeName_ == 'ShapeShdwOffsetX':
            obj_ = ShapeShdwOffsetX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapeShdwOffsetX.append(obj_)
            obj_.original_tagname_ = 'ShapeShdwOffsetX'
        elif nodeName_ == 'ShapeShdwOffsetY':
            obj_ = ShapeShdwOffsetY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapeShdwOffsetY.append(obj_)
            obj_.original_tagname_ = 'ShapeShdwOffsetY'
        elif nodeName_ == 'ShapeShdwObliqueAngle':
            obj_ = ShapeShdwObliqueAngle_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapeShdwObliqueAngle.append(obj_)
            obj_.original_tagname_ = 'ShapeShdwObliqueAngle'
        elif nodeName_ == 'ShapeShdwScaleFactor':
            obj_ = ShapeShdwScaleFactor_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapeShdwScaleFactor.append(obj_)
            obj_.original_tagname_ = 'ShapeShdwScaleFactor'
        super(Fill_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Fill_Type


class FillForegnd_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FillForegnd_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FillForegnd_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FillForegnd_Type.subclass:
            return FillForegnd_Type.subclass(*args_, **kwargs_)
        else:
            return FillForegnd_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(FillForegnd_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FillForegnd_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FillForegnd_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FillForegnd_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FillForegnd_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FillForegnd_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FillForegnd_Type'):
        super(FillForegnd_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FillForegnd_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FillForegnd_Type', fromsubclass_=False, pretty_print=True):
        super(FillForegnd_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FillForegnd_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FillForegnd_Type


class FillBkgnd_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FillBkgnd_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FillBkgnd_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FillBkgnd_Type.subclass:
            return FillBkgnd_Type.subclass(*args_, **kwargs_)
        else:
            return FillBkgnd_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(FillBkgnd_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FillBkgnd_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FillBkgnd_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FillBkgnd_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FillBkgnd_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FillBkgnd_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FillBkgnd_Type'):
        super(FillBkgnd_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FillBkgnd_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FillBkgnd_Type', fromsubclass_=False, pretty_print=True):
        super(FillBkgnd_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FillBkgnd_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FillBkgnd_Type


class FillPattern_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FillPattern_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FillPattern_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FillPattern_Type.subclass:
            return FillPattern_Type.subclass(*args_, **kwargs_)
        else:
            return FillPattern_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(FillPattern_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FillPattern_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FillPattern_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FillPattern_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FillPattern_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FillPattern_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FillPattern_Type'):
        super(FillPattern_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FillPattern_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FillPattern_Type', fromsubclass_=False, pretty_print=True):
        super(FillPattern_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FillPattern_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FillPattern_Type


class ShdwForegnd_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShdwForegnd_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShdwForegnd_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShdwForegnd_Type.subclass:
            return ShdwForegnd_Type.subclass(*args_, **kwargs_)
        else:
            return ShdwForegnd_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShdwForegnd_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwForegnd_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShdwForegnd_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShdwForegnd_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwForegnd_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShdwForegnd_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShdwForegnd_Type'):
        super(ShdwForegnd_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwForegnd_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwForegnd_Type', fromsubclass_=False, pretty_print=True):
        super(ShdwForegnd_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShdwForegnd_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShdwForegnd_Type


class ShdwBkgnd_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShdwBkgnd_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShdwBkgnd_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShdwBkgnd_Type.subclass:
            return ShdwBkgnd_Type.subclass(*args_, **kwargs_)
        else:
            return ShdwBkgnd_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShdwBkgnd_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwBkgnd_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShdwBkgnd_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShdwBkgnd_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwBkgnd_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShdwBkgnd_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShdwBkgnd_Type'):
        super(ShdwBkgnd_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwBkgnd_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwBkgnd_Type', fromsubclass_=False, pretty_print=True):
        super(ShdwBkgnd_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShdwBkgnd_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShdwBkgnd_Type


class ShdwPattern_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShdwPattern_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShdwPattern_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShdwPattern_Type.subclass:
            return ShdwPattern_Type.subclass(*args_, **kwargs_)
        else:
            return ShdwPattern_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShdwPattern_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwPattern_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShdwPattern_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShdwPattern_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwPattern_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShdwPattern_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShdwPattern_Type'):
        super(ShdwPattern_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwPattern_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwPattern_Type', fromsubclass_=False, pretty_print=True):
        super(ShdwPattern_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShdwPattern_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShdwPattern_Type


class FillForegndTrans_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FillForegndTrans_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FillForegndTrans_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FillForegndTrans_Type.subclass:
            return FillForegndTrans_Type.subclass(*args_, **kwargs_)
        else:
            return FillForegndTrans_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(FillForegndTrans_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FillForegndTrans_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FillForegndTrans_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FillForegndTrans_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FillForegndTrans_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FillForegndTrans_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FillForegndTrans_Type'):
        super(FillForegndTrans_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FillForegndTrans_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FillForegndTrans_Type', fromsubclass_=False, pretty_print=True):
        super(FillForegndTrans_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FillForegndTrans_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FillForegndTrans_Type


class FillBkgndTrans_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FillBkgndTrans_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FillBkgndTrans_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FillBkgndTrans_Type.subclass:
            return FillBkgndTrans_Type.subclass(*args_, **kwargs_)
        else:
            return FillBkgndTrans_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(FillBkgndTrans_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FillBkgndTrans_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FillBkgndTrans_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FillBkgndTrans_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FillBkgndTrans_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FillBkgndTrans_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FillBkgndTrans_Type'):
        super(FillBkgndTrans_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FillBkgndTrans_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FillBkgndTrans_Type', fromsubclass_=False, pretty_print=True):
        super(FillBkgndTrans_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FillBkgndTrans_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FillBkgndTrans_Type


class ShdwForegndTrans_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShdwForegndTrans_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShdwForegndTrans_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShdwForegndTrans_Type.subclass:
            return ShdwForegndTrans_Type.subclass(*args_, **kwargs_)
        else:
            return ShdwForegndTrans_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShdwForegndTrans_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwForegndTrans_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShdwForegndTrans_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShdwForegndTrans_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwForegndTrans_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShdwForegndTrans_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShdwForegndTrans_Type'):
        super(ShdwForegndTrans_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwForegndTrans_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwForegndTrans_Type', fromsubclass_=False, pretty_print=True):
        super(ShdwForegndTrans_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShdwForegndTrans_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShdwForegndTrans_Type


class ShdwBkgndTrans_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShdwBkgndTrans_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShdwBkgndTrans_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShdwBkgndTrans_Type.subclass:
            return ShdwBkgndTrans_Type.subclass(*args_, **kwargs_)
        else:
            return ShdwBkgndTrans_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShdwBkgndTrans_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwBkgndTrans_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShdwBkgndTrans_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShdwBkgndTrans_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwBkgndTrans_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShdwBkgndTrans_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShdwBkgndTrans_Type'):
        super(ShdwBkgndTrans_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwBkgndTrans_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwBkgndTrans_Type', fromsubclass_=False, pretty_print=True):
        super(ShdwBkgndTrans_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShdwBkgndTrans_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShdwBkgndTrans_Type


class ShapeShdwType_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapeShdwType_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapeShdwType_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapeShdwType_Type.subclass:
            return ShapeShdwType_Type.subclass(*args_, **kwargs_)
        else:
            return ShapeShdwType_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapeShdwType_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeShdwType_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapeShdwType_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapeShdwType_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeShdwType_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapeShdwType_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapeShdwType_Type'):
        super(ShapeShdwType_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeShdwType_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeShdwType_Type', fromsubclass_=False, pretty_print=True):
        super(ShapeShdwType_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapeShdwType_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapeShdwType_Type


class ShapeShdwOffsetX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapeShdwOffsetX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapeShdwOffsetX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapeShdwOffsetX_Type.subclass:
            return ShapeShdwOffsetX_Type.subclass(*args_, **kwargs_)
        else:
            return ShapeShdwOffsetX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapeShdwOffsetX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeShdwOffsetX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapeShdwOffsetX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapeShdwOffsetX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeShdwOffsetX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapeShdwOffsetX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapeShdwOffsetX_Type'):
        super(ShapeShdwOffsetX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeShdwOffsetX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeShdwOffsetX_Type', fromsubclass_=False, pretty_print=True):
        super(ShapeShdwOffsetX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapeShdwOffsetX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapeShdwOffsetX_Type


class ShapeShdwOffsetY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapeShdwOffsetY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapeShdwOffsetY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapeShdwOffsetY_Type.subclass:
            return ShapeShdwOffsetY_Type.subclass(*args_, **kwargs_)
        else:
            return ShapeShdwOffsetY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapeShdwOffsetY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeShdwOffsetY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapeShdwOffsetY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapeShdwOffsetY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeShdwOffsetY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapeShdwOffsetY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapeShdwOffsetY_Type'):
        super(ShapeShdwOffsetY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeShdwOffsetY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeShdwOffsetY_Type', fromsubclass_=False, pretty_print=True):
        super(ShapeShdwOffsetY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapeShdwOffsetY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapeShdwOffsetY_Type


class ShapeShdwObliqueAngle_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapeShdwObliqueAngle_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapeShdwObliqueAngle_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapeShdwObliqueAngle_Type.subclass:
            return ShapeShdwObliqueAngle_Type.subclass(*args_, **kwargs_)
        else:
            return ShapeShdwObliqueAngle_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapeShdwObliqueAngle_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeShdwObliqueAngle_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapeShdwObliqueAngle_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapeShdwObliqueAngle_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeShdwObliqueAngle_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapeShdwObliqueAngle_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapeShdwObliqueAngle_Type'):
        super(ShapeShdwObliqueAngle_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeShdwObliqueAngle_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeShdwObliqueAngle_Type', fromsubclass_=False, pretty_print=True):
        super(ShapeShdwObliqueAngle_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapeShdwObliqueAngle_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapeShdwObliqueAngle_Type


class ShapeShdwScaleFactor_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapeShdwScaleFactor_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapeShdwScaleFactor_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapeShdwScaleFactor_Type.subclass:
            return ShapeShdwScaleFactor_Type.subclass(*args_, **kwargs_)
        else:
            return ShapeShdwScaleFactor_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapeShdwScaleFactor_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeShdwScaleFactor_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapeShdwScaleFactor_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapeShdwScaleFactor_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeShdwScaleFactor_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapeShdwScaleFactor_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapeShdwScaleFactor_Type'):
        super(ShapeShdwScaleFactor_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeShdwScaleFactor_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeShdwScaleFactor_Type', fromsubclass_=False, pretty_print=True):
        super(ShapeShdwScaleFactor_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapeShdwScaleFactor_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapeShdwScaleFactor_Type


class XForm1D_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, BeginX=None, BeginY=None, EndX=None, EndY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(XForm1D_Type, self).__init__(Del,  **kwargs_)
        if BeginX is None:
            self.BeginX = []
        else:
            self.BeginX = BeginX
        self.BeginX_nsprefix_ = None
        if BeginY is None:
            self.BeginY = []
        else:
            self.BeginY = BeginY
        self.BeginY_nsprefix_ = None
        if EndX is None:
            self.EndX = []
        else:
            self.EndX = EndX
        self.EndX_nsprefix_ = None
        if EndY is None:
            self.EndY = []
        else:
            self.EndY = EndY
        self.EndY_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XForm1D_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XForm1D_Type.subclass:
            return XForm1D_Type.subclass(*args_, **kwargs_)
        else:
            return XForm1D_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BeginX(self):
        return self.BeginX
    def set_BeginX(self, BeginX):
        self.BeginX = BeginX
    def add_BeginX(self, value):
        self.BeginX.append(value)
    def insert_BeginX_at(self, index, value):
        self.BeginX.insert(index, value)
    def replace_BeginX_at(self, index, value):
        self.BeginX[index] = value
    def get_BeginY(self):
        return self.BeginY
    def set_BeginY(self, BeginY):
        self.BeginY = BeginY
    def add_BeginY(self, value):
        self.BeginY.append(value)
    def insert_BeginY_at(self, index, value):
        self.BeginY.insert(index, value)
    def replace_BeginY_at(self, index, value):
        self.BeginY[index] = value
    def get_EndX(self):
        return self.EndX
    def set_EndX(self, EndX):
        self.EndX = EndX
    def add_EndX(self, value):
        self.EndX.append(value)
    def insert_EndX_at(self, index, value):
        self.EndX.insert(index, value)
    def replace_EndX_at(self, index, value):
        self.EndX[index] = value
    def get_EndY(self):
        return self.EndY
    def set_EndY(self, EndY):
        self.EndY = EndY
    def add_EndY(self, value):
        self.EndY.append(value)
    def insert_EndY_at(self, index, value):
        self.EndY.insert(index, value)
    def replace_EndY_at(self, index, value):
        self.EndY[index] = value
    def hasContent_(self):
        if (
            self.BeginX or
            self.BeginY or
            self.EndX or
            self.EndY or
            super(XForm1D_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='XForm1D_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XForm1D_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'XForm1D_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XForm1D_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XForm1D_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XForm1D_Type'):
        super(XForm1D_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XForm1D_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='XForm1D_Type', fromsubclass_=False, pretty_print=True):
        super(XForm1D_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BeginX_ in self.BeginX:
            namespaceprefix_ = self.BeginX_nsprefix_ + ':' if (UseCapturedNS_ and self.BeginX_nsprefix_) else ''
            BeginX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BeginX', pretty_print=pretty_print)
        for BeginY_ in self.BeginY:
            namespaceprefix_ = self.BeginY_nsprefix_ + ':' if (UseCapturedNS_ and self.BeginY_nsprefix_) else ''
            BeginY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BeginY', pretty_print=pretty_print)
        for EndX_ in self.EndX:
            namespaceprefix_ = self.EndX_nsprefix_ + ':' if (UseCapturedNS_ and self.EndX_nsprefix_) else ''
            EndX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EndX', pretty_print=pretty_print)
        for EndY_ in self.EndY:
            namespaceprefix_ = self.EndY_nsprefix_ + ':' if (UseCapturedNS_ and self.EndY_nsprefix_) else ''
            EndY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EndY', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(XForm1D_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BeginX':
            obj_ = BeginX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BeginX.append(obj_)
            obj_.original_tagname_ = 'BeginX'
        elif nodeName_ == 'BeginY':
            obj_ = BeginY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BeginY.append(obj_)
            obj_.original_tagname_ = 'BeginY'
        elif nodeName_ == 'EndX':
            obj_ = EndX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EndX.append(obj_)
            obj_.original_tagname_ = 'EndX'
        elif nodeName_ == 'EndY':
            obj_ = EndY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EndY.append(obj_)
            obj_.original_tagname_ = 'EndY'
        super(XForm1D_Type, self).buildChildren(child_, node, nodeName_, True)
# end class XForm1D_Type


class BeginX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BeginX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BeginX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BeginX_Type.subclass:
            return BeginX_Type.subclass(*args_, **kwargs_)
        else:
            return BeginX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(BeginX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BeginX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BeginX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BeginX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BeginX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BeginX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BeginX_Type'):
        super(BeginX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BeginX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BeginX_Type', fromsubclass_=False, pretty_print=True):
        super(BeginX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BeginX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BeginX_Type


class BeginY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BeginY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BeginY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BeginY_Type.subclass:
            return BeginY_Type.subclass(*args_, **kwargs_)
        else:
            return BeginY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(BeginY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BeginY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BeginY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BeginY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BeginY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BeginY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BeginY_Type'):
        super(BeginY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BeginY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BeginY_Type', fromsubclass_=False, pretty_print=True):
        super(BeginY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BeginY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BeginY_Type


class EndX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EndX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndX_Type.subclass:
            return EndX_Type.subclass(*args_, **kwargs_)
        else:
            return EndX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EndX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EndX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EndX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EndX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EndX_Type'):
        super(EndX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndX_Type', fromsubclass_=False, pretty_print=True):
        super(EndX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EndX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EndX_Type


class EndY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EndY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndY_Type.subclass:
            return EndY_Type.subclass(*args_, **kwargs_)
        else:
            return EndY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EndY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EndY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EndY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EndY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EndY_Type'):
        super(EndY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndY_Type', fromsubclass_=False, pretty_print=True):
        super(EndY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EndY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EndY_Type


class Event_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, TheData=None, TheText=None, EventDblClick=None, EventXFMod=None, EventDrop=None, EventMultiDrop=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Event_Type, self).__init__(Del,  **kwargs_)
        if TheData is None:
            self.TheData = []
        else:
            self.TheData = TheData
        self.TheData_nsprefix_ = None
        if TheText is None:
            self.TheText = []
        else:
            self.TheText = TheText
        self.TheText_nsprefix_ = None
        if EventDblClick is None:
            self.EventDblClick = []
        else:
            self.EventDblClick = EventDblClick
        self.EventDblClick_nsprefix_ = None
        if EventXFMod is None:
            self.EventXFMod = []
        else:
            self.EventXFMod = EventXFMod
        self.EventXFMod_nsprefix_ = None
        if EventDrop is None:
            self.EventDrop = []
        else:
            self.EventDrop = EventDrop
        self.EventDrop_nsprefix_ = None
        if EventMultiDrop is None:
            self.EventMultiDrop = []
        else:
            self.EventMultiDrop = EventMultiDrop
        self.EventMultiDrop_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Event_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Event_Type.subclass:
            return Event_Type.subclass(*args_, **kwargs_)
        else:
            return Event_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TheData(self):
        return self.TheData
    def set_TheData(self, TheData):
        self.TheData = TheData
    def add_TheData(self, value):
        self.TheData.append(value)
    def insert_TheData_at(self, index, value):
        self.TheData.insert(index, value)
    def replace_TheData_at(self, index, value):
        self.TheData[index] = value
    def get_TheText(self):
        return self.TheText
    def set_TheText(self, TheText):
        self.TheText = TheText
    def add_TheText(self, value):
        self.TheText.append(value)
    def insert_TheText_at(self, index, value):
        self.TheText.insert(index, value)
    def replace_TheText_at(self, index, value):
        self.TheText[index] = value
    def get_EventDblClick(self):
        return self.EventDblClick
    def set_EventDblClick(self, EventDblClick):
        self.EventDblClick = EventDblClick
    def add_EventDblClick(self, value):
        self.EventDblClick.append(value)
    def insert_EventDblClick_at(self, index, value):
        self.EventDblClick.insert(index, value)
    def replace_EventDblClick_at(self, index, value):
        self.EventDblClick[index] = value
    def get_EventXFMod(self):
        return self.EventXFMod
    def set_EventXFMod(self, EventXFMod):
        self.EventXFMod = EventXFMod
    def add_EventXFMod(self, value):
        self.EventXFMod.append(value)
    def insert_EventXFMod_at(self, index, value):
        self.EventXFMod.insert(index, value)
    def replace_EventXFMod_at(self, index, value):
        self.EventXFMod[index] = value
    def get_EventDrop(self):
        return self.EventDrop
    def set_EventDrop(self, EventDrop):
        self.EventDrop = EventDrop
    def add_EventDrop(self, value):
        self.EventDrop.append(value)
    def insert_EventDrop_at(self, index, value):
        self.EventDrop.insert(index, value)
    def replace_EventDrop_at(self, index, value):
        self.EventDrop[index] = value
    def get_EventMultiDrop(self):
        return self.EventMultiDrop
    def set_EventMultiDrop(self, EventMultiDrop):
        self.EventMultiDrop = EventMultiDrop
    def add_EventMultiDrop(self, value):
        self.EventMultiDrop.append(value)
    def insert_EventMultiDrop_at(self, index, value):
        self.EventMultiDrop.insert(index, value)
    def replace_EventMultiDrop_at(self, index, value):
        self.EventMultiDrop[index] = value
    def hasContent_(self):
        if (
            self.TheData or
            self.TheText or
            self.EventDblClick or
            self.EventXFMod or
            self.EventDrop or
            self.EventMultiDrop or
            super(Event_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Event_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Event_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Event_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Event_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Event_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Event_Type'):
        super(Event_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Event_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Event_Type', fromsubclass_=False, pretty_print=True):
        super(Event_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TheData_ in self.TheData:
            namespaceprefix_ = self.TheData_nsprefix_ + ':' if (UseCapturedNS_ and self.TheData_nsprefix_) else ''
            TheData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TheData', pretty_print=pretty_print)
        for TheText_ in self.TheText:
            namespaceprefix_ = self.TheText_nsprefix_ + ':' if (UseCapturedNS_ and self.TheText_nsprefix_) else ''
            TheText_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TheText', pretty_print=pretty_print)
        for EventDblClick_ in self.EventDblClick:
            namespaceprefix_ = self.EventDblClick_nsprefix_ + ':' if (UseCapturedNS_ and self.EventDblClick_nsprefix_) else ''
            EventDblClick_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EventDblClick', pretty_print=pretty_print)
        for EventXFMod_ in self.EventXFMod:
            namespaceprefix_ = self.EventXFMod_nsprefix_ + ':' if (UseCapturedNS_ and self.EventXFMod_nsprefix_) else ''
            EventXFMod_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EventXFMod', pretty_print=pretty_print)
        for EventDrop_ in self.EventDrop:
            namespaceprefix_ = self.EventDrop_nsprefix_ + ':' if (UseCapturedNS_ and self.EventDrop_nsprefix_) else ''
            EventDrop_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EventDrop', pretty_print=pretty_print)
        for EventMultiDrop_ in self.EventMultiDrop:
            namespaceprefix_ = self.EventMultiDrop_nsprefix_ + ':' if (UseCapturedNS_ and self.EventMultiDrop_nsprefix_) else ''
            EventMultiDrop_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EventMultiDrop', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Event_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TheData':
            obj_ = TheData_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TheData.append(obj_)
            obj_.original_tagname_ = 'TheData'
        elif nodeName_ == 'TheText':
            obj_ = TheText_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TheText.append(obj_)
            obj_.original_tagname_ = 'TheText'
        elif nodeName_ == 'EventDblClick':
            obj_ = EventDblClick_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EventDblClick.append(obj_)
            obj_.original_tagname_ = 'EventDblClick'
        elif nodeName_ == 'EventXFMod':
            obj_ = EventXFMod_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EventXFMod.append(obj_)
            obj_.original_tagname_ = 'EventXFMod'
        elif nodeName_ == 'EventDrop':
            obj_ = EventDrop_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EventDrop.append(obj_)
            obj_.original_tagname_ = 'EventDrop'
        elif nodeName_ == 'EventMultiDrop':
            obj_ = EventMultiDrop_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EventMultiDrop.append(obj_)
            obj_.original_tagname_ = 'EventMultiDrop'
        super(Event_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Event_Type


class TheData_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TheData_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TheData_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TheData_Type.subclass:
            return TheData_Type.subclass(*args_, **kwargs_)
        else:
            return TheData_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TheData_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TheData_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TheData_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TheData_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TheData_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TheData_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TheData_Type'):
        super(TheData_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TheData_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TheData_Type', fromsubclass_=False, pretty_print=True):
        super(TheData_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TheData_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TheData_Type


class TheText_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TheText_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TheText_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TheText_Type.subclass:
            return TheText_Type.subclass(*args_, **kwargs_)
        else:
            return TheText_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TheText_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TheText_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TheText_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TheText_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TheText_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TheText_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TheText_Type'):
        super(TheText_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TheText_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TheText_Type', fromsubclass_=False, pretty_print=True):
        super(TheText_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TheText_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TheText_Type


class EventDblClick_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EventDblClick_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventDblClick_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventDblClick_Type.subclass:
            return EventDblClick_Type.subclass(*args_, **kwargs_)
        else:
            return EventDblClick_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EventDblClick_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EventDblClick_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EventDblClick_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EventDblClick_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EventDblClick_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EventDblClick_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EventDblClick_Type'):
        super(EventDblClick_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EventDblClick_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EventDblClick_Type', fromsubclass_=False, pretty_print=True):
        super(EventDblClick_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EventDblClick_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EventDblClick_Type


class EventXFMod_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EventXFMod_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventXFMod_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventXFMod_Type.subclass:
            return EventXFMod_Type.subclass(*args_, **kwargs_)
        else:
            return EventXFMod_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EventXFMod_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EventXFMod_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EventXFMod_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EventXFMod_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EventXFMod_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EventXFMod_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EventXFMod_Type'):
        super(EventXFMod_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EventXFMod_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EventXFMod_Type', fromsubclass_=False, pretty_print=True):
        super(EventXFMod_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EventXFMod_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EventXFMod_Type


class EventDrop_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EventDrop_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventDrop_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventDrop_Type.subclass:
            return EventDrop_Type.subclass(*args_, **kwargs_)
        else:
            return EventDrop_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EventDrop_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EventDrop_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EventDrop_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EventDrop_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EventDrop_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EventDrop_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EventDrop_Type'):
        super(EventDrop_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EventDrop_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EventDrop_Type', fromsubclass_=False, pretty_print=True):
        super(EventDrop_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EventDrop_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EventDrop_Type


class EventMultiDrop_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EventMultiDrop_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventMultiDrop_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventMultiDrop_Type.subclass:
            return EventMultiDrop_Type.subclass(*args_, **kwargs_)
        else:
            return EventMultiDrop_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EventMultiDrop_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EventMultiDrop_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EventMultiDrop_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EventMultiDrop_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EventMultiDrop_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EventMultiDrop_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EventMultiDrop_Type'):
        super(EventMultiDrop_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EventMultiDrop_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EventMultiDrop_Type', fromsubclass_=False, pretty_print=True):
        super(EventMultiDrop_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EventMultiDrop_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EventMultiDrop_Type


class D_Type(ExtendableCell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ExtendableCell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, SolutionXML=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(D_Type, self).__init__(Unit, F, Err, V, SolutionXML, valueOf_, mixedclass_, content_,  **kwargs_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, D_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if D_Type.subclass:
            return D_Type.subclass(*args_, **kwargs_)
        else:
            return D_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(D_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='D_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('D_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'D_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='D_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='D_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='D_Type'):
        super(D_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='D_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='D_Type', fromsubclass_=False, pretty_print=True):
        super(D_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(D_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(D_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class D_Type


class E_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(E_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, E_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if E_Type.subclass:
            return E_Type.subclass(*args_, **kwargs_)
        else:
            return E_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(E_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='E_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('E_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'E_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='E_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='E_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='E_Type'):
        super(E_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='E_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='E_Type', fromsubclass_=False, pretty_print=True):
        super(E_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(E_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class E_Type


class LayerMem_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, LayerMember=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LayerMem_Type, self).__init__(Del,  **kwargs_)
        if LayerMember is None:
            self.LayerMember = []
        else:
            self.LayerMember = LayerMember
        self.LayerMember_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LayerMem_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LayerMem_Type.subclass:
            return LayerMem_Type.subclass(*args_, **kwargs_)
        else:
            return LayerMem_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LayerMember(self):
        return self.LayerMember
    def set_LayerMember(self, LayerMember):
        self.LayerMember = LayerMember
    def add_LayerMember(self, value):
        self.LayerMember.append(value)
    def insert_LayerMember_at(self, index, value):
        self.LayerMember.insert(index, value)
    def replace_LayerMember_at(self, index, value):
        self.LayerMember[index] = value
    def hasContent_(self):
        if (
            self.LayerMember or
            super(LayerMem_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='LayerMem_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LayerMem_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LayerMem_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LayerMem_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LayerMem_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LayerMem_Type'):
        super(LayerMem_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LayerMem_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='LayerMem_Type', fromsubclass_=False, pretty_print=True):
        super(LayerMem_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LayerMember_ in self.LayerMember:
            namespaceprefix_ = self.LayerMember_nsprefix_ + ':' if (UseCapturedNS_ and self.LayerMember_nsprefix_) else ''
            LayerMember_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LayerMember', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LayerMem_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LayerMember':
            obj_ = LayerMember_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LayerMember.append(obj_)
            obj_.original_tagname_ = 'LayerMember'
        super(LayerMem_Type, self).buildChildren(child_, node, nodeName_, True)
# end class LayerMem_Type


class LayerMember_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LayerMember_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LayerMember_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LayerMember_Type.subclass:
            return LayerMember_Type.subclass(*args_, **kwargs_)
        else:
            return LayerMember_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LayerMember_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LayerMember_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LayerMember_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LayerMember_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LayerMember_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LayerMember_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LayerMember_Type'):
        super(LayerMember_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LayerMember_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LayerMember_Type', fromsubclass_=False, pretty_print=True):
        super(LayerMember_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LayerMember_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LayerMember_Type


class Guide_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Guide_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Guide_Type.subclass:
            return Guide_Type.subclass(*args_, **kwargs_)
        else:
            return Guide_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Guide_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Guide_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Guide_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Guide_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Guide_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Guide_Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Guide_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Guide_Type


class X_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(X_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X_Type.subclass:
            return X_Type.subclass(*args_, **kwargs_)
        else:
            return X_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(X_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='X_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('X_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'X_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='X_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='X_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='X_Type'):
        super(X_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='X_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='X_Type', fromsubclass_=False, pretty_print=True):
        super(X_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(X_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class X_Type


class Y_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Y_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Y_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Y_Type.subclass:
            return Y_Type.subclass(*args_, **kwargs_)
        else:
            return Y_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Y_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Y_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Y_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Y_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Y_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Y_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Y_Type'):
        super(Y_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Y_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Y_Type', fromsubclass_=False, pretty_print=True):
        super(Y_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Y_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Y_Type


class A_Type(ExtendableCell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ExtendableCell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, SolutionXML=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(A_Type, self).__init__(Unit, F, Err, V, SolutionXML, valueOf_, mixedclass_, content_,  **kwargs_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, A_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if A_Type.subclass:
            return A_Type.subclass(*args_, **kwargs_)
        else:
            return A_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(A_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='A_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('A_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'A_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='A_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='A_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='A_Type'):
        super(A_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='A_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='A_Type', fromsubclass_=False, pretty_print=True):
        super(A_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(A_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(A_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class A_Type


class StyleProp_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, EnableLineProps=None, EnableFillProps=None, EnableTextProps=None, HideForApply=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(StyleProp_Type, self).__init__(Del,  **kwargs_)
        if EnableLineProps is None:
            self.EnableLineProps = []
        else:
            self.EnableLineProps = EnableLineProps
        self.EnableLineProps_nsprefix_ = None
        if EnableFillProps is None:
            self.EnableFillProps = []
        else:
            self.EnableFillProps = EnableFillProps
        self.EnableFillProps_nsprefix_ = None
        if EnableTextProps is None:
            self.EnableTextProps = []
        else:
            self.EnableTextProps = EnableTextProps
        self.EnableTextProps_nsprefix_ = None
        if HideForApply is None:
            self.HideForApply = []
        else:
            self.HideForApply = HideForApply
        self.HideForApply_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StyleProp_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StyleProp_Type.subclass:
            return StyleProp_Type.subclass(*args_, **kwargs_)
        else:
            return StyleProp_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EnableLineProps(self):
        return self.EnableLineProps
    def set_EnableLineProps(self, EnableLineProps):
        self.EnableLineProps = EnableLineProps
    def add_EnableLineProps(self, value):
        self.EnableLineProps.append(value)
    def insert_EnableLineProps_at(self, index, value):
        self.EnableLineProps.insert(index, value)
    def replace_EnableLineProps_at(self, index, value):
        self.EnableLineProps[index] = value
    def get_EnableFillProps(self):
        return self.EnableFillProps
    def set_EnableFillProps(self, EnableFillProps):
        self.EnableFillProps = EnableFillProps
    def add_EnableFillProps(self, value):
        self.EnableFillProps.append(value)
    def insert_EnableFillProps_at(self, index, value):
        self.EnableFillProps.insert(index, value)
    def replace_EnableFillProps_at(self, index, value):
        self.EnableFillProps[index] = value
    def get_EnableTextProps(self):
        return self.EnableTextProps
    def set_EnableTextProps(self, EnableTextProps):
        self.EnableTextProps = EnableTextProps
    def add_EnableTextProps(self, value):
        self.EnableTextProps.append(value)
    def insert_EnableTextProps_at(self, index, value):
        self.EnableTextProps.insert(index, value)
    def replace_EnableTextProps_at(self, index, value):
        self.EnableTextProps[index] = value
    def get_HideForApply(self):
        return self.HideForApply
    def set_HideForApply(self, HideForApply):
        self.HideForApply = HideForApply
    def add_HideForApply(self, value):
        self.HideForApply.append(value)
    def insert_HideForApply_at(self, index, value):
        self.HideForApply.insert(index, value)
    def replace_HideForApply_at(self, index, value):
        self.HideForApply[index] = value
    def hasContent_(self):
        if (
            self.EnableLineProps or
            self.EnableFillProps or
            self.EnableTextProps or
            self.HideForApply or
            super(StyleProp_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='StyleProp_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StyleProp_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StyleProp_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StyleProp_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StyleProp_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StyleProp_Type'):
        super(StyleProp_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StyleProp_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='StyleProp_Type', fromsubclass_=False, pretty_print=True):
        super(StyleProp_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EnableLineProps_ in self.EnableLineProps:
            namespaceprefix_ = self.EnableLineProps_nsprefix_ + ':' if (UseCapturedNS_ and self.EnableLineProps_nsprefix_) else ''
            EnableLineProps_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EnableLineProps', pretty_print=pretty_print)
        for EnableFillProps_ in self.EnableFillProps:
            namespaceprefix_ = self.EnableFillProps_nsprefix_ + ':' if (UseCapturedNS_ and self.EnableFillProps_nsprefix_) else ''
            EnableFillProps_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EnableFillProps', pretty_print=pretty_print)
        for EnableTextProps_ in self.EnableTextProps:
            namespaceprefix_ = self.EnableTextProps_nsprefix_ + ':' if (UseCapturedNS_ and self.EnableTextProps_nsprefix_) else ''
            EnableTextProps_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EnableTextProps', pretty_print=pretty_print)
        for HideForApply_ in self.HideForApply:
            namespaceprefix_ = self.HideForApply_nsprefix_ + ':' if (UseCapturedNS_ and self.HideForApply_nsprefix_) else ''
            HideForApply_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HideForApply', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StyleProp_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EnableLineProps':
            obj_ = EnableLineProps_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnableLineProps.append(obj_)
            obj_.original_tagname_ = 'EnableLineProps'
        elif nodeName_ == 'EnableFillProps':
            obj_ = EnableFillProps_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnableFillProps.append(obj_)
            obj_.original_tagname_ = 'EnableFillProps'
        elif nodeName_ == 'EnableTextProps':
            obj_ = EnableTextProps_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnableTextProps.append(obj_)
            obj_.original_tagname_ = 'EnableTextProps'
        elif nodeName_ == 'HideForApply':
            obj_ = HideForApply_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HideForApply.append(obj_)
            obj_.original_tagname_ = 'HideForApply'
        super(StyleProp_Type, self).buildChildren(child_, node, nodeName_, True)
# end class StyleProp_Type


class EnableLineProps_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EnableLineProps_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnableLineProps_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnableLineProps_Type.subclass:
            return EnableLineProps_Type.subclass(*args_, **kwargs_)
        else:
            return EnableLineProps_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EnableLineProps_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnableLineProps_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnableLineProps_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EnableLineProps_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnableLineProps_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EnableLineProps_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EnableLineProps_Type'):
        super(EnableLineProps_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnableLineProps_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnableLineProps_Type', fromsubclass_=False, pretty_print=True):
        super(EnableLineProps_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EnableLineProps_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EnableLineProps_Type


class EnableFillProps_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EnableFillProps_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnableFillProps_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnableFillProps_Type.subclass:
            return EnableFillProps_Type.subclass(*args_, **kwargs_)
        else:
            return EnableFillProps_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EnableFillProps_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnableFillProps_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnableFillProps_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EnableFillProps_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnableFillProps_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EnableFillProps_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EnableFillProps_Type'):
        super(EnableFillProps_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnableFillProps_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnableFillProps_Type', fromsubclass_=False, pretty_print=True):
        super(EnableFillProps_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EnableFillProps_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EnableFillProps_Type


class EnableTextProps_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EnableTextProps_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnableTextProps_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnableTextProps_Type.subclass:
            return EnableTextProps_Type.subclass(*args_, **kwargs_)
        else:
            return EnableTextProps_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EnableTextProps_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnableTextProps_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnableTextProps_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EnableTextProps_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnableTextProps_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EnableTextProps_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EnableTextProps_Type'):
        super(EnableTextProps_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnableTextProps_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnableTextProps_Type', fromsubclass_=False, pretty_print=True):
        super(EnableTextProps_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EnableTextProps_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EnableTextProps_Type


class HideForApply_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(HideForApply_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HideForApply_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HideForApply_Type.subclass:
            return HideForApply_Type.subclass(*args_, **kwargs_)
        else:
            return HideForApply_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(HideForApply_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HideForApply_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HideForApply_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HideForApply_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HideForApply_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HideForApply_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HideForApply_Type'):
        super(HideForApply_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HideForApply_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HideForApply_Type', fromsubclass_=False, pretty_print=True):
        super(HideForApply_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HideForApply_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class HideForApply_Type


class C_Type(ExtendableCell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ExtendableCell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, SolutionXML=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(C_Type, self).__init__(Unit, F, Err, V, SolutionXML, valueOf_, mixedclass_, content_,  **kwargs_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, C_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if C_Type.subclass:
            return C_Type.subclass(*args_, **kwargs_)
        else:
            return C_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(C_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='C_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('C_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'C_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='C_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='C_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='C_Type'):
        super(C_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='C_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='C_Type', fromsubclass_=False, pretty_print=True):
        super(C_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(C_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(C_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class C_Type


class Foreign_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, ImgOffsetX=None, ImgOffsetY=None, ImgWidth=None, ImgHeight=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Foreign_Type, self).__init__(Del,  **kwargs_)
        if ImgOffsetX is None:
            self.ImgOffsetX = []
        else:
            self.ImgOffsetX = ImgOffsetX
        self.ImgOffsetX_nsprefix_ = None
        if ImgOffsetY is None:
            self.ImgOffsetY = []
        else:
            self.ImgOffsetY = ImgOffsetY
        self.ImgOffsetY_nsprefix_ = None
        if ImgWidth is None:
            self.ImgWidth = []
        else:
            self.ImgWidth = ImgWidth
        self.ImgWidth_nsprefix_ = None
        if ImgHeight is None:
            self.ImgHeight = []
        else:
            self.ImgHeight = ImgHeight
        self.ImgHeight_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Foreign_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Foreign_Type.subclass:
            return Foreign_Type.subclass(*args_, **kwargs_)
        else:
            return Foreign_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ImgOffsetX(self):
        return self.ImgOffsetX
    def set_ImgOffsetX(self, ImgOffsetX):
        self.ImgOffsetX = ImgOffsetX
    def add_ImgOffsetX(self, value):
        self.ImgOffsetX.append(value)
    def insert_ImgOffsetX_at(self, index, value):
        self.ImgOffsetX.insert(index, value)
    def replace_ImgOffsetX_at(self, index, value):
        self.ImgOffsetX[index] = value
    def get_ImgOffsetY(self):
        return self.ImgOffsetY
    def set_ImgOffsetY(self, ImgOffsetY):
        self.ImgOffsetY = ImgOffsetY
    def add_ImgOffsetY(self, value):
        self.ImgOffsetY.append(value)
    def insert_ImgOffsetY_at(self, index, value):
        self.ImgOffsetY.insert(index, value)
    def replace_ImgOffsetY_at(self, index, value):
        self.ImgOffsetY[index] = value
    def get_ImgWidth(self):
        return self.ImgWidth
    def set_ImgWidth(self, ImgWidth):
        self.ImgWidth = ImgWidth
    def add_ImgWidth(self, value):
        self.ImgWidth.append(value)
    def insert_ImgWidth_at(self, index, value):
        self.ImgWidth.insert(index, value)
    def replace_ImgWidth_at(self, index, value):
        self.ImgWidth[index] = value
    def get_ImgHeight(self):
        return self.ImgHeight
    def set_ImgHeight(self, ImgHeight):
        self.ImgHeight = ImgHeight
    def add_ImgHeight(self, value):
        self.ImgHeight.append(value)
    def insert_ImgHeight_at(self, index, value):
        self.ImgHeight.insert(index, value)
    def replace_ImgHeight_at(self, index, value):
        self.ImgHeight[index] = value
    def hasContent_(self):
        if (
            self.ImgOffsetX or
            self.ImgOffsetY or
            self.ImgWidth or
            self.ImgHeight or
            super(Foreign_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Foreign_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Foreign_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Foreign_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Foreign_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Foreign_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Foreign_Type'):
        super(Foreign_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Foreign_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Foreign_Type', fromsubclass_=False, pretty_print=True):
        super(Foreign_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ImgOffsetX_ in self.ImgOffsetX:
            namespaceprefix_ = self.ImgOffsetX_nsprefix_ + ':' if (UseCapturedNS_ and self.ImgOffsetX_nsprefix_) else ''
            ImgOffsetX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ImgOffsetX', pretty_print=pretty_print)
        for ImgOffsetY_ in self.ImgOffsetY:
            namespaceprefix_ = self.ImgOffsetY_nsprefix_ + ':' if (UseCapturedNS_ and self.ImgOffsetY_nsprefix_) else ''
            ImgOffsetY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ImgOffsetY', pretty_print=pretty_print)
        for ImgWidth_ in self.ImgWidth:
            namespaceprefix_ = self.ImgWidth_nsprefix_ + ':' if (UseCapturedNS_ and self.ImgWidth_nsprefix_) else ''
            ImgWidth_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ImgWidth', pretty_print=pretty_print)
        for ImgHeight_ in self.ImgHeight:
            namespaceprefix_ = self.ImgHeight_nsprefix_ + ':' if (UseCapturedNS_ and self.ImgHeight_nsprefix_) else ''
            ImgHeight_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ImgHeight', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Foreign_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ImgOffsetX':
            obj_ = ImgOffsetX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ImgOffsetX.append(obj_)
            obj_.original_tagname_ = 'ImgOffsetX'
        elif nodeName_ == 'ImgOffsetY':
            obj_ = ImgOffsetY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ImgOffsetY.append(obj_)
            obj_.original_tagname_ = 'ImgOffsetY'
        elif nodeName_ == 'ImgWidth':
            obj_ = ImgWidth_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ImgWidth.append(obj_)
            obj_.original_tagname_ = 'ImgWidth'
        elif nodeName_ == 'ImgHeight':
            obj_ = ImgHeight_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ImgHeight.append(obj_)
            obj_.original_tagname_ = 'ImgHeight'
        super(Foreign_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Foreign_Type


class ImgOffsetX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ImgOffsetX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImgOffsetX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImgOffsetX_Type.subclass:
            return ImgOffsetX_Type.subclass(*args_, **kwargs_)
        else:
            return ImgOffsetX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ImgOffsetX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImgOffsetX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ImgOffsetX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ImgOffsetX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImgOffsetX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ImgOffsetX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ImgOffsetX_Type'):
        super(ImgOffsetX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImgOffsetX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImgOffsetX_Type', fromsubclass_=False, pretty_print=True):
        super(ImgOffsetX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ImgOffsetX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ImgOffsetX_Type


class ImgOffsetY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ImgOffsetY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImgOffsetY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImgOffsetY_Type.subclass:
            return ImgOffsetY_Type.subclass(*args_, **kwargs_)
        else:
            return ImgOffsetY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ImgOffsetY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImgOffsetY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ImgOffsetY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ImgOffsetY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImgOffsetY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ImgOffsetY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ImgOffsetY_Type'):
        super(ImgOffsetY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImgOffsetY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImgOffsetY_Type', fromsubclass_=False, pretty_print=True):
        super(ImgOffsetY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ImgOffsetY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ImgOffsetY_Type


class ImgWidth_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ImgWidth_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImgWidth_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImgWidth_Type.subclass:
            return ImgWidth_Type.subclass(*args_, **kwargs_)
        else:
            return ImgWidth_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ImgWidth_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImgWidth_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ImgWidth_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ImgWidth_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImgWidth_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ImgWidth_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ImgWidth_Type'):
        super(ImgWidth_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImgWidth_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImgWidth_Type', fromsubclass_=False, pretty_print=True):
        super(ImgWidth_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ImgWidth_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ImgWidth_Type


class ImgHeight_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ImgHeight_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImgHeight_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImgHeight_Type.subclass:
            return ImgHeight_Type.subclass(*args_, **kwargs_)
        else:
            return ImgHeight_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ImgHeight_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImgHeight_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ImgHeight_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ImgHeight_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImgHeight_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ImgHeight_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ImgHeight_Type'):
        super(ImgHeight_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImgHeight_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImgHeight_Type', fromsubclass_=False, pretty_print=True):
        super(ImgHeight_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ImgHeight_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ImgHeight_Type


class PageProps_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, PageWidth=None, PageHeight=None, ShdwOffsetX=None, ShdwOffsetY=None, PageScale=None, DrawingScale=None, DrawingSizeType=None, DrawingScaleType=None, InhibitSnap=None, UIVisibility=None, ShdwType=None, ShdwObliqueAngle=None, ShdwScaleFactor=None, PageColor=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PageProps_Type, self).__init__(Del,  **kwargs_)
        if PageWidth is None:
            self.PageWidth = []
        else:
            self.PageWidth = PageWidth
        self.PageWidth_nsprefix_ = None
        if PageHeight is None:
            self.PageHeight = []
        else:
            self.PageHeight = PageHeight
        self.PageHeight_nsprefix_ = None
        if ShdwOffsetX is None:
            self.ShdwOffsetX = []
        else:
            self.ShdwOffsetX = ShdwOffsetX
        self.ShdwOffsetX_nsprefix_ = None
        if ShdwOffsetY is None:
            self.ShdwOffsetY = []
        else:
            self.ShdwOffsetY = ShdwOffsetY
        self.ShdwOffsetY_nsprefix_ = None
        if PageScale is None:
            self.PageScale = []
        else:
            self.PageScale = PageScale
        self.PageScale_nsprefix_ = None
        if DrawingScale is None:
            self.DrawingScale = []
        else:
            self.DrawingScale = DrawingScale
        self.DrawingScale_nsprefix_ = None
        if DrawingSizeType is None:
            self.DrawingSizeType = []
        else:
            self.DrawingSizeType = DrawingSizeType
        self.DrawingSizeType_nsprefix_ = None
        if DrawingScaleType is None:
            self.DrawingScaleType = []
        else:
            self.DrawingScaleType = DrawingScaleType
        self.DrawingScaleType_nsprefix_ = None
        if InhibitSnap is None:
            self.InhibitSnap = []
        else:
            self.InhibitSnap = InhibitSnap
        self.InhibitSnap_nsprefix_ = None
        if UIVisibility is None:
            self.UIVisibility = []
        else:
            self.UIVisibility = UIVisibility
        self.UIVisibility_nsprefix_ = None
        if ShdwType is None:
            self.ShdwType = []
        else:
            self.ShdwType = ShdwType
        self.ShdwType_nsprefix_ = None
        if ShdwObliqueAngle is None:
            self.ShdwObliqueAngle = []
        else:
            self.ShdwObliqueAngle = ShdwObliqueAngle
        self.ShdwObliqueAngle_nsprefix_ = None
        if ShdwScaleFactor is None:
            self.ShdwScaleFactor = []
        else:
            self.ShdwScaleFactor = ShdwScaleFactor
        self.ShdwScaleFactor_nsprefix_ = None
        if PageColor is None:
            self.PageColor = []
        else:
            self.PageColor = PageColor
        self.PageColor_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PageProps_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PageProps_Type.subclass:
            return PageProps_Type.subclass(*args_, **kwargs_)
        else:
            return PageProps_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PageWidth(self):
        return self.PageWidth
    def set_PageWidth(self, PageWidth):
        self.PageWidth = PageWidth
    def add_PageWidth(self, value):
        self.PageWidth.append(value)
    def insert_PageWidth_at(self, index, value):
        self.PageWidth.insert(index, value)
    def replace_PageWidth_at(self, index, value):
        self.PageWidth[index] = value
    def get_PageHeight(self):
        return self.PageHeight
    def set_PageHeight(self, PageHeight):
        self.PageHeight = PageHeight
    def add_PageHeight(self, value):
        self.PageHeight.append(value)
    def insert_PageHeight_at(self, index, value):
        self.PageHeight.insert(index, value)
    def replace_PageHeight_at(self, index, value):
        self.PageHeight[index] = value
    def get_ShdwOffsetX(self):
        return self.ShdwOffsetX
    def set_ShdwOffsetX(self, ShdwOffsetX):
        self.ShdwOffsetX = ShdwOffsetX
    def add_ShdwOffsetX(self, value):
        self.ShdwOffsetX.append(value)
    def insert_ShdwOffsetX_at(self, index, value):
        self.ShdwOffsetX.insert(index, value)
    def replace_ShdwOffsetX_at(self, index, value):
        self.ShdwOffsetX[index] = value
    def get_ShdwOffsetY(self):
        return self.ShdwOffsetY
    def set_ShdwOffsetY(self, ShdwOffsetY):
        self.ShdwOffsetY = ShdwOffsetY
    def add_ShdwOffsetY(self, value):
        self.ShdwOffsetY.append(value)
    def insert_ShdwOffsetY_at(self, index, value):
        self.ShdwOffsetY.insert(index, value)
    def replace_ShdwOffsetY_at(self, index, value):
        self.ShdwOffsetY[index] = value
    def get_PageScale(self):
        return self.PageScale
    def set_PageScale(self, PageScale):
        self.PageScale = PageScale
    def add_PageScale(self, value):
        self.PageScale.append(value)
    def insert_PageScale_at(self, index, value):
        self.PageScale.insert(index, value)
    def replace_PageScale_at(self, index, value):
        self.PageScale[index] = value
    def get_DrawingScale(self):
        return self.DrawingScale
    def set_DrawingScale(self, DrawingScale):
        self.DrawingScale = DrawingScale
    def add_DrawingScale(self, value):
        self.DrawingScale.append(value)
    def insert_DrawingScale_at(self, index, value):
        self.DrawingScale.insert(index, value)
    def replace_DrawingScale_at(self, index, value):
        self.DrawingScale[index] = value
    def get_DrawingSizeType(self):
        return self.DrawingSizeType
    def set_DrawingSizeType(self, DrawingSizeType):
        self.DrawingSizeType = DrawingSizeType
    def add_DrawingSizeType(self, value):
        self.DrawingSizeType.append(value)
    def insert_DrawingSizeType_at(self, index, value):
        self.DrawingSizeType.insert(index, value)
    def replace_DrawingSizeType_at(self, index, value):
        self.DrawingSizeType[index] = value
    def get_DrawingScaleType(self):
        return self.DrawingScaleType
    def set_DrawingScaleType(self, DrawingScaleType):
        self.DrawingScaleType = DrawingScaleType
    def add_DrawingScaleType(self, value):
        self.DrawingScaleType.append(value)
    def insert_DrawingScaleType_at(self, index, value):
        self.DrawingScaleType.insert(index, value)
    def replace_DrawingScaleType_at(self, index, value):
        self.DrawingScaleType[index] = value
    def get_InhibitSnap(self):
        return self.InhibitSnap
    def set_InhibitSnap(self, InhibitSnap):
        self.InhibitSnap = InhibitSnap
    def add_InhibitSnap(self, value):
        self.InhibitSnap.append(value)
    def insert_InhibitSnap_at(self, index, value):
        self.InhibitSnap.insert(index, value)
    def replace_InhibitSnap_at(self, index, value):
        self.InhibitSnap[index] = value
    def get_UIVisibility(self):
        return self.UIVisibility
    def set_UIVisibility(self, UIVisibility):
        self.UIVisibility = UIVisibility
    def add_UIVisibility(self, value):
        self.UIVisibility.append(value)
    def insert_UIVisibility_at(self, index, value):
        self.UIVisibility.insert(index, value)
    def replace_UIVisibility_at(self, index, value):
        self.UIVisibility[index] = value
    def get_ShdwType(self):
        return self.ShdwType
    def set_ShdwType(self, ShdwType):
        self.ShdwType = ShdwType
    def add_ShdwType(self, value):
        self.ShdwType.append(value)
    def insert_ShdwType_at(self, index, value):
        self.ShdwType.insert(index, value)
    def replace_ShdwType_at(self, index, value):
        self.ShdwType[index] = value
    def get_ShdwObliqueAngle(self):
        return self.ShdwObliqueAngle
    def set_ShdwObliqueAngle(self, ShdwObliqueAngle):
        self.ShdwObliqueAngle = ShdwObliqueAngle
    def add_ShdwObliqueAngle(self, value):
        self.ShdwObliqueAngle.append(value)
    def insert_ShdwObliqueAngle_at(self, index, value):
        self.ShdwObliqueAngle.insert(index, value)
    def replace_ShdwObliqueAngle_at(self, index, value):
        self.ShdwObliqueAngle[index] = value
    def get_ShdwScaleFactor(self):
        return self.ShdwScaleFactor
    def set_ShdwScaleFactor(self, ShdwScaleFactor):
        self.ShdwScaleFactor = ShdwScaleFactor
    def add_ShdwScaleFactor(self, value):
        self.ShdwScaleFactor.append(value)
    def insert_ShdwScaleFactor_at(self, index, value):
        self.ShdwScaleFactor.insert(index, value)
    def replace_ShdwScaleFactor_at(self, index, value):
        self.ShdwScaleFactor[index] = value
    def get_PageColor(self):
        return self.PageColor
    def set_PageColor(self, PageColor):
        self.PageColor = PageColor
    def add_PageColor(self, value):
        self.PageColor.append(value)
    def insert_PageColor_at(self, index, value):
        self.PageColor.insert(index, value)
    def replace_PageColor_at(self, index, value):
        self.PageColor[index] = value
    def hasContent_(self):
        if (
            self.PageWidth or
            self.PageHeight or
            self.ShdwOffsetX or
            self.ShdwOffsetY or
            self.PageScale or
            self.DrawingScale or
            self.DrawingSizeType or
            self.DrawingScaleType or
            self.InhibitSnap or
            self.UIVisibility or
            self.ShdwType or
            self.ShdwObliqueAngle or
            self.ShdwScaleFactor or
            self.PageColor or
            super(PageProps_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='PageProps_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PageProps_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PageProps_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageProps_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PageProps_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PageProps_Type'):
        super(PageProps_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageProps_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='PageProps_Type', fromsubclass_=False, pretty_print=True):
        super(PageProps_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PageWidth_ in self.PageWidth:
            namespaceprefix_ = self.PageWidth_nsprefix_ + ':' if (UseCapturedNS_ and self.PageWidth_nsprefix_) else ''
            PageWidth_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PageWidth', pretty_print=pretty_print)
        for PageHeight_ in self.PageHeight:
            namespaceprefix_ = self.PageHeight_nsprefix_ + ':' if (UseCapturedNS_ and self.PageHeight_nsprefix_) else ''
            PageHeight_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PageHeight', pretty_print=pretty_print)
        for ShdwOffsetX_ in self.ShdwOffsetX:
            namespaceprefix_ = self.ShdwOffsetX_nsprefix_ + ':' if (UseCapturedNS_ and self.ShdwOffsetX_nsprefix_) else ''
            ShdwOffsetX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShdwOffsetX', pretty_print=pretty_print)
        for ShdwOffsetY_ in self.ShdwOffsetY:
            namespaceprefix_ = self.ShdwOffsetY_nsprefix_ + ':' if (UseCapturedNS_ and self.ShdwOffsetY_nsprefix_) else ''
            ShdwOffsetY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShdwOffsetY', pretty_print=pretty_print)
        for PageScale_ in self.PageScale:
            namespaceprefix_ = self.PageScale_nsprefix_ + ':' if (UseCapturedNS_ and self.PageScale_nsprefix_) else ''
            PageScale_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PageScale', pretty_print=pretty_print)
        for DrawingScale_ in self.DrawingScale:
            namespaceprefix_ = self.DrawingScale_nsprefix_ + ':' if (UseCapturedNS_ and self.DrawingScale_nsprefix_) else ''
            DrawingScale_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DrawingScale', pretty_print=pretty_print)
        for DrawingSizeType_ in self.DrawingSizeType:
            namespaceprefix_ = self.DrawingSizeType_nsprefix_ + ':' if (UseCapturedNS_ and self.DrawingSizeType_nsprefix_) else ''
            DrawingSizeType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DrawingSizeType', pretty_print=pretty_print)
        for DrawingScaleType_ in self.DrawingScaleType:
            namespaceprefix_ = self.DrawingScaleType_nsprefix_ + ':' if (UseCapturedNS_ and self.DrawingScaleType_nsprefix_) else ''
            DrawingScaleType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DrawingScaleType', pretty_print=pretty_print)
        for InhibitSnap_ in self.InhibitSnap:
            namespaceprefix_ = self.InhibitSnap_nsprefix_ + ':' if (UseCapturedNS_ and self.InhibitSnap_nsprefix_) else ''
            InhibitSnap_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InhibitSnap', pretty_print=pretty_print)
        for UIVisibility_ in self.UIVisibility:
            namespaceprefix_ = self.UIVisibility_nsprefix_ + ':' if (UseCapturedNS_ and self.UIVisibility_nsprefix_) else ''
            UIVisibility_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UIVisibility', pretty_print=pretty_print)
        for ShdwType_ in self.ShdwType:
            namespaceprefix_ = self.ShdwType_nsprefix_ + ':' if (UseCapturedNS_ and self.ShdwType_nsprefix_) else ''
            ShdwType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShdwType', pretty_print=pretty_print)
        for ShdwObliqueAngle_ in self.ShdwObliqueAngle:
            namespaceprefix_ = self.ShdwObliqueAngle_nsprefix_ + ':' if (UseCapturedNS_ and self.ShdwObliqueAngle_nsprefix_) else ''
            ShdwObliqueAngle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShdwObliqueAngle', pretty_print=pretty_print)
        for ShdwScaleFactor_ in self.ShdwScaleFactor:
            namespaceprefix_ = self.ShdwScaleFactor_nsprefix_ + ':' if (UseCapturedNS_ and self.ShdwScaleFactor_nsprefix_) else ''
            ShdwScaleFactor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShdwScaleFactor', pretty_print=pretty_print)
        for PageColor_ in self.PageColor:
            namespaceprefix_ = self.PageColor_nsprefix_ + ':' if (UseCapturedNS_ and self.PageColor_nsprefix_) else ''
            PageColor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PageColor', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PageProps_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PageWidth':
            obj_ = PageWidth_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PageWidth.append(obj_)
            obj_.original_tagname_ = 'PageWidth'
        elif nodeName_ == 'PageHeight':
            obj_ = PageHeight_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PageHeight.append(obj_)
            obj_.original_tagname_ = 'PageHeight'
        elif nodeName_ == 'ShdwOffsetX':
            obj_ = ShdwOffsetX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShdwOffsetX.append(obj_)
            obj_.original_tagname_ = 'ShdwOffsetX'
        elif nodeName_ == 'ShdwOffsetY':
            obj_ = ShdwOffsetY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShdwOffsetY.append(obj_)
            obj_.original_tagname_ = 'ShdwOffsetY'
        elif nodeName_ == 'PageScale':
            obj_ = PageScale_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PageScale.append(obj_)
            obj_.original_tagname_ = 'PageScale'
        elif nodeName_ == 'DrawingScale':
            obj_ = DrawingScale_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DrawingScale.append(obj_)
            obj_.original_tagname_ = 'DrawingScale'
        elif nodeName_ == 'DrawingSizeType':
            obj_ = DrawingSizeType_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DrawingSizeType.append(obj_)
            obj_.original_tagname_ = 'DrawingSizeType'
        elif nodeName_ == 'DrawingScaleType':
            obj_ = DrawingScaleType_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DrawingScaleType.append(obj_)
            obj_.original_tagname_ = 'DrawingScaleType'
        elif nodeName_ == 'InhibitSnap':
            obj_ = InhibitSnap_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InhibitSnap.append(obj_)
            obj_.original_tagname_ = 'InhibitSnap'
        elif nodeName_ == 'UIVisibility':
            obj_ = UIVisibility_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UIVisibility.append(obj_)
            obj_.original_tagname_ = 'UIVisibility'
        elif nodeName_ == 'ShdwType':
            obj_ = ShdwType_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShdwType.append(obj_)
            obj_.original_tagname_ = 'ShdwType'
        elif nodeName_ == 'ShdwObliqueAngle':
            obj_ = ShdwObliqueAngle_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShdwObliqueAngle.append(obj_)
            obj_.original_tagname_ = 'ShdwObliqueAngle'
        elif nodeName_ == 'ShdwScaleFactor':
            obj_ = ShdwScaleFactor_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShdwScaleFactor.append(obj_)
            obj_.original_tagname_ = 'ShdwScaleFactor'
        elif nodeName_ == 'PageColor':
            obj_ = PageColor_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PageColor.append(obj_)
            obj_.original_tagname_ = 'PageColor'
        super(PageProps_Type, self).buildChildren(child_, node, nodeName_, True)
# end class PageProps_Type


class PageWidth_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PageWidth_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PageWidth_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PageWidth_Type.subclass:
            return PageWidth_Type.subclass(*args_, **kwargs_)
        else:
            return PageWidth_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PageWidth_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageWidth_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PageWidth_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PageWidth_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageWidth_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PageWidth_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PageWidth_Type'):
        super(PageWidth_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageWidth_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageWidth_Type', fromsubclass_=False, pretty_print=True):
        super(PageWidth_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PageWidth_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PageWidth_Type


class PageHeight_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PageHeight_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PageHeight_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PageHeight_Type.subclass:
            return PageHeight_Type.subclass(*args_, **kwargs_)
        else:
            return PageHeight_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PageHeight_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageHeight_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PageHeight_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PageHeight_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageHeight_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PageHeight_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PageHeight_Type'):
        super(PageHeight_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageHeight_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageHeight_Type', fromsubclass_=False, pretty_print=True):
        super(PageHeight_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PageHeight_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PageHeight_Type


class ShdwOffsetX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShdwOffsetX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShdwOffsetX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShdwOffsetX_Type.subclass:
            return ShdwOffsetX_Type.subclass(*args_, **kwargs_)
        else:
            return ShdwOffsetX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShdwOffsetX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwOffsetX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShdwOffsetX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShdwOffsetX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwOffsetX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShdwOffsetX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShdwOffsetX_Type'):
        super(ShdwOffsetX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwOffsetX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwOffsetX_Type', fromsubclass_=False, pretty_print=True):
        super(ShdwOffsetX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShdwOffsetX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShdwOffsetX_Type


class ShdwOffsetY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShdwOffsetY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShdwOffsetY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShdwOffsetY_Type.subclass:
            return ShdwOffsetY_Type.subclass(*args_, **kwargs_)
        else:
            return ShdwOffsetY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShdwOffsetY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwOffsetY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShdwOffsetY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShdwOffsetY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwOffsetY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShdwOffsetY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShdwOffsetY_Type'):
        super(ShdwOffsetY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwOffsetY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwOffsetY_Type', fromsubclass_=False, pretty_print=True):
        super(ShdwOffsetY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShdwOffsetY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShdwOffsetY_Type


class PageScale_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PageScale_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PageScale_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PageScale_Type.subclass:
            return PageScale_Type.subclass(*args_, **kwargs_)
        else:
            return PageScale_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PageScale_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageScale_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PageScale_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PageScale_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageScale_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PageScale_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PageScale_Type'):
        super(PageScale_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageScale_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageScale_Type', fromsubclass_=False, pretty_print=True):
        super(PageScale_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PageScale_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PageScale_Type


class DrawingScale_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DrawingScale_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DrawingScale_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DrawingScale_Type.subclass:
            return DrawingScale_Type.subclass(*args_, **kwargs_)
        else:
            return DrawingScale_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DrawingScale_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DrawingScale_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DrawingScale_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DrawingScale_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DrawingScale_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DrawingScale_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DrawingScale_Type'):
        super(DrawingScale_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DrawingScale_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DrawingScale_Type', fromsubclass_=False, pretty_print=True):
        super(DrawingScale_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DrawingScale_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DrawingScale_Type


class DrawingSizeType_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DrawingSizeType_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DrawingSizeType_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DrawingSizeType_Type.subclass:
            return DrawingSizeType_Type.subclass(*args_, **kwargs_)
        else:
            return DrawingSizeType_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DrawingSizeType_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DrawingSizeType_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DrawingSizeType_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DrawingSizeType_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DrawingSizeType_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DrawingSizeType_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DrawingSizeType_Type'):
        super(DrawingSizeType_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DrawingSizeType_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DrawingSizeType_Type', fromsubclass_=False, pretty_print=True):
        super(DrawingSizeType_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DrawingSizeType_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DrawingSizeType_Type


class DrawingScaleType_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DrawingScaleType_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DrawingScaleType_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DrawingScaleType_Type.subclass:
            return DrawingScaleType_Type.subclass(*args_, **kwargs_)
        else:
            return DrawingScaleType_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DrawingScaleType_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DrawingScaleType_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DrawingScaleType_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DrawingScaleType_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DrawingScaleType_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DrawingScaleType_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DrawingScaleType_Type'):
        super(DrawingScaleType_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DrawingScaleType_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DrawingScaleType_Type', fromsubclass_=False, pretty_print=True):
        super(DrawingScaleType_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DrawingScaleType_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DrawingScaleType_Type


class InhibitSnap_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(InhibitSnap_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InhibitSnap_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InhibitSnap_Type.subclass:
            return InhibitSnap_Type.subclass(*args_, **kwargs_)
        else:
            return InhibitSnap_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(InhibitSnap_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InhibitSnap_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InhibitSnap_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InhibitSnap_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InhibitSnap_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InhibitSnap_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InhibitSnap_Type'):
        super(InhibitSnap_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InhibitSnap_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InhibitSnap_Type', fromsubclass_=False, pretty_print=True):
        super(InhibitSnap_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InhibitSnap_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class InhibitSnap_Type


class UIVisibility_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(UIVisibility_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UIVisibility_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UIVisibility_Type.subclass:
            return UIVisibility_Type.subclass(*args_, **kwargs_)
        else:
            return UIVisibility_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(UIVisibility_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UIVisibility_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UIVisibility_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UIVisibility_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UIVisibility_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UIVisibility_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UIVisibility_Type'):
        super(UIVisibility_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UIVisibility_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UIVisibility_Type', fromsubclass_=False, pretty_print=True):
        super(UIVisibility_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UIVisibility_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class UIVisibility_Type


class ShdwType_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShdwType_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShdwType_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShdwType_Type.subclass:
            return ShdwType_Type.subclass(*args_, **kwargs_)
        else:
            return ShdwType_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShdwType_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwType_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShdwType_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShdwType_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwType_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShdwType_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShdwType_Type'):
        super(ShdwType_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwType_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwType_Type', fromsubclass_=False, pretty_print=True):
        super(ShdwType_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShdwType_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShdwType_Type


class ShdwObliqueAngle_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShdwObliqueAngle_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShdwObliqueAngle_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShdwObliqueAngle_Type.subclass:
            return ShdwObliqueAngle_Type.subclass(*args_, **kwargs_)
        else:
            return ShdwObliqueAngle_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShdwObliqueAngle_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwObliqueAngle_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShdwObliqueAngle_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShdwObliqueAngle_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwObliqueAngle_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShdwObliqueAngle_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShdwObliqueAngle_Type'):
        super(ShdwObliqueAngle_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwObliqueAngle_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwObliqueAngle_Type', fromsubclass_=False, pretty_print=True):
        super(ShdwObliqueAngle_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShdwObliqueAngle_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShdwObliqueAngle_Type


class ShdwScaleFactor_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShdwScaleFactor_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShdwScaleFactor_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShdwScaleFactor_Type.subclass:
            return ShdwScaleFactor_Type.subclass(*args_, **kwargs_)
        else:
            return ShdwScaleFactor_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShdwScaleFactor_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwScaleFactor_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShdwScaleFactor_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShdwScaleFactor_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwScaleFactor_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShdwScaleFactor_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShdwScaleFactor_Type'):
        super(ShdwScaleFactor_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShdwScaleFactor_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShdwScaleFactor_Type', fromsubclass_=False, pretty_print=True):
        super(ShdwScaleFactor_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShdwScaleFactor_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShdwScaleFactor_Type


class PageColor_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PageColor_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PageColor_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PageColor_Type.subclass:
            return PageColor_Type.subclass(*args_, **kwargs_)
        else:
            return PageColor_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PageColor_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageColor_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PageColor_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PageColor_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageColor_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PageColor_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PageColor_Type'):
        super(PageColor_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageColor_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageColor_Type', fromsubclass_=False, pretty_print=True):
        super(PageColor_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PageColor_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PageColor_Type


class TextBlock_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, LeftMargin=None, RightMargin=None, TopMargin=None, BottomMargin=None, VerticalAlign=None, TextBkgnd=None, DefaultTabStop=None, TextDirection=None, TextBkgndTrans=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TextBlock_Type, self).__init__(Del,  **kwargs_)
        if LeftMargin is None:
            self.LeftMargin = []
        else:
            self.LeftMargin = LeftMargin
        self.LeftMargin_nsprefix_ = None
        if RightMargin is None:
            self.RightMargin = []
        else:
            self.RightMargin = RightMargin
        self.RightMargin_nsprefix_ = None
        if TopMargin is None:
            self.TopMargin = []
        else:
            self.TopMargin = TopMargin
        self.TopMargin_nsprefix_ = None
        if BottomMargin is None:
            self.BottomMargin = []
        else:
            self.BottomMargin = BottomMargin
        self.BottomMargin_nsprefix_ = None
        if VerticalAlign is None:
            self.VerticalAlign = []
        else:
            self.VerticalAlign = VerticalAlign
        self.VerticalAlign_nsprefix_ = None
        if TextBkgnd is None:
            self.TextBkgnd = []
        else:
            self.TextBkgnd = TextBkgnd
        self.TextBkgnd_nsprefix_ = None
        if DefaultTabStop is None:
            self.DefaultTabStop = []
        else:
            self.DefaultTabStop = DefaultTabStop
        self.DefaultTabStop_nsprefix_ = None
        if TextDirection is None:
            self.TextDirection = []
        else:
            self.TextDirection = TextDirection
        self.TextDirection_nsprefix_ = None
        if TextBkgndTrans is None:
            self.TextBkgndTrans = []
        else:
            self.TextBkgndTrans = TextBkgndTrans
        self.TextBkgndTrans_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextBlock_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextBlock_Type.subclass:
            return TextBlock_Type.subclass(*args_, **kwargs_)
        else:
            return TextBlock_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LeftMargin(self):
        return self.LeftMargin
    def set_LeftMargin(self, LeftMargin):
        self.LeftMargin = LeftMargin
    def add_LeftMargin(self, value):
        self.LeftMargin.append(value)
    def insert_LeftMargin_at(self, index, value):
        self.LeftMargin.insert(index, value)
    def replace_LeftMargin_at(self, index, value):
        self.LeftMargin[index] = value
    def get_RightMargin(self):
        return self.RightMargin
    def set_RightMargin(self, RightMargin):
        self.RightMargin = RightMargin
    def add_RightMargin(self, value):
        self.RightMargin.append(value)
    def insert_RightMargin_at(self, index, value):
        self.RightMargin.insert(index, value)
    def replace_RightMargin_at(self, index, value):
        self.RightMargin[index] = value
    def get_TopMargin(self):
        return self.TopMargin
    def set_TopMargin(self, TopMargin):
        self.TopMargin = TopMargin
    def add_TopMargin(self, value):
        self.TopMargin.append(value)
    def insert_TopMargin_at(self, index, value):
        self.TopMargin.insert(index, value)
    def replace_TopMargin_at(self, index, value):
        self.TopMargin[index] = value
    def get_BottomMargin(self):
        return self.BottomMargin
    def set_BottomMargin(self, BottomMargin):
        self.BottomMargin = BottomMargin
    def add_BottomMargin(self, value):
        self.BottomMargin.append(value)
    def insert_BottomMargin_at(self, index, value):
        self.BottomMargin.insert(index, value)
    def replace_BottomMargin_at(self, index, value):
        self.BottomMargin[index] = value
    def get_VerticalAlign(self):
        return self.VerticalAlign
    def set_VerticalAlign(self, VerticalAlign):
        self.VerticalAlign = VerticalAlign
    def add_VerticalAlign(self, value):
        self.VerticalAlign.append(value)
    def insert_VerticalAlign_at(self, index, value):
        self.VerticalAlign.insert(index, value)
    def replace_VerticalAlign_at(self, index, value):
        self.VerticalAlign[index] = value
    def get_TextBkgnd(self):
        return self.TextBkgnd
    def set_TextBkgnd(self, TextBkgnd):
        self.TextBkgnd = TextBkgnd
    def add_TextBkgnd(self, value):
        self.TextBkgnd.append(value)
    def insert_TextBkgnd_at(self, index, value):
        self.TextBkgnd.insert(index, value)
    def replace_TextBkgnd_at(self, index, value):
        self.TextBkgnd[index] = value
    def get_DefaultTabStop(self):
        return self.DefaultTabStop
    def set_DefaultTabStop(self, DefaultTabStop):
        self.DefaultTabStop = DefaultTabStop
    def add_DefaultTabStop(self, value):
        self.DefaultTabStop.append(value)
    def insert_DefaultTabStop_at(self, index, value):
        self.DefaultTabStop.insert(index, value)
    def replace_DefaultTabStop_at(self, index, value):
        self.DefaultTabStop[index] = value
    def get_TextDirection(self):
        return self.TextDirection
    def set_TextDirection(self, TextDirection):
        self.TextDirection = TextDirection
    def add_TextDirection(self, value):
        self.TextDirection.append(value)
    def insert_TextDirection_at(self, index, value):
        self.TextDirection.insert(index, value)
    def replace_TextDirection_at(self, index, value):
        self.TextDirection[index] = value
    def get_TextBkgndTrans(self):
        return self.TextBkgndTrans
    def set_TextBkgndTrans(self, TextBkgndTrans):
        self.TextBkgndTrans = TextBkgndTrans
    def add_TextBkgndTrans(self, value):
        self.TextBkgndTrans.append(value)
    def insert_TextBkgndTrans_at(self, index, value):
        self.TextBkgndTrans.insert(index, value)
    def replace_TextBkgndTrans_at(self, index, value):
        self.TextBkgndTrans[index] = value
    def hasContent_(self):
        if (
            self.LeftMargin or
            self.RightMargin or
            self.TopMargin or
            self.BottomMargin or
            self.VerticalAlign or
            self.TextBkgnd or
            self.DefaultTabStop or
            self.TextDirection or
            self.TextBkgndTrans or
            super(TextBlock_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='TextBlock_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextBlock_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextBlock_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextBlock_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextBlock_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextBlock_Type'):
        super(TextBlock_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextBlock_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='TextBlock_Type', fromsubclass_=False, pretty_print=True):
        super(TextBlock_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LeftMargin_ in self.LeftMargin:
            namespaceprefix_ = self.LeftMargin_nsprefix_ + ':' if (UseCapturedNS_ and self.LeftMargin_nsprefix_) else ''
            LeftMargin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LeftMargin', pretty_print=pretty_print)
        for RightMargin_ in self.RightMargin:
            namespaceprefix_ = self.RightMargin_nsprefix_ + ':' if (UseCapturedNS_ and self.RightMargin_nsprefix_) else ''
            RightMargin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RightMargin', pretty_print=pretty_print)
        for TopMargin_ in self.TopMargin:
            namespaceprefix_ = self.TopMargin_nsprefix_ + ':' if (UseCapturedNS_ and self.TopMargin_nsprefix_) else ''
            TopMargin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TopMargin', pretty_print=pretty_print)
        for BottomMargin_ in self.BottomMargin:
            namespaceprefix_ = self.BottomMargin_nsprefix_ + ':' if (UseCapturedNS_ and self.BottomMargin_nsprefix_) else ''
            BottomMargin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BottomMargin', pretty_print=pretty_print)
        for VerticalAlign_ in self.VerticalAlign:
            namespaceprefix_ = self.VerticalAlign_nsprefix_ + ':' if (UseCapturedNS_ and self.VerticalAlign_nsprefix_) else ''
            VerticalAlign_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VerticalAlign', pretty_print=pretty_print)
        for TextBkgnd_ in self.TextBkgnd:
            namespaceprefix_ = self.TextBkgnd_nsprefix_ + ':' if (UseCapturedNS_ and self.TextBkgnd_nsprefix_) else ''
            TextBkgnd_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextBkgnd', pretty_print=pretty_print)
        for DefaultTabStop_ in self.DefaultTabStop:
            namespaceprefix_ = self.DefaultTabStop_nsprefix_ + ':' if (UseCapturedNS_ and self.DefaultTabStop_nsprefix_) else ''
            DefaultTabStop_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DefaultTabStop', pretty_print=pretty_print)
        for TextDirection_ in self.TextDirection:
            namespaceprefix_ = self.TextDirection_nsprefix_ + ':' if (UseCapturedNS_ and self.TextDirection_nsprefix_) else ''
            TextDirection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextDirection', pretty_print=pretty_print)
        for TextBkgndTrans_ in self.TextBkgndTrans:
            namespaceprefix_ = self.TextBkgndTrans_nsprefix_ + ':' if (UseCapturedNS_ and self.TextBkgndTrans_nsprefix_) else ''
            TextBkgndTrans_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextBkgndTrans', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TextBlock_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LeftMargin':
            obj_ = LeftMargin_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LeftMargin.append(obj_)
            obj_.original_tagname_ = 'LeftMargin'
        elif nodeName_ == 'RightMargin':
            obj_ = RightMargin_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RightMargin.append(obj_)
            obj_.original_tagname_ = 'RightMargin'
        elif nodeName_ == 'TopMargin':
            obj_ = TopMargin_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TopMargin.append(obj_)
            obj_.original_tagname_ = 'TopMargin'
        elif nodeName_ == 'BottomMargin':
            obj_ = BottomMargin_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BottomMargin.append(obj_)
            obj_.original_tagname_ = 'BottomMargin'
        elif nodeName_ == 'VerticalAlign':
            obj_ = VerticalAlign_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VerticalAlign.append(obj_)
            obj_.original_tagname_ = 'VerticalAlign'
        elif nodeName_ == 'TextBkgnd':
            obj_ = TextBkgnd_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TextBkgnd.append(obj_)
            obj_.original_tagname_ = 'TextBkgnd'
        elif nodeName_ == 'DefaultTabStop':
            obj_ = DefaultTabStop_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DefaultTabStop.append(obj_)
            obj_.original_tagname_ = 'DefaultTabStop'
        elif nodeName_ == 'TextDirection':
            obj_ = TextDirection_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TextDirection.append(obj_)
            obj_.original_tagname_ = 'TextDirection'
        elif nodeName_ == 'TextBkgndTrans':
            obj_ = TextBkgndTrans_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TextBkgndTrans.append(obj_)
            obj_.original_tagname_ = 'TextBkgndTrans'
        super(TextBlock_Type, self).buildChildren(child_, node, nodeName_, True)
# end class TextBlock_Type


class LeftMargin_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LeftMargin_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LeftMargin_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LeftMargin_Type.subclass:
            return LeftMargin_Type.subclass(*args_, **kwargs_)
        else:
            return LeftMargin_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LeftMargin_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LeftMargin_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LeftMargin_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LeftMargin_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LeftMargin_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LeftMargin_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LeftMargin_Type'):
        super(LeftMargin_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LeftMargin_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LeftMargin_Type', fromsubclass_=False, pretty_print=True):
        super(LeftMargin_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LeftMargin_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LeftMargin_Type


class RightMargin_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RightMargin_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RightMargin_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RightMargin_Type.subclass:
            return RightMargin_Type.subclass(*args_, **kwargs_)
        else:
            return RightMargin_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(RightMargin_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RightMargin_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RightMargin_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RightMargin_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RightMargin_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RightMargin_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RightMargin_Type'):
        super(RightMargin_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RightMargin_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RightMargin_Type', fromsubclass_=False, pretty_print=True):
        super(RightMargin_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RightMargin_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RightMargin_Type


class TopMargin_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TopMargin_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TopMargin_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TopMargin_Type.subclass:
            return TopMargin_Type.subclass(*args_, **kwargs_)
        else:
            return TopMargin_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TopMargin_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TopMargin_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TopMargin_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TopMargin_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TopMargin_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TopMargin_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TopMargin_Type'):
        super(TopMargin_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TopMargin_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TopMargin_Type', fromsubclass_=False, pretty_print=True):
        super(TopMargin_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TopMargin_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TopMargin_Type


class BottomMargin_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BottomMargin_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BottomMargin_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BottomMargin_Type.subclass:
            return BottomMargin_Type.subclass(*args_, **kwargs_)
        else:
            return BottomMargin_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(BottomMargin_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BottomMargin_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BottomMargin_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BottomMargin_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BottomMargin_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BottomMargin_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BottomMargin_Type'):
        super(BottomMargin_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BottomMargin_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BottomMargin_Type', fromsubclass_=False, pretty_print=True):
        super(BottomMargin_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BottomMargin_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BottomMargin_Type


class VerticalAlign_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(VerticalAlign_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerticalAlign_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerticalAlign_Type.subclass:
            return VerticalAlign_Type.subclass(*args_, **kwargs_)
        else:
            return VerticalAlign_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(VerticalAlign_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VerticalAlign_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VerticalAlign_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VerticalAlign_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VerticalAlign_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VerticalAlign_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VerticalAlign_Type'):
        super(VerticalAlign_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VerticalAlign_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VerticalAlign_Type', fromsubclass_=False, pretty_print=True):
        super(VerticalAlign_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VerticalAlign_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class VerticalAlign_Type


class TextBkgnd_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TextBkgnd_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextBkgnd_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextBkgnd_Type.subclass:
            return TextBkgnd_Type.subclass(*args_, **kwargs_)
        else:
            return TextBkgnd_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TextBkgnd_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextBkgnd_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextBkgnd_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextBkgnd_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextBkgnd_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextBkgnd_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextBkgnd_Type'):
        super(TextBkgnd_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextBkgnd_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextBkgnd_Type', fromsubclass_=False, pretty_print=True):
        super(TextBkgnd_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TextBkgnd_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TextBkgnd_Type


class DefaultTabStop_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DefaultTabStop_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DefaultTabStop_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DefaultTabStop_Type.subclass:
            return DefaultTabStop_Type.subclass(*args_, **kwargs_)
        else:
            return DefaultTabStop_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DefaultTabStop_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DefaultTabStop_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DefaultTabStop_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DefaultTabStop_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DefaultTabStop_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DefaultTabStop_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DefaultTabStop_Type'):
        super(DefaultTabStop_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DefaultTabStop_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DefaultTabStop_Type', fromsubclass_=False, pretty_print=True):
        super(DefaultTabStop_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DefaultTabStop_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DefaultTabStop_Type


class TextDirection_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TextDirection_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextDirection_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextDirection_Type.subclass:
            return TextDirection_Type.subclass(*args_, **kwargs_)
        else:
            return TextDirection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TextDirection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextDirection_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextDirection_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextDirection_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextDirection_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextDirection_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextDirection_Type'):
        super(TextDirection_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextDirection_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextDirection_Type', fromsubclass_=False, pretty_print=True):
        super(TextDirection_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TextDirection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TextDirection_Type


class TextBkgndTrans_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TextBkgndTrans_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextBkgndTrans_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextBkgndTrans_Type.subclass:
            return TextBkgndTrans_Type.subclass(*args_, **kwargs_)
        else:
            return TextBkgndTrans_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TextBkgndTrans_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextBkgndTrans_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextBkgndTrans_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextBkgndTrans_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextBkgndTrans_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextBkgndTrans_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextBkgndTrans_Type'):
        super(TextBkgndTrans_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextBkgndTrans_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextBkgndTrans_Type', fromsubclass_=False, pretty_print=True):
        super(TextBkgndTrans_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TextBkgndTrans_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TextBkgndTrans_Type


class Flags_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Flags_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Flags_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Flags_Type.subclass:
            return Flags_Type.subclass(*args_, **kwargs_)
        else:
            return Flags_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Flags_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Flags_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Flags_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Flags_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Flags_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Flags_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Flags_Type'):
        super(Flags_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Flags_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Flags_Type', fromsubclass_=False, pretty_print=True):
        super(Flags_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Flags_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Flags_Type


class DiacriticColor_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DiacriticColor_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiacriticColor_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiacriticColor_Type.subclass:
            return DiacriticColor_Type.subclass(*args_, **kwargs_)
        else:
            return DiacriticColor_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DiacriticColor_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DiacriticColor_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DiacriticColor_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DiacriticColor_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DiacriticColor_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DiacriticColor_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DiacriticColor_Type'):
        super(DiacriticColor_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DiacriticColor_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DiacriticColor_Type', fromsubclass_=False, pretty_print=True):
        super(DiacriticColor_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DiacriticColor_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DiacriticColor_Type


class ExProps_Type(XPropsCell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = XPropsCell_Type
    def __init__(self, XProp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ExProps_Type, self).__init__(XProp,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExProps_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExProps_Type.subclass:
            return ExProps_Type.subclass(*args_, **kwargs_)
        else:
            return ExProps_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (
            super(ExProps_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExProps_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExProps_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ExProps_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExProps_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExProps_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExProps_Type'):
        super(ExProps_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExProps_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExProps_Type', fromsubclass_=False, pretty_print=True):
        super(ExProps_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExProps_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ExProps_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExProps_Type


class TextXForm_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, TxtPinX=None, TxtPinY=None, TxtWidth=None, TxtHeight=None, TxtLocPinX=None, TxtLocPinY=None, TxtAngle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TextXForm_Type, self).__init__(Del,  **kwargs_)
        if TxtPinX is None:
            self.TxtPinX = []
        else:
            self.TxtPinX = TxtPinX
        self.TxtPinX_nsprefix_ = None
        if TxtPinY is None:
            self.TxtPinY = []
        else:
            self.TxtPinY = TxtPinY
        self.TxtPinY_nsprefix_ = None
        if TxtWidth is None:
            self.TxtWidth = []
        else:
            self.TxtWidth = TxtWidth
        self.TxtWidth_nsprefix_ = None
        if TxtHeight is None:
            self.TxtHeight = []
        else:
            self.TxtHeight = TxtHeight
        self.TxtHeight_nsprefix_ = None
        if TxtLocPinX is None:
            self.TxtLocPinX = []
        else:
            self.TxtLocPinX = TxtLocPinX
        self.TxtLocPinX_nsprefix_ = None
        if TxtLocPinY is None:
            self.TxtLocPinY = []
        else:
            self.TxtLocPinY = TxtLocPinY
        self.TxtLocPinY_nsprefix_ = None
        if TxtAngle is None:
            self.TxtAngle = []
        else:
            self.TxtAngle = TxtAngle
        self.TxtAngle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextXForm_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextXForm_Type.subclass:
            return TextXForm_Type.subclass(*args_, **kwargs_)
        else:
            return TextXForm_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TxtPinX(self):
        return self.TxtPinX
    def set_TxtPinX(self, TxtPinX):
        self.TxtPinX = TxtPinX
    def add_TxtPinX(self, value):
        self.TxtPinX.append(value)
    def insert_TxtPinX_at(self, index, value):
        self.TxtPinX.insert(index, value)
    def replace_TxtPinX_at(self, index, value):
        self.TxtPinX[index] = value
    def get_TxtPinY(self):
        return self.TxtPinY
    def set_TxtPinY(self, TxtPinY):
        self.TxtPinY = TxtPinY
    def add_TxtPinY(self, value):
        self.TxtPinY.append(value)
    def insert_TxtPinY_at(self, index, value):
        self.TxtPinY.insert(index, value)
    def replace_TxtPinY_at(self, index, value):
        self.TxtPinY[index] = value
    def get_TxtWidth(self):
        return self.TxtWidth
    def set_TxtWidth(self, TxtWidth):
        self.TxtWidth = TxtWidth
    def add_TxtWidth(self, value):
        self.TxtWidth.append(value)
    def insert_TxtWidth_at(self, index, value):
        self.TxtWidth.insert(index, value)
    def replace_TxtWidth_at(self, index, value):
        self.TxtWidth[index] = value
    def get_TxtHeight(self):
        return self.TxtHeight
    def set_TxtHeight(self, TxtHeight):
        self.TxtHeight = TxtHeight
    def add_TxtHeight(self, value):
        self.TxtHeight.append(value)
    def insert_TxtHeight_at(self, index, value):
        self.TxtHeight.insert(index, value)
    def replace_TxtHeight_at(self, index, value):
        self.TxtHeight[index] = value
    def get_TxtLocPinX(self):
        return self.TxtLocPinX
    def set_TxtLocPinX(self, TxtLocPinX):
        self.TxtLocPinX = TxtLocPinX
    def add_TxtLocPinX(self, value):
        self.TxtLocPinX.append(value)
    def insert_TxtLocPinX_at(self, index, value):
        self.TxtLocPinX.insert(index, value)
    def replace_TxtLocPinX_at(self, index, value):
        self.TxtLocPinX[index] = value
    def get_TxtLocPinY(self):
        return self.TxtLocPinY
    def set_TxtLocPinY(self, TxtLocPinY):
        self.TxtLocPinY = TxtLocPinY
    def add_TxtLocPinY(self, value):
        self.TxtLocPinY.append(value)
    def insert_TxtLocPinY_at(self, index, value):
        self.TxtLocPinY.insert(index, value)
    def replace_TxtLocPinY_at(self, index, value):
        self.TxtLocPinY[index] = value
    def get_TxtAngle(self):
        return self.TxtAngle
    def set_TxtAngle(self, TxtAngle):
        self.TxtAngle = TxtAngle
    def add_TxtAngle(self, value):
        self.TxtAngle.append(value)
    def insert_TxtAngle_at(self, index, value):
        self.TxtAngle.insert(index, value)
    def replace_TxtAngle_at(self, index, value):
        self.TxtAngle[index] = value
    def hasContent_(self):
        if (
            self.TxtPinX or
            self.TxtPinY or
            self.TxtWidth or
            self.TxtHeight or
            self.TxtLocPinX or
            self.TxtLocPinY or
            self.TxtAngle or
            super(TextXForm_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='TextXForm_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextXForm_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextXForm_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextXForm_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextXForm_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextXForm_Type'):
        super(TextXForm_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextXForm_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='TextXForm_Type', fromsubclass_=False, pretty_print=True):
        super(TextXForm_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TxtPinX_ in self.TxtPinX:
            namespaceprefix_ = self.TxtPinX_nsprefix_ + ':' if (UseCapturedNS_ and self.TxtPinX_nsprefix_) else ''
            TxtPinX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TxtPinX', pretty_print=pretty_print)
        for TxtPinY_ in self.TxtPinY:
            namespaceprefix_ = self.TxtPinY_nsprefix_ + ':' if (UseCapturedNS_ and self.TxtPinY_nsprefix_) else ''
            TxtPinY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TxtPinY', pretty_print=pretty_print)
        for TxtWidth_ in self.TxtWidth:
            namespaceprefix_ = self.TxtWidth_nsprefix_ + ':' if (UseCapturedNS_ and self.TxtWidth_nsprefix_) else ''
            TxtWidth_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TxtWidth', pretty_print=pretty_print)
        for TxtHeight_ in self.TxtHeight:
            namespaceprefix_ = self.TxtHeight_nsprefix_ + ':' if (UseCapturedNS_ and self.TxtHeight_nsprefix_) else ''
            TxtHeight_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TxtHeight', pretty_print=pretty_print)
        for TxtLocPinX_ in self.TxtLocPinX:
            namespaceprefix_ = self.TxtLocPinX_nsprefix_ + ':' if (UseCapturedNS_ and self.TxtLocPinX_nsprefix_) else ''
            TxtLocPinX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TxtLocPinX', pretty_print=pretty_print)
        for TxtLocPinY_ in self.TxtLocPinY:
            namespaceprefix_ = self.TxtLocPinY_nsprefix_ + ':' if (UseCapturedNS_ and self.TxtLocPinY_nsprefix_) else ''
            TxtLocPinY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TxtLocPinY', pretty_print=pretty_print)
        for TxtAngle_ in self.TxtAngle:
            namespaceprefix_ = self.TxtAngle_nsprefix_ + ':' if (UseCapturedNS_ and self.TxtAngle_nsprefix_) else ''
            TxtAngle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TxtAngle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TextXForm_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TxtPinX':
            obj_ = TxtPinX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TxtPinX.append(obj_)
            obj_.original_tagname_ = 'TxtPinX'
        elif nodeName_ == 'TxtPinY':
            obj_ = TxtPinY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TxtPinY.append(obj_)
            obj_.original_tagname_ = 'TxtPinY'
        elif nodeName_ == 'TxtWidth':
            obj_ = TxtWidth_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TxtWidth.append(obj_)
            obj_.original_tagname_ = 'TxtWidth'
        elif nodeName_ == 'TxtHeight':
            obj_ = TxtHeight_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TxtHeight.append(obj_)
            obj_.original_tagname_ = 'TxtHeight'
        elif nodeName_ == 'TxtLocPinX':
            obj_ = TxtLocPinX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TxtLocPinX.append(obj_)
            obj_.original_tagname_ = 'TxtLocPinX'
        elif nodeName_ == 'TxtLocPinY':
            obj_ = TxtLocPinY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TxtLocPinY.append(obj_)
            obj_.original_tagname_ = 'TxtLocPinY'
        elif nodeName_ == 'TxtAngle':
            obj_ = TxtAngle_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TxtAngle.append(obj_)
            obj_.original_tagname_ = 'TxtAngle'
        super(TextXForm_Type, self).buildChildren(child_, node, nodeName_, True)
# end class TextXForm_Type


class TxtPinX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TxtPinX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TxtPinX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TxtPinX_Type.subclass:
            return TxtPinX_Type.subclass(*args_, **kwargs_)
        else:
            return TxtPinX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TxtPinX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TxtPinX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TxtPinX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TxtPinX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TxtPinX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TxtPinX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TxtPinX_Type'):
        super(TxtPinX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TxtPinX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TxtPinX_Type', fromsubclass_=False, pretty_print=True):
        super(TxtPinX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TxtPinX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TxtPinX_Type


class TxtPinY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TxtPinY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TxtPinY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TxtPinY_Type.subclass:
            return TxtPinY_Type.subclass(*args_, **kwargs_)
        else:
            return TxtPinY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TxtPinY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TxtPinY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TxtPinY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TxtPinY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TxtPinY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TxtPinY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TxtPinY_Type'):
        super(TxtPinY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TxtPinY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TxtPinY_Type', fromsubclass_=False, pretty_print=True):
        super(TxtPinY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TxtPinY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TxtPinY_Type


class TxtWidth_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TxtWidth_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TxtWidth_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TxtWidth_Type.subclass:
            return TxtWidth_Type.subclass(*args_, **kwargs_)
        else:
            return TxtWidth_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TxtWidth_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TxtWidth_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TxtWidth_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TxtWidth_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TxtWidth_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TxtWidth_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TxtWidth_Type'):
        super(TxtWidth_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TxtWidth_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TxtWidth_Type', fromsubclass_=False, pretty_print=True):
        super(TxtWidth_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TxtWidth_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TxtWidth_Type


class TxtHeight_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TxtHeight_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TxtHeight_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TxtHeight_Type.subclass:
            return TxtHeight_Type.subclass(*args_, **kwargs_)
        else:
            return TxtHeight_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TxtHeight_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TxtHeight_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TxtHeight_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TxtHeight_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TxtHeight_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TxtHeight_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TxtHeight_Type'):
        super(TxtHeight_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TxtHeight_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TxtHeight_Type', fromsubclass_=False, pretty_print=True):
        super(TxtHeight_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TxtHeight_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TxtHeight_Type


class TxtLocPinX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TxtLocPinX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TxtLocPinX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TxtLocPinX_Type.subclass:
            return TxtLocPinX_Type.subclass(*args_, **kwargs_)
        else:
            return TxtLocPinX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TxtLocPinX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TxtLocPinX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TxtLocPinX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TxtLocPinX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TxtLocPinX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TxtLocPinX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TxtLocPinX_Type'):
        super(TxtLocPinX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TxtLocPinX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TxtLocPinX_Type', fromsubclass_=False, pretty_print=True):
        super(TxtLocPinX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TxtLocPinX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TxtLocPinX_Type


class TxtLocPinY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TxtLocPinY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TxtLocPinY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TxtLocPinY_Type.subclass:
            return TxtLocPinY_Type.subclass(*args_, **kwargs_)
        else:
            return TxtLocPinY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TxtLocPinY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TxtLocPinY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TxtLocPinY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TxtLocPinY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TxtLocPinY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TxtLocPinY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TxtLocPinY_Type'):
        super(TxtLocPinY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TxtLocPinY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TxtLocPinY_Type', fromsubclass_=False, pretty_print=True):
        super(TxtLocPinY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TxtLocPinY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TxtLocPinY_Type


class TxtAngle_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TxtAngle_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TxtAngle_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TxtAngle_Type.subclass:
            return TxtAngle_Type.subclass(*args_, **kwargs_)
        else:
            return TxtAngle_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TxtAngle_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TxtAngle_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TxtAngle_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TxtAngle_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TxtAngle_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TxtAngle_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TxtAngle_Type'):
        super(TxtAngle_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TxtAngle_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TxtAngle_Type', fromsubclass_=False, pretty_print=True):
        super(TxtAngle_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TxtAngle_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TxtAngle_Type


class Align_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, AlignLeft=None, AlignCenter=None, AlignRight=None, AlignTop=None, AlignMiddle=None, AlignBottom=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Align_Type, self).__init__(Del,  **kwargs_)
        if AlignLeft is None:
            self.AlignLeft = []
        else:
            self.AlignLeft = AlignLeft
        self.AlignLeft_nsprefix_ = None
        if AlignCenter is None:
            self.AlignCenter = []
        else:
            self.AlignCenter = AlignCenter
        self.AlignCenter_nsprefix_ = None
        if AlignRight is None:
            self.AlignRight = []
        else:
            self.AlignRight = AlignRight
        self.AlignRight_nsprefix_ = None
        if AlignTop is None:
            self.AlignTop = []
        else:
            self.AlignTop = AlignTop
        self.AlignTop_nsprefix_ = None
        if AlignMiddle is None:
            self.AlignMiddle = []
        else:
            self.AlignMiddle = AlignMiddle
        self.AlignMiddle_nsprefix_ = None
        if AlignBottom is None:
            self.AlignBottom = []
        else:
            self.AlignBottom = AlignBottom
        self.AlignBottom_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Align_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Align_Type.subclass:
            return Align_Type.subclass(*args_, **kwargs_)
        else:
            return Align_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AlignLeft(self):
        return self.AlignLeft
    def set_AlignLeft(self, AlignLeft):
        self.AlignLeft = AlignLeft
    def add_AlignLeft(self, value):
        self.AlignLeft.append(value)
    def insert_AlignLeft_at(self, index, value):
        self.AlignLeft.insert(index, value)
    def replace_AlignLeft_at(self, index, value):
        self.AlignLeft[index] = value
    def get_AlignCenter(self):
        return self.AlignCenter
    def set_AlignCenter(self, AlignCenter):
        self.AlignCenter = AlignCenter
    def add_AlignCenter(self, value):
        self.AlignCenter.append(value)
    def insert_AlignCenter_at(self, index, value):
        self.AlignCenter.insert(index, value)
    def replace_AlignCenter_at(self, index, value):
        self.AlignCenter[index] = value
    def get_AlignRight(self):
        return self.AlignRight
    def set_AlignRight(self, AlignRight):
        self.AlignRight = AlignRight
    def add_AlignRight(self, value):
        self.AlignRight.append(value)
    def insert_AlignRight_at(self, index, value):
        self.AlignRight.insert(index, value)
    def replace_AlignRight_at(self, index, value):
        self.AlignRight[index] = value
    def get_AlignTop(self):
        return self.AlignTop
    def set_AlignTop(self, AlignTop):
        self.AlignTop = AlignTop
    def add_AlignTop(self, value):
        self.AlignTop.append(value)
    def insert_AlignTop_at(self, index, value):
        self.AlignTop.insert(index, value)
    def replace_AlignTop_at(self, index, value):
        self.AlignTop[index] = value
    def get_AlignMiddle(self):
        return self.AlignMiddle
    def set_AlignMiddle(self, AlignMiddle):
        self.AlignMiddle = AlignMiddle
    def add_AlignMiddle(self, value):
        self.AlignMiddle.append(value)
    def insert_AlignMiddle_at(self, index, value):
        self.AlignMiddle.insert(index, value)
    def replace_AlignMiddle_at(self, index, value):
        self.AlignMiddle[index] = value
    def get_AlignBottom(self):
        return self.AlignBottom
    def set_AlignBottom(self, AlignBottom):
        self.AlignBottom = AlignBottom
    def add_AlignBottom(self, value):
        self.AlignBottom.append(value)
    def insert_AlignBottom_at(self, index, value):
        self.AlignBottom.insert(index, value)
    def replace_AlignBottom_at(self, index, value):
        self.AlignBottom[index] = value
    def hasContent_(self):
        if (
            self.AlignLeft or
            self.AlignCenter or
            self.AlignRight or
            self.AlignTop or
            self.AlignMiddle or
            self.AlignBottom or
            super(Align_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Align_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Align_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Align_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Align_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Align_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Align_Type'):
        super(Align_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Align_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Align_Type', fromsubclass_=False, pretty_print=True):
        super(Align_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AlignLeft_ in self.AlignLeft:
            namespaceprefix_ = self.AlignLeft_nsprefix_ + ':' if (UseCapturedNS_ and self.AlignLeft_nsprefix_) else ''
            AlignLeft_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AlignLeft', pretty_print=pretty_print)
        for AlignCenter_ in self.AlignCenter:
            namespaceprefix_ = self.AlignCenter_nsprefix_ + ':' if (UseCapturedNS_ and self.AlignCenter_nsprefix_) else ''
            AlignCenter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AlignCenter', pretty_print=pretty_print)
        for AlignRight_ in self.AlignRight:
            namespaceprefix_ = self.AlignRight_nsprefix_ + ':' if (UseCapturedNS_ and self.AlignRight_nsprefix_) else ''
            AlignRight_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AlignRight', pretty_print=pretty_print)
        for AlignTop_ in self.AlignTop:
            namespaceprefix_ = self.AlignTop_nsprefix_ + ':' if (UseCapturedNS_ and self.AlignTop_nsprefix_) else ''
            AlignTop_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AlignTop', pretty_print=pretty_print)
        for AlignMiddle_ in self.AlignMiddle:
            namespaceprefix_ = self.AlignMiddle_nsprefix_ + ':' if (UseCapturedNS_ and self.AlignMiddle_nsprefix_) else ''
            AlignMiddle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AlignMiddle', pretty_print=pretty_print)
        for AlignBottom_ in self.AlignBottom:
            namespaceprefix_ = self.AlignBottom_nsprefix_ + ':' if (UseCapturedNS_ and self.AlignBottom_nsprefix_) else ''
            AlignBottom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AlignBottom', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Align_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AlignLeft':
            obj_ = AlignLeft_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AlignLeft.append(obj_)
            obj_.original_tagname_ = 'AlignLeft'
        elif nodeName_ == 'AlignCenter':
            obj_ = AlignCenter_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AlignCenter.append(obj_)
            obj_.original_tagname_ = 'AlignCenter'
        elif nodeName_ == 'AlignRight':
            obj_ = AlignRight_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AlignRight.append(obj_)
            obj_.original_tagname_ = 'AlignRight'
        elif nodeName_ == 'AlignTop':
            obj_ = AlignTop_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AlignTop.append(obj_)
            obj_.original_tagname_ = 'AlignTop'
        elif nodeName_ == 'AlignMiddle':
            obj_ = AlignMiddle_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AlignMiddle.append(obj_)
            obj_.original_tagname_ = 'AlignMiddle'
        elif nodeName_ == 'AlignBottom':
            obj_ = AlignBottom_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AlignBottom.append(obj_)
            obj_.original_tagname_ = 'AlignBottom'
        super(Align_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Align_Type


class AlignLeft_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AlignLeft_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlignLeft_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlignLeft_Type.subclass:
            return AlignLeft_Type.subclass(*args_, **kwargs_)
        else:
            return AlignLeft_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AlignLeft_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlignLeft_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlignLeft_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AlignLeft_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlignLeft_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlignLeft_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlignLeft_Type'):
        super(AlignLeft_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlignLeft_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlignLeft_Type', fromsubclass_=False, pretty_print=True):
        super(AlignLeft_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AlignLeft_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AlignLeft_Type


class AlignCenter_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AlignCenter_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlignCenter_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlignCenter_Type.subclass:
            return AlignCenter_Type.subclass(*args_, **kwargs_)
        else:
            return AlignCenter_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AlignCenter_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlignCenter_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlignCenter_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AlignCenter_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlignCenter_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlignCenter_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlignCenter_Type'):
        super(AlignCenter_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlignCenter_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlignCenter_Type', fromsubclass_=False, pretty_print=True):
        super(AlignCenter_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AlignCenter_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AlignCenter_Type


class AlignRight_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AlignRight_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlignRight_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlignRight_Type.subclass:
            return AlignRight_Type.subclass(*args_, **kwargs_)
        else:
            return AlignRight_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AlignRight_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlignRight_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlignRight_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AlignRight_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlignRight_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlignRight_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlignRight_Type'):
        super(AlignRight_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlignRight_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlignRight_Type', fromsubclass_=False, pretty_print=True):
        super(AlignRight_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AlignRight_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AlignRight_Type


class AlignTop_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AlignTop_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlignTop_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlignTop_Type.subclass:
            return AlignTop_Type.subclass(*args_, **kwargs_)
        else:
            return AlignTop_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AlignTop_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlignTop_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlignTop_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AlignTop_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlignTop_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlignTop_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlignTop_Type'):
        super(AlignTop_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlignTop_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlignTop_Type', fromsubclass_=False, pretty_print=True):
        super(AlignTop_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AlignTop_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AlignTop_Type


class AlignMiddle_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AlignMiddle_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlignMiddle_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlignMiddle_Type.subclass:
            return AlignMiddle_Type.subclass(*args_, **kwargs_)
        else:
            return AlignMiddle_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AlignMiddle_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlignMiddle_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlignMiddle_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AlignMiddle_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlignMiddle_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlignMiddle_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlignMiddle_Type'):
        super(AlignMiddle_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlignMiddle_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlignMiddle_Type', fromsubclass_=False, pretty_print=True):
        super(AlignMiddle_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AlignMiddle_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AlignMiddle_Type


class AlignBottom_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AlignBottom_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlignBottom_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlignBottom_Type.subclass:
            return AlignBottom_Type.subclass(*args_, **kwargs_)
        else:
            return AlignBottom_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AlignBottom_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlignBottom_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlignBottom_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AlignBottom_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlignBottom_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlignBottom_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlignBottom_Type'):
        super(AlignBottom_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlignBottom_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlignBottom_Type', fromsubclass_=False, pretty_print=True):
        super(AlignBottom_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AlignBottom_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AlignBottom_Type


class Protection_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, LockWidth=None, LockHeight=None, LockMoveX=None, LockMoveY=None, LockAspect=None, LockDelete=None, LockBegin=None, LockEnd=None, LockRotate=None, LockCrop=None, LockVtxEdit=None, LockTextEdit=None, LockFormat=None, LockGroup=None, LockCalcWH=None, LockSelect=None, LockCustProp=None, LockFromGroupFormat=None, LockThemeColors=None, LockThemeEffects=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Protection_Type, self).__init__(Del,  **kwargs_)
        if LockWidth is None:
            self.LockWidth = []
        else:
            self.LockWidth = LockWidth
        self.LockWidth_nsprefix_ = None
        if LockHeight is None:
            self.LockHeight = []
        else:
            self.LockHeight = LockHeight
        self.LockHeight_nsprefix_ = None
        if LockMoveX is None:
            self.LockMoveX = []
        else:
            self.LockMoveX = LockMoveX
        self.LockMoveX_nsprefix_ = None
        if LockMoveY is None:
            self.LockMoveY = []
        else:
            self.LockMoveY = LockMoveY
        self.LockMoveY_nsprefix_ = None
        if LockAspect is None:
            self.LockAspect = []
        else:
            self.LockAspect = LockAspect
        self.LockAspect_nsprefix_ = None
        if LockDelete is None:
            self.LockDelete = []
        else:
            self.LockDelete = LockDelete
        self.LockDelete_nsprefix_ = None
        if LockBegin is None:
            self.LockBegin = []
        else:
            self.LockBegin = LockBegin
        self.LockBegin_nsprefix_ = None
        if LockEnd is None:
            self.LockEnd = []
        else:
            self.LockEnd = LockEnd
        self.LockEnd_nsprefix_ = None
        if LockRotate is None:
            self.LockRotate = []
        else:
            self.LockRotate = LockRotate
        self.LockRotate_nsprefix_ = None
        if LockCrop is None:
            self.LockCrop = []
        else:
            self.LockCrop = LockCrop
        self.LockCrop_nsprefix_ = None
        if LockVtxEdit is None:
            self.LockVtxEdit = []
        else:
            self.LockVtxEdit = LockVtxEdit
        self.LockVtxEdit_nsprefix_ = None
        if LockTextEdit is None:
            self.LockTextEdit = []
        else:
            self.LockTextEdit = LockTextEdit
        self.LockTextEdit_nsprefix_ = None
        if LockFormat is None:
            self.LockFormat = []
        else:
            self.LockFormat = LockFormat
        self.LockFormat_nsprefix_ = None
        if LockGroup is None:
            self.LockGroup = []
        else:
            self.LockGroup = LockGroup
        self.LockGroup_nsprefix_ = None
        if LockCalcWH is None:
            self.LockCalcWH = []
        else:
            self.LockCalcWH = LockCalcWH
        self.LockCalcWH_nsprefix_ = None
        if LockSelect is None:
            self.LockSelect = []
        else:
            self.LockSelect = LockSelect
        self.LockSelect_nsprefix_ = None
        if LockCustProp is None:
            self.LockCustProp = []
        else:
            self.LockCustProp = LockCustProp
        self.LockCustProp_nsprefix_ = None
        if LockFromGroupFormat is None:
            self.LockFromGroupFormat = []
        else:
            self.LockFromGroupFormat = LockFromGroupFormat
        self.LockFromGroupFormat_nsprefix_ = None
        if LockThemeColors is None:
            self.LockThemeColors = []
        else:
            self.LockThemeColors = LockThemeColors
        self.LockThemeColors_nsprefix_ = None
        if LockThemeEffects is None:
            self.LockThemeEffects = []
        else:
            self.LockThemeEffects = LockThemeEffects
        self.LockThemeEffects_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Protection_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Protection_Type.subclass:
            return Protection_Type.subclass(*args_, **kwargs_)
        else:
            return Protection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LockWidth(self):
        return self.LockWidth
    def set_LockWidth(self, LockWidth):
        self.LockWidth = LockWidth
    def add_LockWidth(self, value):
        self.LockWidth.append(value)
    def insert_LockWidth_at(self, index, value):
        self.LockWidth.insert(index, value)
    def replace_LockWidth_at(self, index, value):
        self.LockWidth[index] = value
    def get_LockHeight(self):
        return self.LockHeight
    def set_LockHeight(self, LockHeight):
        self.LockHeight = LockHeight
    def add_LockHeight(self, value):
        self.LockHeight.append(value)
    def insert_LockHeight_at(self, index, value):
        self.LockHeight.insert(index, value)
    def replace_LockHeight_at(self, index, value):
        self.LockHeight[index] = value
    def get_LockMoveX(self):
        return self.LockMoveX
    def set_LockMoveX(self, LockMoveX):
        self.LockMoveX = LockMoveX
    def add_LockMoveX(self, value):
        self.LockMoveX.append(value)
    def insert_LockMoveX_at(self, index, value):
        self.LockMoveX.insert(index, value)
    def replace_LockMoveX_at(self, index, value):
        self.LockMoveX[index] = value
    def get_LockMoveY(self):
        return self.LockMoveY
    def set_LockMoveY(self, LockMoveY):
        self.LockMoveY = LockMoveY
    def add_LockMoveY(self, value):
        self.LockMoveY.append(value)
    def insert_LockMoveY_at(self, index, value):
        self.LockMoveY.insert(index, value)
    def replace_LockMoveY_at(self, index, value):
        self.LockMoveY[index] = value
    def get_LockAspect(self):
        return self.LockAspect
    def set_LockAspect(self, LockAspect):
        self.LockAspect = LockAspect
    def add_LockAspect(self, value):
        self.LockAspect.append(value)
    def insert_LockAspect_at(self, index, value):
        self.LockAspect.insert(index, value)
    def replace_LockAspect_at(self, index, value):
        self.LockAspect[index] = value
    def get_LockDelete(self):
        return self.LockDelete
    def set_LockDelete(self, LockDelete):
        self.LockDelete = LockDelete
    def add_LockDelete(self, value):
        self.LockDelete.append(value)
    def insert_LockDelete_at(self, index, value):
        self.LockDelete.insert(index, value)
    def replace_LockDelete_at(self, index, value):
        self.LockDelete[index] = value
    def get_LockBegin(self):
        return self.LockBegin
    def set_LockBegin(self, LockBegin):
        self.LockBegin = LockBegin
    def add_LockBegin(self, value):
        self.LockBegin.append(value)
    def insert_LockBegin_at(self, index, value):
        self.LockBegin.insert(index, value)
    def replace_LockBegin_at(self, index, value):
        self.LockBegin[index] = value
    def get_LockEnd(self):
        return self.LockEnd
    def set_LockEnd(self, LockEnd):
        self.LockEnd = LockEnd
    def add_LockEnd(self, value):
        self.LockEnd.append(value)
    def insert_LockEnd_at(self, index, value):
        self.LockEnd.insert(index, value)
    def replace_LockEnd_at(self, index, value):
        self.LockEnd[index] = value
    def get_LockRotate(self):
        return self.LockRotate
    def set_LockRotate(self, LockRotate):
        self.LockRotate = LockRotate
    def add_LockRotate(self, value):
        self.LockRotate.append(value)
    def insert_LockRotate_at(self, index, value):
        self.LockRotate.insert(index, value)
    def replace_LockRotate_at(self, index, value):
        self.LockRotate[index] = value
    def get_LockCrop(self):
        return self.LockCrop
    def set_LockCrop(self, LockCrop):
        self.LockCrop = LockCrop
    def add_LockCrop(self, value):
        self.LockCrop.append(value)
    def insert_LockCrop_at(self, index, value):
        self.LockCrop.insert(index, value)
    def replace_LockCrop_at(self, index, value):
        self.LockCrop[index] = value
    def get_LockVtxEdit(self):
        return self.LockVtxEdit
    def set_LockVtxEdit(self, LockVtxEdit):
        self.LockVtxEdit = LockVtxEdit
    def add_LockVtxEdit(self, value):
        self.LockVtxEdit.append(value)
    def insert_LockVtxEdit_at(self, index, value):
        self.LockVtxEdit.insert(index, value)
    def replace_LockVtxEdit_at(self, index, value):
        self.LockVtxEdit[index] = value
    def get_LockTextEdit(self):
        return self.LockTextEdit
    def set_LockTextEdit(self, LockTextEdit):
        self.LockTextEdit = LockTextEdit
    def add_LockTextEdit(self, value):
        self.LockTextEdit.append(value)
    def insert_LockTextEdit_at(self, index, value):
        self.LockTextEdit.insert(index, value)
    def replace_LockTextEdit_at(self, index, value):
        self.LockTextEdit[index] = value
    def get_LockFormat(self):
        return self.LockFormat
    def set_LockFormat(self, LockFormat):
        self.LockFormat = LockFormat
    def add_LockFormat(self, value):
        self.LockFormat.append(value)
    def insert_LockFormat_at(self, index, value):
        self.LockFormat.insert(index, value)
    def replace_LockFormat_at(self, index, value):
        self.LockFormat[index] = value
    def get_LockGroup(self):
        return self.LockGroup
    def set_LockGroup(self, LockGroup):
        self.LockGroup = LockGroup
    def add_LockGroup(self, value):
        self.LockGroup.append(value)
    def insert_LockGroup_at(self, index, value):
        self.LockGroup.insert(index, value)
    def replace_LockGroup_at(self, index, value):
        self.LockGroup[index] = value
    def get_LockCalcWH(self):
        return self.LockCalcWH
    def set_LockCalcWH(self, LockCalcWH):
        self.LockCalcWH = LockCalcWH
    def add_LockCalcWH(self, value):
        self.LockCalcWH.append(value)
    def insert_LockCalcWH_at(self, index, value):
        self.LockCalcWH.insert(index, value)
    def replace_LockCalcWH_at(self, index, value):
        self.LockCalcWH[index] = value
    def get_LockSelect(self):
        return self.LockSelect
    def set_LockSelect(self, LockSelect):
        self.LockSelect = LockSelect
    def add_LockSelect(self, value):
        self.LockSelect.append(value)
    def insert_LockSelect_at(self, index, value):
        self.LockSelect.insert(index, value)
    def replace_LockSelect_at(self, index, value):
        self.LockSelect[index] = value
    def get_LockCustProp(self):
        return self.LockCustProp
    def set_LockCustProp(self, LockCustProp):
        self.LockCustProp = LockCustProp
    def add_LockCustProp(self, value):
        self.LockCustProp.append(value)
    def insert_LockCustProp_at(self, index, value):
        self.LockCustProp.insert(index, value)
    def replace_LockCustProp_at(self, index, value):
        self.LockCustProp[index] = value
    def get_LockFromGroupFormat(self):
        return self.LockFromGroupFormat
    def set_LockFromGroupFormat(self, LockFromGroupFormat):
        self.LockFromGroupFormat = LockFromGroupFormat
    def add_LockFromGroupFormat(self, value):
        self.LockFromGroupFormat.append(value)
    def insert_LockFromGroupFormat_at(self, index, value):
        self.LockFromGroupFormat.insert(index, value)
    def replace_LockFromGroupFormat_at(self, index, value):
        self.LockFromGroupFormat[index] = value
    def get_LockThemeColors(self):
        return self.LockThemeColors
    def set_LockThemeColors(self, LockThemeColors):
        self.LockThemeColors = LockThemeColors
    def add_LockThemeColors(self, value):
        self.LockThemeColors.append(value)
    def insert_LockThemeColors_at(self, index, value):
        self.LockThemeColors.insert(index, value)
    def replace_LockThemeColors_at(self, index, value):
        self.LockThemeColors[index] = value
    def get_LockThemeEffects(self):
        return self.LockThemeEffects
    def set_LockThemeEffects(self, LockThemeEffects):
        self.LockThemeEffects = LockThemeEffects
    def add_LockThemeEffects(self, value):
        self.LockThemeEffects.append(value)
    def insert_LockThemeEffects_at(self, index, value):
        self.LockThemeEffects.insert(index, value)
    def replace_LockThemeEffects_at(self, index, value):
        self.LockThemeEffects[index] = value
    def hasContent_(self):
        if (
            self.LockWidth or
            self.LockHeight or
            self.LockMoveX or
            self.LockMoveY or
            self.LockAspect or
            self.LockDelete or
            self.LockBegin or
            self.LockEnd or
            self.LockRotate or
            self.LockCrop or
            self.LockVtxEdit or
            self.LockTextEdit or
            self.LockFormat or
            self.LockGroup or
            self.LockCalcWH or
            self.LockSelect or
            self.LockCustProp or
            self.LockFromGroupFormat or
            self.LockThemeColors or
            self.LockThemeEffects or
            super(Protection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Protection_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Protection_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Protection_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Protection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Protection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Protection_Type'):
        super(Protection_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Protection_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Protection_Type', fromsubclass_=False, pretty_print=True):
        super(Protection_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LockWidth_ in self.LockWidth:
            namespaceprefix_ = self.LockWidth_nsprefix_ + ':' if (UseCapturedNS_ and self.LockWidth_nsprefix_) else ''
            LockWidth_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockWidth', pretty_print=pretty_print)
        for LockHeight_ in self.LockHeight:
            namespaceprefix_ = self.LockHeight_nsprefix_ + ':' if (UseCapturedNS_ and self.LockHeight_nsprefix_) else ''
            LockHeight_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockHeight', pretty_print=pretty_print)
        for LockMoveX_ in self.LockMoveX:
            namespaceprefix_ = self.LockMoveX_nsprefix_ + ':' if (UseCapturedNS_ and self.LockMoveX_nsprefix_) else ''
            LockMoveX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockMoveX', pretty_print=pretty_print)
        for LockMoveY_ in self.LockMoveY:
            namespaceprefix_ = self.LockMoveY_nsprefix_ + ':' if (UseCapturedNS_ and self.LockMoveY_nsprefix_) else ''
            LockMoveY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockMoveY', pretty_print=pretty_print)
        for LockAspect_ in self.LockAspect:
            namespaceprefix_ = self.LockAspect_nsprefix_ + ':' if (UseCapturedNS_ and self.LockAspect_nsprefix_) else ''
            LockAspect_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockAspect', pretty_print=pretty_print)
        for LockDelete_ in self.LockDelete:
            namespaceprefix_ = self.LockDelete_nsprefix_ + ':' if (UseCapturedNS_ and self.LockDelete_nsprefix_) else ''
            LockDelete_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockDelete', pretty_print=pretty_print)
        for LockBegin_ in self.LockBegin:
            namespaceprefix_ = self.LockBegin_nsprefix_ + ':' if (UseCapturedNS_ and self.LockBegin_nsprefix_) else ''
            LockBegin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockBegin', pretty_print=pretty_print)
        for LockEnd_ in self.LockEnd:
            namespaceprefix_ = self.LockEnd_nsprefix_ + ':' if (UseCapturedNS_ and self.LockEnd_nsprefix_) else ''
            LockEnd_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockEnd', pretty_print=pretty_print)
        for LockRotate_ in self.LockRotate:
            namespaceprefix_ = self.LockRotate_nsprefix_ + ':' if (UseCapturedNS_ and self.LockRotate_nsprefix_) else ''
            LockRotate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockRotate', pretty_print=pretty_print)
        for LockCrop_ in self.LockCrop:
            namespaceprefix_ = self.LockCrop_nsprefix_ + ':' if (UseCapturedNS_ and self.LockCrop_nsprefix_) else ''
            LockCrop_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockCrop', pretty_print=pretty_print)
        for LockVtxEdit_ in self.LockVtxEdit:
            namespaceprefix_ = self.LockVtxEdit_nsprefix_ + ':' if (UseCapturedNS_ and self.LockVtxEdit_nsprefix_) else ''
            LockVtxEdit_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockVtxEdit', pretty_print=pretty_print)
        for LockTextEdit_ in self.LockTextEdit:
            namespaceprefix_ = self.LockTextEdit_nsprefix_ + ':' if (UseCapturedNS_ and self.LockTextEdit_nsprefix_) else ''
            LockTextEdit_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockTextEdit', pretty_print=pretty_print)
        for LockFormat_ in self.LockFormat:
            namespaceprefix_ = self.LockFormat_nsprefix_ + ':' if (UseCapturedNS_ and self.LockFormat_nsprefix_) else ''
            LockFormat_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockFormat', pretty_print=pretty_print)
        for LockGroup_ in self.LockGroup:
            namespaceprefix_ = self.LockGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.LockGroup_nsprefix_) else ''
            LockGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockGroup', pretty_print=pretty_print)
        for LockCalcWH_ in self.LockCalcWH:
            namespaceprefix_ = self.LockCalcWH_nsprefix_ + ':' if (UseCapturedNS_ and self.LockCalcWH_nsprefix_) else ''
            LockCalcWH_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockCalcWH', pretty_print=pretty_print)
        for LockSelect_ in self.LockSelect:
            namespaceprefix_ = self.LockSelect_nsprefix_ + ':' if (UseCapturedNS_ and self.LockSelect_nsprefix_) else ''
            LockSelect_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockSelect', pretty_print=pretty_print)
        for LockCustProp_ in self.LockCustProp:
            namespaceprefix_ = self.LockCustProp_nsprefix_ + ':' if (UseCapturedNS_ and self.LockCustProp_nsprefix_) else ''
            LockCustProp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockCustProp', pretty_print=pretty_print)
        for LockFromGroupFormat_ in self.LockFromGroupFormat:
            namespaceprefix_ = self.LockFromGroupFormat_nsprefix_ + ':' if (UseCapturedNS_ and self.LockFromGroupFormat_nsprefix_) else ''
            LockFromGroupFormat_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockFromGroupFormat', pretty_print=pretty_print)
        for LockThemeColors_ in self.LockThemeColors:
            namespaceprefix_ = self.LockThemeColors_nsprefix_ + ':' if (UseCapturedNS_ and self.LockThemeColors_nsprefix_) else ''
            LockThemeColors_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockThemeColors', pretty_print=pretty_print)
        for LockThemeEffects_ in self.LockThemeEffects:
            namespaceprefix_ = self.LockThemeEffects_nsprefix_ + ':' if (UseCapturedNS_ and self.LockThemeEffects_nsprefix_) else ''
            LockThemeEffects_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockThemeEffects', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Protection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LockWidth':
            obj_ = LockWidth_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockWidth.append(obj_)
            obj_.original_tagname_ = 'LockWidth'
        elif nodeName_ == 'LockHeight':
            obj_ = LockHeight_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockHeight.append(obj_)
            obj_.original_tagname_ = 'LockHeight'
        elif nodeName_ == 'LockMoveX':
            obj_ = LockMoveX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockMoveX.append(obj_)
            obj_.original_tagname_ = 'LockMoveX'
        elif nodeName_ == 'LockMoveY':
            obj_ = LockMoveY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockMoveY.append(obj_)
            obj_.original_tagname_ = 'LockMoveY'
        elif nodeName_ == 'LockAspect':
            obj_ = LockAspect_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockAspect.append(obj_)
            obj_.original_tagname_ = 'LockAspect'
        elif nodeName_ == 'LockDelete':
            obj_ = LockDelete_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockDelete.append(obj_)
            obj_.original_tagname_ = 'LockDelete'
        elif nodeName_ == 'LockBegin':
            obj_ = LockBegin_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockBegin.append(obj_)
            obj_.original_tagname_ = 'LockBegin'
        elif nodeName_ == 'LockEnd':
            obj_ = LockEnd_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockEnd.append(obj_)
            obj_.original_tagname_ = 'LockEnd'
        elif nodeName_ == 'LockRotate':
            obj_ = LockRotate_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockRotate.append(obj_)
            obj_.original_tagname_ = 'LockRotate'
        elif nodeName_ == 'LockCrop':
            obj_ = LockCrop_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockCrop.append(obj_)
            obj_.original_tagname_ = 'LockCrop'
        elif nodeName_ == 'LockVtxEdit':
            obj_ = LockVtxEdit_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockVtxEdit.append(obj_)
            obj_.original_tagname_ = 'LockVtxEdit'
        elif nodeName_ == 'LockTextEdit':
            obj_ = LockTextEdit_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockTextEdit.append(obj_)
            obj_.original_tagname_ = 'LockTextEdit'
        elif nodeName_ == 'LockFormat':
            obj_ = LockFormat_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockFormat.append(obj_)
            obj_.original_tagname_ = 'LockFormat'
        elif nodeName_ == 'LockGroup':
            obj_ = LockGroup_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockGroup.append(obj_)
            obj_.original_tagname_ = 'LockGroup'
        elif nodeName_ == 'LockCalcWH':
            obj_ = LockCalcWH_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockCalcWH.append(obj_)
            obj_.original_tagname_ = 'LockCalcWH'
        elif nodeName_ == 'LockSelect':
            obj_ = LockSelect_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockSelect.append(obj_)
            obj_.original_tagname_ = 'LockSelect'
        elif nodeName_ == 'LockCustProp':
            obj_ = LockCustProp_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockCustProp.append(obj_)
            obj_.original_tagname_ = 'LockCustProp'
        elif nodeName_ == 'LockFromGroupFormat':
            obj_ = LockFromGroupFormat_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockFromGroupFormat.append(obj_)
            obj_.original_tagname_ = 'LockFromGroupFormat'
        elif nodeName_ == 'LockThemeColors':
            obj_ = LockThemeColors_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockThemeColors.append(obj_)
            obj_.original_tagname_ = 'LockThemeColors'
        elif nodeName_ == 'LockThemeEffects':
            obj_ = LockThemeEffects_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockThemeEffects.append(obj_)
            obj_.original_tagname_ = 'LockThemeEffects'
        super(Protection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Protection_Type


class LockWidth_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockWidth_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockWidth_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockWidth_Type.subclass:
            return LockWidth_Type.subclass(*args_, **kwargs_)
        else:
            return LockWidth_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockWidth_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockWidth_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockWidth_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockWidth_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockWidth_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockWidth_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockWidth_Type'):
        super(LockWidth_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockWidth_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockWidth_Type', fromsubclass_=False, pretty_print=True):
        super(LockWidth_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockWidth_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockWidth_Type


class LockHeight_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockHeight_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockHeight_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockHeight_Type.subclass:
            return LockHeight_Type.subclass(*args_, **kwargs_)
        else:
            return LockHeight_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockHeight_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockHeight_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockHeight_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockHeight_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockHeight_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockHeight_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockHeight_Type'):
        super(LockHeight_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockHeight_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockHeight_Type', fromsubclass_=False, pretty_print=True):
        super(LockHeight_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockHeight_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockHeight_Type


class LockMoveX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockMoveX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockMoveX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockMoveX_Type.subclass:
            return LockMoveX_Type.subclass(*args_, **kwargs_)
        else:
            return LockMoveX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockMoveX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockMoveX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockMoveX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockMoveX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockMoveX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockMoveX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockMoveX_Type'):
        super(LockMoveX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockMoveX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockMoveX_Type', fromsubclass_=False, pretty_print=True):
        super(LockMoveX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockMoveX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockMoveX_Type


class LockMoveY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockMoveY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockMoveY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockMoveY_Type.subclass:
            return LockMoveY_Type.subclass(*args_, **kwargs_)
        else:
            return LockMoveY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockMoveY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockMoveY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockMoveY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockMoveY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockMoveY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockMoveY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockMoveY_Type'):
        super(LockMoveY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockMoveY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockMoveY_Type', fromsubclass_=False, pretty_print=True):
        super(LockMoveY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockMoveY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockMoveY_Type


class LockAspect_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockAspect_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockAspect_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockAspect_Type.subclass:
            return LockAspect_Type.subclass(*args_, **kwargs_)
        else:
            return LockAspect_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockAspect_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockAspect_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockAspect_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockAspect_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockAspect_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockAspect_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockAspect_Type'):
        super(LockAspect_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockAspect_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockAspect_Type', fromsubclass_=False, pretty_print=True):
        super(LockAspect_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockAspect_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockAspect_Type


class LockDelete_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockDelete_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockDelete_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockDelete_Type.subclass:
            return LockDelete_Type.subclass(*args_, **kwargs_)
        else:
            return LockDelete_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockDelete_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockDelete_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockDelete_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockDelete_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockDelete_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockDelete_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockDelete_Type'):
        super(LockDelete_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockDelete_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockDelete_Type', fromsubclass_=False, pretty_print=True):
        super(LockDelete_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockDelete_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockDelete_Type


class LockBegin_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockBegin_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockBegin_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockBegin_Type.subclass:
            return LockBegin_Type.subclass(*args_, **kwargs_)
        else:
            return LockBegin_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockBegin_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockBegin_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockBegin_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockBegin_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockBegin_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockBegin_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockBegin_Type'):
        super(LockBegin_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockBegin_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockBegin_Type', fromsubclass_=False, pretty_print=True):
        super(LockBegin_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockBegin_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockBegin_Type


class LockEnd_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockEnd_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockEnd_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockEnd_Type.subclass:
            return LockEnd_Type.subclass(*args_, **kwargs_)
        else:
            return LockEnd_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockEnd_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockEnd_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockEnd_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockEnd_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockEnd_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockEnd_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockEnd_Type'):
        super(LockEnd_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockEnd_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockEnd_Type', fromsubclass_=False, pretty_print=True):
        super(LockEnd_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockEnd_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockEnd_Type


class LockRotate_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockRotate_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockRotate_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockRotate_Type.subclass:
            return LockRotate_Type.subclass(*args_, **kwargs_)
        else:
            return LockRotate_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockRotate_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockRotate_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockRotate_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockRotate_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockRotate_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockRotate_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockRotate_Type'):
        super(LockRotate_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockRotate_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockRotate_Type', fromsubclass_=False, pretty_print=True):
        super(LockRotate_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockRotate_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockRotate_Type


class LockCrop_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockCrop_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockCrop_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockCrop_Type.subclass:
            return LockCrop_Type.subclass(*args_, **kwargs_)
        else:
            return LockCrop_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockCrop_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockCrop_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockCrop_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockCrop_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockCrop_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockCrop_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockCrop_Type'):
        super(LockCrop_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockCrop_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockCrop_Type', fromsubclass_=False, pretty_print=True):
        super(LockCrop_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockCrop_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockCrop_Type


class LockVtxEdit_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockVtxEdit_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockVtxEdit_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockVtxEdit_Type.subclass:
            return LockVtxEdit_Type.subclass(*args_, **kwargs_)
        else:
            return LockVtxEdit_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockVtxEdit_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockVtxEdit_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockVtxEdit_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockVtxEdit_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockVtxEdit_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockVtxEdit_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockVtxEdit_Type'):
        super(LockVtxEdit_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockVtxEdit_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockVtxEdit_Type', fromsubclass_=False, pretty_print=True):
        super(LockVtxEdit_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockVtxEdit_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockVtxEdit_Type


class LockTextEdit_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockTextEdit_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockTextEdit_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockTextEdit_Type.subclass:
            return LockTextEdit_Type.subclass(*args_, **kwargs_)
        else:
            return LockTextEdit_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockTextEdit_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockTextEdit_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockTextEdit_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockTextEdit_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockTextEdit_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockTextEdit_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockTextEdit_Type'):
        super(LockTextEdit_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockTextEdit_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockTextEdit_Type', fromsubclass_=False, pretty_print=True):
        super(LockTextEdit_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockTextEdit_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockTextEdit_Type


class LockFormat_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockFormat_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockFormat_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockFormat_Type.subclass:
            return LockFormat_Type.subclass(*args_, **kwargs_)
        else:
            return LockFormat_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockFormat_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockFormat_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockFormat_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockFormat_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockFormat_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockFormat_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockFormat_Type'):
        super(LockFormat_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockFormat_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockFormat_Type', fromsubclass_=False, pretty_print=True):
        super(LockFormat_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockFormat_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockFormat_Type


class LockGroup_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockGroup_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockGroup_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockGroup_Type.subclass:
            return LockGroup_Type.subclass(*args_, **kwargs_)
        else:
            return LockGroup_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockGroup_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockGroup_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockGroup_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockGroup_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockGroup_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockGroup_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockGroup_Type'):
        super(LockGroup_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockGroup_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockGroup_Type', fromsubclass_=False, pretty_print=True):
        super(LockGroup_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockGroup_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockGroup_Type


class LockCalcWH_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockCalcWH_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockCalcWH_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockCalcWH_Type.subclass:
            return LockCalcWH_Type.subclass(*args_, **kwargs_)
        else:
            return LockCalcWH_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockCalcWH_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockCalcWH_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockCalcWH_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockCalcWH_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockCalcWH_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockCalcWH_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockCalcWH_Type'):
        super(LockCalcWH_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockCalcWH_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockCalcWH_Type', fromsubclass_=False, pretty_print=True):
        super(LockCalcWH_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockCalcWH_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockCalcWH_Type


class LockSelect_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockSelect_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockSelect_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockSelect_Type.subclass:
            return LockSelect_Type.subclass(*args_, **kwargs_)
        else:
            return LockSelect_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockSelect_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockSelect_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockSelect_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockSelect_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockSelect_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockSelect_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockSelect_Type'):
        super(LockSelect_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockSelect_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockSelect_Type', fromsubclass_=False, pretty_print=True):
        super(LockSelect_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockSelect_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockSelect_Type


class LockCustProp_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockCustProp_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockCustProp_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockCustProp_Type.subclass:
            return LockCustProp_Type.subclass(*args_, **kwargs_)
        else:
            return LockCustProp_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockCustProp_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockCustProp_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockCustProp_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockCustProp_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockCustProp_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockCustProp_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockCustProp_Type'):
        super(LockCustProp_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockCustProp_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockCustProp_Type', fromsubclass_=False, pretty_print=True):
        super(LockCustProp_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockCustProp_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockCustProp_Type


class LockFromGroupFormat_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockFromGroupFormat_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockFromGroupFormat_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockFromGroupFormat_Type.subclass:
            return LockFromGroupFormat_Type.subclass(*args_, **kwargs_)
        else:
            return LockFromGroupFormat_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockFromGroupFormat_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockFromGroupFormat_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockFromGroupFormat_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockFromGroupFormat_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockFromGroupFormat_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockFromGroupFormat_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockFromGroupFormat_Type'):
        super(LockFromGroupFormat_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockFromGroupFormat_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockFromGroupFormat_Type', fromsubclass_=False, pretty_print=True):
        super(LockFromGroupFormat_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockFromGroupFormat_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockFromGroupFormat_Type


class LockThemeColors_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockThemeColors_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockThemeColors_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockThemeColors_Type.subclass:
            return LockThemeColors_Type.subclass(*args_, **kwargs_)
        else:
            return LockThemeColors_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockThemeColors_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockThemeColors_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockThemeColors_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockThemeColors_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockThemeColors_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockThemeColors_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockThemeColors_Type'):
        super(LockThemeColors_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockThemeColors_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockThemeColors_Type', fromsubclass_=False, pretty_print=True):
        super(LockThemeColors_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockThemeColors_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockThemeColors_Type


class LockThemeEffects_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockThemeEffects_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockThemeEffects_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockThemeEffects_Type.subclass:
            return LockThemeEffects_Type.subclass(*args_, **kwargs_)
        else:
            return LockThemeEffects_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockThemeEffects_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockThemeEffects_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockThemeEffects_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockThemeEffects_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockThemeEffects_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockThemeEffects_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockThemeEffects_Type'):
        super(LockThemeEffects_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockThemeEffects_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockThemeEffects_Type', fromsubclass_=False, pretty_print=True):
        super(LockThemeEffects_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockThemeEffects_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockThemeEffects_Type


class Help_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, HelpTopic=None, Copyright=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Help_Type, self).__init__(Del,  **kwargs_)
        if HelpTopic is None:
            self.HelpTopic = []
        else:
            self.HelpTopic = HelpTopic
        self.HelpTopic_nsprefix_ = None
        if Copyright is None:
            self.Copyright = []
        else:
            self.Copyright = Copyright
        self.Copyright_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Help_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Help_Type.subclass:
            return Help_Type.subclass(*args_, **kwargs_)
        else:
            return Help_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HelpTopic(self):
        return self.HelpTopic
    def set_HelpTopic(self, HelpTopic):
        self.HelpTopic = HelpTopic
    def add_HelpTopic(self, value):
        self.HelpTopic.append(value)
    def insert_HelpTopic_at(self, index, value):
        self.HelpTopic.insert(index, value)
    def replace_HelpTopic_at(self, index, value):
        self.HelpTopic[index] = value
    def get_Copyright(self):
        return self.Copyright
    def set_Copyright(self, Copyright):
        self.Copyright = Copyright
    def add_Copyright(self, value):
        self.Copyright.append(value)
    def insert_Copyright_at(self, index, value):
        self.Copyright.insert(index, value)
    def replace_Copyright_at(self, index, value):
        self.Copyright[index] = value
    def hasContent_(self):
        if (
            self.HelpTopic or
            self.Copyright or
            super(Help_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Help_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Help_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Help_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Help_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Help_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Help_Type'):
        super(Help_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Help_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Help_Type', fromsubclass_=False, pretty_print=True):
        super(Help_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HelpTopic_ in self.HelpTopic:
            namespaceprefix_ = self.HelpTopic_nsprefix_ + ':' if (UseCapturedNS_ and self.HelpTopic_nsprefix_) else ''
            HelpTopic_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HelpTopic', pretty_print=pretty_print)
        for Copyright_ in self.Copyright:
            namespaceprefix_ = self.Copyright_nsprefix_ + ':' if (UseCapturedNS_ and self.Copyright_nsprefix_) else ''
            Copyright_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Copyright', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Help_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HelpTopic':
            obj_ = HelpTopic_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HelpTopic.append(obj_)
            obj_.original_tagname_ = 'HelpTopic'
        elif nodeName_ == 'Copyright':
            obj_ = Copyright_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Copyright.append(obj_)
            obj_.original_tagname_ = 'Copyright'
        super(Help_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Help_Type


class HelpTopic_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(HelpTopic_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HelpTopic_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HelpTopic_Type.subclass:
            return HelpTopic_Type.subclass(*args_, **kwargs_)
        else:
            return HelpTopic_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(HelpTopic_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HelpTopic_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HelpTopic_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HelpTopic_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HelpTopic_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HelpTopic_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HelpTopic_Type'):
        super(HelpTopic_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HelpTopic_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HelpTopic_Type', fromsubclass_=False, pretty_print=True):
        super(HelpTopic_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HelpTopic_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class HelpTopic_Type


class Copyright_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Copyright_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Copyright_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Copyright_Type.subclass:
            return Copyright_Type.subclass(*args_, **kwargs_)
        else:
            return Copyright_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Copyright_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Copyright_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Copyright_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Copyright_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Copyright_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Copyright_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Copyright_Type'):
        super(Copyright_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Copyright_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Copyright_Type', fromsubclass_=False, pretty_print=True):
        super(Copyright_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Copyright_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Copyright_Type


class B_Type(ExtendableCell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ExtendableCell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, SolutionXML=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(B_Type, self).__init__(Unit, F, Err, V, SolutionXML, valueOf_, mixedclass_, content_,  **kwargs_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, B_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if B_Type.subclass:
            return B_Type.subclass(*args_, **kwargs_)
        else:
            return B_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(B_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='B_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('B_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'B_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='B_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='B_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='B_Type'):
        super(B_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='B_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='B_Type', fromsubclass_=False, pretty_print=True):
        super(B_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(B_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(B_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class B_Type


class Misc_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, NoObjHandles=None, NonPrinting=None, NoCtlHandles=None, NoAlignBox=None, UpdateAlignBox=None, HideText=None, DynFeedback=None, GlueType=None, WalkPreference=None, BegTrigger=None, EndTrigger=None, ObjType=None, Comment=None, IsDropSource=None, NoLiveDynamics=None, LocalizeMerge=None, Calendar=None, LangID=None, ShapeKeywords=None, DropOnPageScale=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Misc_Type, self).__init__(Del,  **kwargs_)
        if NoObjHandles is None:
            self.NoObjHandles = []
        else:
            self.NoObjHandles = NoObjHandles
        self.NoObjHandles_nsprefix_ = None
        if NonPrinting is None:
            self.NonPrinting = []
        else:
            self.NonPrinting = NonPrinting
        self.NonPrinting_nsprefix_ = None
        if NoCtlHandles is None:
            self.NoCtlHandles = []
        else:
            self.NoCtlHandles = NoCtlHandles
        self.NoCtlHandles_nsprefix_ = None
        if NoAlignBox is None:
            self.NoAlignBox = []
        else:
            self.NoAlignBox = NoAlignBox
        self.NoAlignBox_nsprefix_ = None
        if UpdateAlignBox is None:
            self.UpdateAlignBox = []
        else:
            self.UpdateAlignBox = UpdateAlignBox
        self.UpdateAlignBox_nsprefix_ = None
        if HideText is None:
            self.HideText = []
        else:
            self.HideText = HideText
        self.HideText_nsprefix_ = None
        if DynFeedback is None:
            self.DynFeedback = []
        else:
            self.DynFeedback = DynFeedback
        self.DynFeedback_nsprefix_ = None
        if GlueType is None:
            self.GlueType = []
        else:
            self.GlueType = GlueType
        self.GlueType_nsprefix_ = None
        if WalkPreference is None:
            self.WalkPreference = []
        else:
            self.WalkPreference = WalkPreference
        self.WalkPreference_nsprefix_ = None
        if BegTrigger is None:
            self.BegTrigger = []
        else:
            self.BegTrigger = BegTrigger
        self.BegTrigger_nsprefix_ = None
        if EndTrigger is None:
            self.EndTrigger = []
        else:
            self.EndTrigger = EndTrigger
        self.EndTrigger_nsprefix_ = None
        if ObjType is None:
            self.ObjType = []
        else:
            self.ObjType = ObjType
        self.ObjType_nsprefix_ = None
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Comment_nsprefix_ = None
        if IsDropSource is None:
            self.IsDropSource = []
        else:
            self.IsDropSource = IsDropSource
        self.IsDropSource_nsprefix_ = None
        if NoLiveDynamics is None:
            self.NoLiveDynamics = []
        else:
            self.NoLiveDynamics = NoLiveDynamics
        self.NoLiveDynamics_nsprefix_ = None
        if LocalizeMerge is None:
            self.LocalizeMerge = []
        else:
            self.LocalizeMerge = LocalizeMerge
        self.LocalizeMerge_nsprefix_ = None
        if Calendar is None:
            self.Calendar = []
        else:
            self.Calendar = Calendar
        self.Calendar_nsprefix_ = None
        if LangID is None:
            self.LangID = []
        else:
            self.LangID = LangID
        self.LangID_nsprefix_ = None
        if ShapeKeywords is None:
            self.ShapeKeywords = []
        else:
            self.ShapeKeywords = ShapeKeywords
        self.ShapeKeywords_nsprefix_ = None
        if DropOnPageScale is None:
            self.DropOnPageScale = []
        else:
            self.DropOnPageScale = DropOnPageScale
        self.DropOnPageScale_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Misc_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Misc_Type.subclass:
            return Misc_Type.subclass(*args_, **kwargs_)
        else:
            return Misc_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NoObjHandles(self):
        return self.NoObjHandles
    def set_NoObjHandles(self, NoObjHandles):
        self.NoObjHandles = NoObjHandles
    def add_NoObjHandles(self, value):
        self.NoObjHandles.append(value)
    def insert_NoObjHandles_at(self, index, value):
        self.NoObjHandles.insert(index, value)
    def replace_NoObjHandles_at(self, index, value):
        self.NoObjHandles[index] = value
    def get_NonPrinting(self):
        return self.NonPrinting
    def set_NonPrinting(self, NonPrinting):
        self.NonPrinting = NonPrinting
    def add_NonPrinting(self, value):
        self.NonPrinting.append(value)
    def insert_NonPrinting_at(self, index, value):
        self.NonPrinting.insert(index, value)
    def replace_NonPrinting_at(self, index, value):
        self.NonPrinting[index] = value
    def get_NoCtlHandles(self):
        return self.NoCtlHandles
    def set_NoCtlHandles(self, NoCtlHandles):
        self.NoCtlHandles = NoCtlHandles
    def add_NoCtlHandles(self, value):
        self.NoCtlHandles.append(value)
    def insert_NoCtlHandles_at(self, index, value):
        self.NoCtlHandles.insert(index, value)
    def replace_NoCtlHandles_at(self, index, value):
        self.NoCtlHandles[index] = value
    def get_NoAlignBox(self):
        return self.NoAlignBox
    def set_NoAlignBox(self, NoAlignBox):
        self.NoAlignBox = NoAlignBox
    def add_NoAlignBox(self, value):
        self.NoAlignBox.append(value)
    def insert_NoAlignBox_at(self, index, value):
        self.NoAlignBox.insert(index, value)
    def replace_NoAlignBox_at(self, index, value):
        self.NoAlignBox[index] = value
    def get_UpdateAlignBox(self):
        return self.UpdateAlignBox
    def set_UpdateAlignBox(self, UpdateAlignBox):
        self.UpdateAlignBox = UpdateAlignBox
    def add_UpdateAlignBox(self, value):
        self.UpdateAlignBox.append(value)
    def insert_UpdateAlignBox_at(self, index, value):
        self.UpdateAlignBox.insert(index, value)
    def replace_UpdateAlignBox_at(self, index, value):
        self.UpdateAlignBox[index] = value
    def get_HideText(self):
        return self.HideText
    def set_HideText(self, HideText):
        self.HideText = HideText
    def add_HideText(self, value):
        self.HideText.append(value)
    def insert_HideText_at(self, index, value):
        self.HideText.insert(index, value)
    def replace_HideText_at(self, index, value):
        self.HideText[index] = value
    def get_DynFeedback(self):
        return self.DynFeedback
    def set_DynFeedback(self, DynFeedback):
        self.DynFeedback = DynFeedback
    def add_DynFeedback(self, value):
        self.DynFeedback.append(value)
    def insert_DynFeedback_at(self, index, value):
        self.DynFeedback.insert(index, value)
    def replace_DynFeedback_at(self, index, value):
        self.DynFeedback[index] = value
    def get_GlueType(self):
        return self.GlueType
    def set_GlueType(self, GlueType):
        self.GlueType = GlueType
    def add_GlueType(self, value):
        self.GlueType.append(value)
    def insert_GlueType_at(self, index, value):
        self.GlueType.insert(index, value)
    def replace_GlueType_at(self, index, value):
        self.GlueType[index] = value
    def get_WalkPreference(self):
        return self.WalkPreference
    def set_WalkPreference(self, WalkPreference):
        self.WalkPreference = WalkPreference
    def add_WalkPreference(self, value):
        self.WalkPreference.append(value)
    def insert_WalkPreference_at(self, index, value):
        self.WalkPreference.insert(index, value)
    def replace_WalkPreference_at(self, index, value):
        self.WalkPreference[index] = value
    def get_BegTrigger(self):
        return self.BegTrigger
    def set_BegTrigger(self, BegTrigger):
        self.BegTrigger = BegTrigger
    def add_BegTrigger(self, value):
        self.BegTrigger.append(value)
    def insert_BegTrigger_at(self, index, value):
        self.BegTrigger.insert(index, value)
    def replace_BegTrigger_at(self, index, value):
        self.BegTrigger[index] = value
    def get_EndTrigger(self):
        return self.EndTrigger
    def set_EndTrigger(self, EndTrigger):
        self.EndTrigger = EndTrigger
    def add_EndTrigger(self, value):
        self.EndTrigger.append(value)
    def insert_EndTrigger_at(self, index, value):
        self.EndTrigger.insert(index, value)
    def replace_EndTrigger_at(self, index, value):
        self.EndTrigger[index] = value
    def get_ObjType(self):
        return self.ObjType
    def set_ObjType(self, ObjType):
        self.ObjType = ObjType
    def add_ObjType(self, value):
        self.ObjType.append(value)
    def insert_ObjType_at(self, index, value):
        self.ObjType.insert(index, value)
    def replace_ObjType_at(self, index, value):
        self.ObjType[index] = value
    def get_Comment(self):
        return self.Comment
    def set_Comment(self, Comment):
        self.Comment = Comment
    def add_Comment(self, value):
        self.Comment.append(value)
    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value):
        self.Comment[index] = value
    def get_IsDropSource(self):
        return self.IsDropSource
    def set_IsDropSource(self, IsDropSource):
        self.IsDropSource = IsDropSource
    def add_IsDropSource(self, value):
        self.IsDropSource.append(value)
    def insert_IsDropSource_at(self, index, value):
        self.IsDropSource.insert(index, value)
    def replace_IsDropSource_at(self, index, value):
        self.IsDropSource[index] = value
    def get_NoLiveDynamics(self):
        return self.NoLiveDynamics
    def set_NoLiveDynamics(self, NoLiveDynamics):
        self.NoLiveDynamics = NoLiveDynamics
    def add_NoLiveDynamics(self, value):
        self.NoLiveDynamics.append(value)
    def insert_NoLiveDynamics_at(self, index, value):
        self.NoLiveDynamics.insert(index, value)
    def replace_NoLiveDynamics_at(self, index, value):
        self.NoLiveDynamics[index] = value
    def get_LocalizeMerge(self):
        return self.LocalizeMerge
    def set_LocalizeMerge(self, LocalizeMerge):
        self.LocalizeMerge = LocalizeMerge
    def add_LocalizeMerge(self, value):
        self.LocalizeMerge.append(value)
    def insert_LocalizeMerge_at(self, index, value):
        self.LocalizeMerge.insert(index, value)
    def replace_LocalizeMerge_at(self, index, value):
        self.LocalizeMerge[index] = value
    def get_Calendar(self):
        return self.Calendar
    def set_Calendar(self, Calendar):
        self.Calendar = Calendar
    def add_Calendar(self, value):
        self.Calendar.append(value)
    def insert_Calendar_at(self, index, value):
        self.Calendar.insert(index, value)
    def replace_Calendar_at(self, index, value):
        self.Calendar[index] = value
    def get_LangID(self):
        return self.LangID
    def set_LangID(self, LangID):
        self.LangID = LangID
    def add_LangID(self, value):
        self.LangID.append(value)
    def insert_LangID_at(self, index, value):
        self.LangID.insert(index, value)
    def replace_LangID_at(self, index, value):
        self.LangID[index] = value
    def get_ShapeKeywords(self):
        return self.ShapeKeywords
    def set_ShapeKeywords(self, ShapeKeywords):
        self.ShapeKeywords = ShapeKeywords
    def add_ShapeKeywords(self, value):
        self.ShapeKeywords.append(value)
    def insert_ShapeKeywords_at(self, index, value):
        self.ShapeKeywords.insert(index, value)
    def replace_ShapeKeywords_at(self, index, value):
        self.ShapeKeywords[index] = value
    def get_DropOnPageScale(self):
        return self.DropOnPageScale
    def set_DropOnPageScale(self, DropOnPageScale):
        self.DropOnPageScale = DropOnPageScale
    def add_DropOnPageScale(self, value):
        self.DropOnPageScale.append(value)
    def insert_DropOnPageScale_at(self, index, value):
        self.DropOnPageScale.insert(index, value)
    def replace_DropOnPageScale_at(self, index, value):
        self.DropOnPageScale[index] = value
    def hasContent_(self):
        if (
            self.NoObjHandles or
            self.NonPrinting or
            self.NoCtlHandles or
            self.NoAlignBox or
            self.UpdateAlignBox or
            self.HideText or
            self.DynFeedback or
            self.GlueType or
            self.WalkPreference or
            self.BegTrigger or
            self.EndTrigger or
            self.ObjType or
            self.Comment or
            self.IsDropSource or
            self.NoLiveDynamics or
            self.LocalizeMerge or
            self.Calendar or
            self.LangID or
            self.ShapeKeywords or
            self.DropOnPageScale or
            super(Misc_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Misc_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Misc_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Misc_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Misc_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Misc_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Misc_Type'):
        super(Misc_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Misc_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Misc_Type', fromsubclass_=False, pretty_print=True):
        super(Misc_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NoObjHandles_ in self.NoObjHandles:
            namespaceprefix_ = self.NoObjHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.NoObjHandles_nsprefix_) else ''
            NoObjHandles_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NoObjHandles', pretty_print=pretty_print)
        for NonPrinting_ in self.NonPrinting:
            namespaceprefix_ = self.NonPrinting_nsprefix_ + ':' if (UseCapturedNS_ and self.NonPrinting_nsprefix_) else ''
            NonPrinting_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NonPrinting', pretty_print=pretty_print)
        for NoCtlHandles_ in self.NoCtlHandles:
            namespaceprefix_ = self.NoCtlHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.NoCtlHandles_nsprefix_) else ''
            NoCtlHandles_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NoCtlHandles', pretty_print=pretty_print)
        for NoAlignBox_ in self.NoAlignBox:
            namespaceprefix_ = self.NoAlignBox_nsprefix_ + ':' if (UseCapturedNS_ and self.NoAlignBox_nsprefix_) else ''
            NoAlignBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NoAlignBox', pretty_print=pretty_print)
        for UpdateAlignBox_ in self.UpdateAlignBox:
            namespaceprefix_ = self.UpdateAlignBox_nsprefix_ + ':' if (UseCapturedNS_ and self.UpdateAlignBox_nsprefix_) else ''
            UpdateAlignBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UpdateAlignBox', pretty_print=pretty_print)
        for HideText_ in self.HideText:
            namespaceprefix_ = self.HideText_nsprefix_ + ':' if (UseCapturedNS_ and self.HideText_nsprefix_) else ''
            HideText_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HideText', pretty_print=pretty_print)
        for DynFeedback_ in self.DynFeedback:
            namespaceprefix_ = self.DynFeedback_nsprefix_ + ':' if (UseCapturedNS_ and self.DynFeedback_nsprefix_) else ''
            DynFeedback_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DynFeedback', pretty_print=pretty_print)
        for GlueType_ in self.GlueType:
            namespaceprefix_ = self.GlueType_nsprefix_ + ':' if (UseCapturedNS_ and self.GlueType_nsprefix_) else ''
            GlueType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GlueType', pretty_print=pretty_print)
        for WalkPreference_ in self.WalkPreference:
            namespaceprefix_ = self.WalkPreference_nsprefix_ + ':' if (UseCapturedNS_ and self.WalkPreference_nsprefix_) else ''
            WalkPreference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='WalkPreference', pretty_print=pretty_print)
        for BegTrigger_ in self.BegTrigger:
            namespaceprefix_ = self.BegTrigger_nsprefix_ + ':' if (UseCapturedNS_ and self.BegTrigger_nsprefix_) else ''
            BegTrigger_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BegTrigger', pretty_print=pretty_print)
        for EndTrigger_ in self.EndTrigger:
            namespaceprefix_ = self.EndTrigger_nsprefix_ + ':' if (UseCapturedNS_ and self.EndTrigger_nsprefix_) else ''
            EndTrigger_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EndTrigger', pretty_print=pretty_print)
        for ObjType_ in self.ObjType:
            namespaceprefix_ = self.ObjType_nsprefix_ + ':' if (UseCapturedNS_ and self.ObjType_nsprefix_) else ''
            ObjType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ObjType', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            Comment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment', pretty_print=pretty_print)
        for IsDropSource_ in self.IsDropSource:
            namespaceprefix_ = self.IsDropSource_nsprefix_ + ':' if (UseCapturedNS_ and self.IsDropSource_nsprefix_) else ''
            IsDropSource_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IsDropSource', pretty_print=pretty_print)
        for NoLiveDynamics_ in self.NoLiveDynamics:
            namespaceprefix_ = self.NoLiveDynamics_nsprefix_ + ':' if (UseCapturedNS_ and self.NoLiveDynamics_nsprefix_) else ''
            NoLiveDynamics_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NoLiveDynamics', pretty_print=pretty_print)
        for LocalizeMerge_ in self.LocalizeMerge:
            namespaceprefix_ = self.LocalizeMerge_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalizeMerge_nsprefix_) else ''
            LocalizeMerge_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalizeMerge', pretty_print=pretty_print)
        for Calendar_ in self.Calendar:
            namespaceprefix_ = self.Calendar_nsprefix_ + ':' if (UseCapturedNS_ and self.Calendar_nsprefix_) else ''
            Calendar_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Calendar', pretty_print=pretty_print)
        for LangID_ in self.LangID:
            namespaceprefix_ = self.LangID_nsprefix_ + ':' if (UseCapturedNS_ and self.LangID_nsprefix_) else ''
            LangID_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LangID', pretty_print=pretty_print)
        for ShapeKeywords_ in self.ShapeKeywords:
            namespaceprefix_ = self.ShapeKeywords_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapeKeywords_nsprefix_) else ''
            ShapeKeywords_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapeKeywords', pretty_print=pretty_print)
        for DropOnPageScale_ in self.DropOnPageScale:
            namespaceprefix_ = self.DropOnPageScale_nsprefix_ + ':' if (UseCapturedNS_ and self.DropOnPageScale_nsprefix_) else ''
            DropOnPageScale_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DropOnPageScale', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Misc_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NoObjHandles':
            obj_ = NoObjHandles_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NoObjHandles.append(obj_)
            obj_.original_tagname_ = 'NoObjHandles'
        elif nodeName_ == 'NonPrinting':
            obj_ = NonPrinting_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NonPrinting.append(obj_)
            obj_.original_tagname_ = 'NonPrinting'
        elif nodeName_ == 'NoCtlHandles':
            obj_ = NoCtlHandles_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NoCtlHandles.append(obj_)
            obj_.original_tagname_ = 'NoCtlHandles'
        elif nodeName_ == 'NoAlignBox':
            obj_ = NoAlignBox_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NoAlignBox.append(obj_)
            obj_.original_tagname_ = 'NoAlignBox'
        elif nodeName_ == 'UpdateAlignBox':
            obj_ = UpdateAlignBox_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UpdateAlignBox.append(obj_)
            obj_.original_tagname_ = 'UpdateAlignBox'
        elif nodeName_ == 'HideText':
            obj_ = HideText_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HideText.append(obj_)
            obj_.original_tagname_ = 'HideText'
        elif nodeName_ == 'DynFeedback':
            obj_ = DynFeedback_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DynFeedback.append(obj_)
            obj_.original_tagname_ = 'DynFeedback'
        elif nodeName_ == 'GlueType':
            obj_ = GlueType_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GlueType.append(obj_)
            obj_.original_tagname_ = 'GlueType'
        elif nodeName_ == 'WalkPreference':
            obj_ = WalkPreference_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.WalkPreference.append(obj_)
            obj_.original_tagname_ = 'WalkPreference'
        elif nodeName_ == 'BegTrigger':
            obj_ = BegTrigger_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BegTrigger.append(obj_)
            obj_.original_tagname_ = 'BegTrigger'
        elif nodeName_ == 'EndTrigger':
            obj_ = EndTrigger_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EndTrigger.append(obj_)
            obj_.original_tagname_ = 'EndTrigger'
        elif nodeName_ == 'ObjType':
            obj_ = ObjType_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObjType.append(obj_)
            obj_.original_tagname_ = 'ObjType'
        elif nodeName_ == 'Comment':
            obj_ = Comment_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'IsDropSource':
            obj_ = IsDropSource_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IsDropSource.append(obj_)
            obj_.original_tagname_ = 'IsDropSource'
        elif nodeName_ == 'NoLiveDynamics':
            obj_ = NoLiveDynamics_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NoLiveDynamics.append(obj_)
            obj_.original_tagname_ = 'NoLiveDynamics'
        elif nodeName_ == 'LocalizeMerge':
            obj_ = LocalizeMerge_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalizeMerge.append(obj_)
            obj_.original_tagname_ = 'LocalizeMerge'
        elif nodeName_ == 'Calendar':
            obj_ = Calendar_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Calendar.append(obj_)
            obj_.original_tagname_ = 'Calendar'
        elif nodeName_ == 'LangID':
            obj_ = LangID_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LangID.append(obj_)
            obj_.original_tagname_ = 'LangID'
        elif nodeName_ == 'ShapeKeywords':
            obj_ = ShapeKeywords_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapeKeywords.append(obj_)
            obj_.original_tagname_ = 'ShapeKeywords'
        elif nodeName_ == 'DropOnPageScale':
            obj_ = DropOnPageScale_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DropOnPageScale.append(obj_)
            obj_.original_tagname_ = 'DropOnPageScale'
        super(Misc_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Misc_Type


class NoObjHandles_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NoObjHandles_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoObjHandles_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoObjHandles_Type.subclass:
            return NoObjHandles_Type.subclass(*args_, **kwargs_)
        else:
            return NoObjHandles_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(NoObjHandles_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoObjHandles_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NoObjHandles_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NoObjHandles_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoObjHandles_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NoObjHandles_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NoObjHandles_Type'):
        super(NoObjHandles_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoObjHandles_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoObjHandles_Type', fromsubclass_=False, pretty_print=True):
        super(NoObjHandles_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NoObjHandles_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NoObjHandles_Type


class NonPrinting_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NonPrinting_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NonPrinting_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NonPrinting_Type.subclass:
            return NonPrinting_Type.subclass(*args_, **kwargs_)
        else:
            return NonPrinting_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(NonPrinting_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NonPrinting_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NonPrinting_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NonPrinting_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NonPrinting_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NonPrinting_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NonPrinting_Type'):
        super(NonPrinting_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NonPrinting_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NonPrinting_Type', fromsubclass_=False, pretty_print=True):
        super(NonPrinting_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NonPrinting_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NonPrinting_Type


class NoCtlHandles_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NoCtlHandles_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoCtlHandles_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoCtlHandles_Type.subclass:
            return NoCtlHandles_Type.subclass(*args_, **kwargs_)
        else:
            return NoCtlHandles_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(NoCtlHandles_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoCtlHandles_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NoCtlHandles_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NoCtlHandles_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoCtlHandles_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NoCtlHandles_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NoCtlHandles_Type'):
        super(NoCtlHandles_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoCtlHandles_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoCtlHandles_Type', fromsubclass_=False, pretty_print=True):
        super(NoCtlHandles_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NoCtlHandles_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NoCtlHandles_Type


class NoAlignBox_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NoAlignBox_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoAlignBox_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoAlignBox_Type.subclass:
            return NoAlignBox_Type.subclass(*args_, **kwargs_)
        else:
            return NoAlignBox_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(NoAlignBox_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoAlignBox_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NoAlignBox_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NoAlignBox_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoAlignBox_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NoAlignBox_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NoAlignBox_Type'):
        super(NoAlignBox_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoAlignBox_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoAlignBox_Type', fromsubclass_=False, pretty_print=True):
        super(NoAlignBox_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NoAlignBox_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NoAlignBox_Type


class UpdateAlignBox_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(UpdateAlignBox_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UpdateAlignBox_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UpdateAlignBox_Type.subclass:
            return UpdateAlignBox_Type.subclass(*args_, **kwargs_)
        else:
            return UpdateAlignBox_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(UpdateAlignBox_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UpdateAlignBox_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UpdateAlignBox_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UpdateAlignBox_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UpdateAlignBox_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UpdateAlignBox_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UpdateAlignBox_Type'):
        super(UpdateAlignBox_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UpdateAlignBox_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UpdateAlignBox_Type', fromsubclass_=False, pretty_print=True):
        super(UpdateAlignBox_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UpdateAlignBox_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class UpdateAlignBox_Type


class HideText_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(HideText_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HideText_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HideText_Type.subclass:
            return HideText_Type.subclass(*args_, **kwargs_)
        else:
            return HideText_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(HideText_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HideText_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HideText_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HideText_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HideText_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HideText_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HideText_Type'):
        super(HideText_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HideText_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HideText_Type', fromsubclass_=False, pretty_print=True):
        super(HideText_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HideText_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class HideText_Type


class DynFeedback_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DynFeedback_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DynFeedback_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DynFeedback_Type.subclass:
            return DynFeedback_Type.subclass(*args_, **kwargs_)
        else:
            return DynFeedback_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DynFeedback_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DynFeedback_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DynFeedback_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DynFeedback_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DynFeedback_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DynFeedback_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DynFeedback_Type'):
        super(DynFeedback_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DynFeedback_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DynFeedback_Type', fromsubclass_=False, pretty_print=True):
        super(DynFeedback_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DynFeedback_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DynFeedback_Type


class GlueType_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GlueType_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlueType_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlueType_Type.subclass:
            return GlueType_Type.subclass(*args_, **kwargs_)
        else:
            return GlueType_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(GlueType_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GlueType_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GlueType_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GlueType_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GlueType_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GlueType_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GlueType_Type'):
        super(GlueType_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GlueType_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GlueType_Type', fromsubclass_=False, pretty_print=True):
        super(GlueType_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GlueType_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class GlueType_Type


class WalkPreference_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(WalkPreference_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WalkPreference_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WalkPreference_Type.subclass:
            return WalkPreference_Type.subclass(*args_, **kwargs_)
        else:
            return WalkPreference_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(WalkPreference_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WalkPreference_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WalkPreference_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'WalkPreference_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WalkPreference_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WalkPreference_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WalkPreference_Type'):
        super(WalkPreference_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WalkPreference_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WalkPreference_Type', fromsubclass_=False, pretty_print=True):
        super(WalkPreference_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(WalkPreference_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class WalkPreference_Type


class BegTrigger_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BegTrigger_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BegTrigger_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BegTrigger_Type.subclass:
            return BegTrigger_Type.subclass(*args_, **kwargs_)
        else:
            return BegTrigger_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(BegTrigger_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BegTrigger_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BegTrigger_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BegTrigger_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BegTrigger_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BegTrigger_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BegTrigger_Type'):
        super(BegTrigger_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BegTrigger_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BegTrigger_Type', fromsubclass_=False, pretty_print=True):
        super(BegTrigger_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BegTrigger_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BegTrigger_Type


class EndTrigger_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EndTrigger_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndTrigger_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndTrigger_Type.subclass:
            return EndTrigger_Type.subclass(*args_, **kwargs_)
        else:
            return EndTrigger_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EndTrigger_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndTrigger_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EndTrigger_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EndTrigger_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndTrigger_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EndTrigger_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EndTrigger_Type'):
        super(EndTrigger_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndTrigger_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndTrigger_Type', fromsubclass_=False, pretty_print=True):
        super(EndTrigger_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EndTrigger_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EndTrigger_Type


class ObjType_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ObjType_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObjType_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObjType_Type.subclass:
            return ObjType_Type.subclass(*args_, **kwargs_)
        else:
            return ObjType_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ObjType_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObjType_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObjType_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ObjType_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObjType_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObjType_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObjType_Type'):
        super(ObjType_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObjType_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObjType_Type', fromsubclass_=False, pretty_print=True):
        super(ObjType_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ObjType_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ObjType_Type


class Comment_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Comment_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Comment_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Comment_Type.subclass:
            return Comment_Type.subclass(*args_, **kwargs_)
        else:
            return Comment_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Comment_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Comment_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Comment_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Comment_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Comment_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Comment_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Comment_Type'):
        super(Comment_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Comment_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Comment_Type', fromsubclass_=False, pretty_print=True):
        super(Comment_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Comment_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Comment_Type


class IsDropSource_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IsDropSource_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IsDropSource_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IsDropSource_Type.subclass:
            return IsDropSource_Type.subclass(*args_, **kwargs_)
        else:
            return IsDropSource_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(IsDropSource_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IsDropSource_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IsDropSource_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IsDropSource_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IsDropSource_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IsDropSource_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IsDropSource_Type'):
        super(IsDropSource_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IsDropSource_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IsDropSource_Type', fromsubclass_=False, pretty_print=True):
        super(IsDropSource_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IsDropSource_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class IsDropSource_Type


class NoLiveDynamics_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NoLiveDynamics_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoLiveDynamics_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoLiveDynamics_Type.subclass:
            return NoLiveDynamics_Type.subclass(*args_, **kwargs_)
        else:
            return NoLiveDynamics_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(NoLiveDynamics_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoLiveDynamics_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NoLiveDynamics_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NoLiveDynamics_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoLiveDynamics_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NoLiveDynamics_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NoLiveDynamics_Type'):
        super(NoLiveDynamics_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoLiveDynamics_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoLiveDynamics_Type', fromsubclass_=False, pretty_print=True):
        super(NoLiveDynamics_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NoLiveDynamics_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NoLiveDynamics_Type


class LocalizeMerge_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LocalizeMerge_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocalizeMerge_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalizeMerge_Type.subclass:
            return LocalizeMerge_Type.subclass(*args_, **kwargs_)
        else:
            return LocalizeMerge_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LocalizeMerge_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LocalizeMerge_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocalizeMerge_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LocalizeMerge_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocalizeMerge_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LocalizeMerge_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LocalizeMerge_Type'):
        super(LocalizeMerge_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocalizeMerge_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LocalizeMerge_Type', fromsubclass_=False, pretty_print=True):
        super(LocalizeMerge_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LocalizeMerge_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LocalizeMerge_Type


class Calendar_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Calendar_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Calendar_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Calendar_Type.subclass:
            return Calendar_Type.subclass(*args_, **kwargs_)
        else:
            return Calendar_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Calendar_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Calendar_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Calendar_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Calendar_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Calendar_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Calendar_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Calendar_Type'):
        super(Calendar_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Calendar_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Calendar_Type', fromsubclass_=False, pretty_print=True):
        super(Calendar_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Calendar_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Calendar_Type


class LangID_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LangID_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LangID_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LangID_Type.subclass:
            return LangID_Type.subclass(*args_, **kwargs_)
        else:
            return LangID_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LangID_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LangID_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LangID_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LangID_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LangID_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LangID_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LangID_Type'):
        super(LangID_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LangID_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LangID_Type', fromsubclass_=False, pretty_print=True):
        super(LangID_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LangID_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LangID_Type


class ShapeKeywords_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapeKeywords_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapeKeywords_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapeKeywords_Type.subclass:
            return ShapeKeywords_Type.subclass(*args_, **kwargs_)
        else:
            return ShapeKeywords_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapeKeywords_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeKeywords_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapeKeywords_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapeKeywords_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeKeywords_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapeKeywords_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapeKeywords_Type'):
        super(ShapeKeywords_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeKeywords_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeKeywords_Type', fromsubclass_=False, pretty_print=True):
        super(ShapeKeywords_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapeKeywords_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapeKeywords_Type


class DropOnPageScale_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DropOnPageScale_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DropOnPageScale_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DropOnPageScale_Type.subclass:
            return DropOnPageScale_Type.subclass(*args_, **kwargs_)
        else:
            return DropOnPageScale_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DropOnPageScale_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DropOnPageScale_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DropOnPageScale_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DropOnPageScale_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DropOnPageScale_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DropOnPageScale_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DropOnPageScale_Type'):
        super(DropOnPageScale_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DropOnPageScale_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DropOnPageScale_Type', fromsubclass_=False, pretty_print=True):
        super(DropOnPageScale_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DropOnPageScale_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DropOnPageScale_Type


class RulerGrid_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, XRulerDensity=None, YRulerDensity=None, XRulerOrigin=None, YRulerOrigin=None, XGridDensity=None, YGridDensity=None, XGridSpacing=None, YGridSpacing=None, XGridOrigin=None, YGridOrigin=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RulerGrid_Type, self).__init__(Del,  **kwargs_)
        if XRulerDensity is None:
            self.XRulerDensity = []
        else:
            self.XRulerDensity = XRulerDensity
        self.XRulerDensity_nsprefix_ = None
        if YRulerDensity is None:
            self.YRulerDensity = []
        else:
            self.YRulerDensity = YRulerDensity
        self.YRulerDensity_nsprefix_ = None
        if XRulerOrigin is None:
            self.XRulerOrigin = []
        else:
            self.XRulerOrigin = XRulerOrigin
        self.XRulerOrigin_nsprefix_ = None
        if YRulerOrigin is None:
            self.YRulerOrigin = []
        else:
            self.YRulerOrigin = YRulerOrigin
        self.YRulerOrigin_nsprefix_ = None
        if XGridDensity is None:
            self.XGridDensity = []
        else:
            self.XGridDensity = XGridDensity
        self.XGridDensity_nsprefix_ = None
        if YGridDensity is None:
            self.YGridDensity = []
        else:
            self.YGridDensity = YGridDensity
        self.YGridDensity_nsprefix_ = None
        if XGridSpacing is None:
            self.XGridSpacing = []
        else:
            self.XGridSpacing = XGridSpacing
        self.XGridSpacing_nsprefix_ = None
        if YGridSpacing is None:
            self.YGridSpacing = []
        else:
            self.YGridSpacing = YGridSpacing
        self.YGridSpacing_nsprefix_ = None
        if XGridOrigin is None:
            self.XGridOrigin = []
        else:
            self.XGridOrigin = XGridOrigin
        self.XGridOrigin_nsprefix_ = None
        if YGridOrigin is None:
            self.YGridOrigin = []
        else:
            self.YGridOrigin = YGridOrigin
        self.YGridOrigin_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RulerGrid_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RulerGrid_Type.subclass:
            return RulerGrid_Type.subclass(*args_, **kwargs_)
        else:
            return RulerGrid_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_XRulerDensity(self):
        return self.XRulerDensity
    def set_XRulerDensity(self, XRulerDensity):
        self.XRulerDensity = XRulerDensity
    def add_XRulerDensity(self, value):
        self.XRulerDensity.append(value)
    def insert_XRulerDensity_at(self, index, value):
        self.XRulerDensity.insert(index, value)
    def replace_XRulerDensity_at(self, index, value):
        self.XRulerDensity[index] = value
    def get_YRulerDensity(self):
        return self.YRulerDensity
    def set_YRulerDensity(self, YRulerDensity):
        self.YRulerDensity = YRulerDensity
    def add_YRulerDensity(self, value):
        self.YRulerDensity.append(value)
    def insert_YRulerDensity_at(self, index, value):
        self.YRulerDensity.insert(index, value)
    def replace_YRulerDensity_at(self, index, value):
        self.YRulerDensity[index] = value
    def get_XRulerOrigin(self):
        return self.XRulerOrigin
    def set_XRulerOrigin(self, XRulerOrigin):
        self.XRulerOrigin = XRulerOrigin
    def add_XRulerOrigin(self, value):
        self.XRulerOrigin.append(value)
    def insert_XRulerOrigin_at(self, index, value):
        self.XRulerOrigin.insert(index, value)
    def replace_XRulerOrigin_at(self, index, value):
        self.XRulerOrigin[index] = value
    def get_YRulerOrigin(self):
        return self.YRulerOrigin
    def set_YRulerOrigin(self, YRulerOrigin):
        self.YRulerOrigin = YRulerOrigin
    def add_YRulerOrigin(self, value):
        self.YRulerOrigin.append(value)
    def insert_YRulerOrigin_at(self, index, value):
        self.YRulerOrigin.insert(index, value)
    def replace_YRulerOrigin_at(self, index, value):
        self.YRulerOrigin[index] = value
    def get_XGridDensity(self):
        return self.XGridDensity
    def set_XGridDensity(self, XGridDensity):
        self.XGridDensity = XGridDensity
    def add_XGridDensity(self, value):
        self.XGridDensity.append(value)
    def insert_XGridDensity_at(self, index, value):
        self.XGridDensity.insert(index, value)
    def replace_XGridDensity_at(self, index, value):
        self.XGridDensity[index] = value
    def get_YGridDensity(self):
        return self.YGridDensity
    def set_YGridDensity(self, YGridDensity):
        self.YGridDensity = YGridDensity
    def add_YGridDensity(self, value):
        self.YGridDensity.append(value)
    def insert_YGridDensity_at(self, index, value):
        self.YGridDensity.insert(index, value)
    def replace_YGridDensity_at(self, index, value):
        self.YGridDensity[index] = value
    def get_XGridSpacing(self):
        return self.XGridSpacing
    def set_XGridSpacing(self, XGridSpacing):
        self.XGridSpacing = XGridSpacing
    def add_XGridSpacing(self, value):
        self.XGridSpacing.append(value)
    def insert_XGridSpacing_at(self, index, value):
        self.XGridSpacing.insert(index, value)
    def replace_XGridSpacing_at(self, index, value):
        self.XGridSpacing[index] = value
    def get_YGridSpacing(self):
        return self.YGridSpacing
    def set_YGridSpacing(self, YGridSpacing):
        self.YGridSpacing = YGridSpacing
    def add_YGridSpacing(self, value):
        self.YGridSpacing.append(value)
    def insert_YGridSpacing_at(self, index, value):
        self.YGridSpacing.insert(index, value)
    def replace_YGridSpacing_at(self, index, value):
        self.YGridSpacing[index] = value
    def get_XGridOrigin(self):
        return self.XGridOrigin
    def set_XGridOrigin(self, XGridOrigin):
        self.XGridOrigin = XGridOrigin
    def add_XGridOrigin(self, value):
        self.XGridOrigin.append(value)
    def insert_XGridOrigin_at(self, index, value):
        self.XGridOrigin.insert(index, value)
    def replace_XGridOrigin_at(self, index, value):
        self.XGridOrigin[index] = value
    def get_YGridOrigin(self):
        return self.YGridOrigin
    def set_YGridOrigin(self, YGridOrigin):
        self.YGridOrigin = YGridOrigin
    def add_YGridOrigin(self, value):
        self.YGridOrigin.append(value)
    def insert_YGridOrigin_at(self, index, value):
        self.YGridOrigin.insert(index, value)
    def replace_YGridOrigin_at(self, index, value):
        self.YGridOrigin[index] = value
    def hasContent_(self):
        if (
            self.XRulerDensity or
            self.YRulerDensity or
            self.XRulerOrigin or
            self.YRulerOrigin or
            self.XGridDensity or
            self.YGridDensity or
            self.XGridSpacing or
            self.YGridSpacing or
            self.XGridOrigin or
            self.YGridOrigin or
            super(RulerGrid_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='RulerGrid_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RulerGrid_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RulerGrid_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RulerGrid_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RulerGrid_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RulerGrid_Type'):
        super(RulerGrid_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RulerGrid_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='RulerGrid_Type', fromsubclass_=False, pretty_print=True):
        super(RulerGrid_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for XRulerDensity_ in self.XRulerDensity:
            namespaceprefix_ = self.XRulerDensity_nsprefix_ + ':' if (UseCapturedNS_ and self.XRulerDensity_nsprefix_) else ''
            XRulerDensity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRulerDensity', pretty_print=pretty_print)
        for YRulerDensity_ in self.YRulerDensity:
            namespaceprefix_ = self.YRulerDensity_nsprefix_ + ':' if (UseCapturedNS_ and self.YRulerDensity_nsprefix_) else ''
            YRulerDensity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='YRulerDensity', pretty_print=pretty_print)
        for XRulerOrigin_ in self.XRulerOrigin:
            namespaceprefix_ = self.XRulerOrigin_nsprefix_ + ':' if (UseCapturedNS_ and self.XRulerOrigin_nsprefix_) else ''
            XRulerOrigin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRulerOrigin', pretty_print=pretty_print)
        for YRulerOrigin_ in self.YRulerOrigin:
            namespaceprefix_ = self.YRulerOrigin_nsprefix_ + ':' if (UseCapturedNS_ and self.YRulerOrigin_nsprefix_) else ''
            YRulerOrigin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='YRulerOrigin', pretty_print=pretty_print)
        for XGridDensity_ in self.XGridDensity:
            namespaceprefix_ = self.XGridDensity_nsprefix_ + ':' if (UseCapturedNS_ and self.XGridDensity_nsprefix_) else ''
            XGridDensity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XGridDensity', pretty_print=pretty_print)
        for YGridDensity_ in self.YGridDensity:
            namespaceprefix_ = self.YGridDensity_nsprefix_ + ':' if (UseCapturedNS_ and self.YGridDensity_nsprefix_) else ''
            YGridDensity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='YGridDensity', pretty_print=pretty_print)
        for XGridSpacing_ in self.XGridSpacing:
            namespaceprefix_ = self.XGridSpacing_nsprefix_ + ':' if (UseCapturedNS_ and self.XGridSpacing_nsprefix_) else ''
            XGridSpacing_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XGridSpacing', pretty_print=pretty_print)
        for YGridSpacing_ in self.YGridSpacing:
            namespaceprefix_ = self.YGridSpacing_nsprefix_ + ':' if (UseCapturedNS_ and self.YGridSpacing_nsprefix_) else ''
            YGridSpacing_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='YGridSpacing', pretty_print=pretty_print)
        for XGridOrigin_ in self.XGridOrigin:
            namespaceprefix_ = self.XGridOrigin_nsprefix_ + ':' if (UseCapturedNS_ and self.XGridOrigin_nsprefix_) else ''
            XGridOrigin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XGridOrigin', pretty_print=pretty_print)
        for YGridOrigin_ in self.YGridOrigin:
            namespaceprefix_ = self.YGridOrigin_nsprefix_ + ':' if (UseCapturedNS_ and self.YGridOrigin_nsprefix_) else ''
            YGridOrigin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='YGridOrigin', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RulerGrid_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'XRulerDensity':
            obj_ = XRulerDensity_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRulerDensity.append(obj_)
            obj_.original_tagname_ = 'XRulerDensity'
        elif nodeName_ == 'YRulerDensity':
            obj_ = YRulerDensity_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.YRulerDensity.append(obj_)
            obj_.original_tagname_ = 'YRulerDensity'
        elif nodeName_ == 'XRulerOrigin':
            obj_ = XRulerOrigin_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRulerOrigin.append(obj_)
            obj_.original_tagname_ = 'XRulerOrigin'
        elif nodeName_ == 'YRulerOrigin':
            obj_ = YRulerOrigin_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.YRulerOrigin.append(obj_)
            obj_.original_tagname_ = 'YRulerOrigin'
        elif nodeName_ == 'XGridDensity':
            obj_ = XGridDensity_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XGridDensity.append(obj_)
            obj_.original_tagname_ = 'XGridDensity'
        elif nodeName_ == 'YGridDensity':
            obj_ = YGridDensity_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.YGridDensity.append(obj_)
            obj_.original_tagname_ = 'YGridDensity'
        elif nodeName_ == 'XGridSpacing':
            obj_ = XGridSpacing_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XGridSpacing.append(obj_)
            obj_.original_tagname_ = 'XGridSpacing'
        elif nodeName_ == 'YGridSpacing':
            obj_ = YGridSpacing_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.YGridSpacing.append(obj_)
            obj_.original_tagname_ = 'YGridSpacing'
        elif nodeName_ == 'XGridOrigin':
            obj_ = XGridOrigin_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XGridOrigin.append(obj_)
            obj_.original_tagname_ = 'XGridOrigin'
        elif nodeName_ == 'YGridOrigin':
            obj_ = YGridOrigin_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.YGridOrigin.append(obj_)
            obj_.original_tagname_ = 'YGridOrigin'
        super(RulerGrid_Type, self).buildChildren(child_, node, nodeName_, True)
# end class RulerGrid_Type


class XRulerDensity_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(XRulerDensity_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XRulerDensity_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XRulerDensity_Type.subclass:
            return XRulerDensity_Type.subclass(*args_, **kwargs_)
        else:
            return XRulerDensity_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(XRulerDensity_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XRulerDensity_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XRulerDensity_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'XRulerDensity_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XRulerDensity_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XRulerDensity_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XRulerDensity_Type'):
        super(XRulerDensity_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XRulerDensity_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XRulerDensity_Type', fromsubclass_=False, pretty_print=True):
        super(XRulerDensity_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(XRulerDensity_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class XRulerDensity_Type


class YRulerDensity_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(YRulerDensity_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, YRulerDensity_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if YRulerDensity_Type.subclass:
            return YRulerDensity_Type.subclass(*args_, **kwargs_)
        else:
            return YRulerDensity_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(YRulerDensity_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YRulerDensity_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('YRulerDensity_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'YRulerDensity_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YRulerDensity_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='YRulerDensity_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='YRulerDensity_Type'):
        super(YRulerDensity_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YRulerDensity_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YRulerDensity_Type', fromsubclass_=False, pretty_print=True):
        super(YRulerDensity_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(YRulerDensity_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class YRulerDensity_Type


class XRulerOrigin_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(XRulerOrigin_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XRulerOrigin_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XRulerOrigin_Type.subclass:
            return XRulerOrigin_Type.subclass(*args_, **kwargs_)
        else:
            return XRulerOrigin_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(XRulerOrigin_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XRulerOrigin_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XRulerOrigin_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'XRulerOrigin_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XRulerOrigin_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XRulerOrigin_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XRulerOrigin_Type'):
        super(XRulerOrigin_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XRulerOrigin_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XRulerOrigin_Type', fromsubclass_=False, pretty_print=True):
        super(XRulerOrigin_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(XRulerOrigin_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class XRulerOrigin_Type


class YRulerOrigin_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(YRulerOrigin_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, YRulerOrigin_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if YRulerOrigin_Type.subclass:
            return YRulerOrigin_Type.subclass(*args_, **kwargs_)
        else:
            return YRulerOrigin_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(YRulerOrigin_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YRulerOrigin_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('YRulerOrigin_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'YRulerOrigin_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YRulerOrigin_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='YRulerOrigin_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='YRulerOrigin_Type'):
        super(YRulerOrigin_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YRulerOrigin_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YRulerOrigin_Type', fromsubclass_=False, pretty_print=True):
        super(YRulerOrigin_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(YRulerOrigin_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class YRulerOrigin_Type


class XGridDensity_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(XGridDensity_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XGridDensity_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XGridDensity_Type.subclass:
            return XGridDensity_Type.subclass(*args_, **kwargs_)
        else:
            return XGridDensity_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(XGridDensity_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XGridDensity_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XGridDensity_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'XGridDensity_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XGridDensity_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XGridDensity_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XGridDensity_Type'):
        super(XGridDensity_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XGridDensity_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XGridDensity_Type', fromsubclass_=False, pretty_print=True):
        super(XGridDensity_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(XGridDensity_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class XGridDensity_Type


class YGridDensity_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(YGridDensity_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, YGridDensity_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if YGridDensity_Type.subclass:
            return YGridDensity_Type.subclass(*args_, **kwargs_)
        else:
            return YGridDensity_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(YGridDensity_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YGridDensity_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('YGridDensity_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'YGridDensity_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YGridDensity_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='YGridDensity_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='YGridDensity_Type'):
        super(YGridDensity_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YGridDensity_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YGridDensity_Type', fromsubclass_=False, pretty_print=True):
        super(YGridDensity_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(YGridDensity_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class YGridDensity_Type


class XGridSpacing_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(XGridSpacing_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XGridSpacing_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XGridSpacing_Type.subclass:
            return XGridSpacing_Type.subclass(*args_, **kwargs_)
        else:
            return XGridSpacing_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(XGridSpacing_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XGridSpacing_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XGridSpacing_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'XGridSpacing_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XGridSpacing_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XGridSpacing_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XGridSpacing_Type'):
        super(XGridSpacing_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XGridSpacing_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XGridSpacing_Type', fromsubclass_=False, pretty_print=True):
        super(XGridSpacing_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(XGridSpacing_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class XGridSpacing_Type


class YGridSpacing_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(YGridSpacing_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, YGridSpacing_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if YGridSpacing_Type.subclass:
            return YGridSpacing_Type.subclass(*args_, **kwargs_)
        else:
            return YGridSpacing_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(YGridSpacing_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YGridSpacing_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('YGridSpacing_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'YGridSpacing_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YGridSpacing_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='YGridSpacing_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='YGridSpacing_Type'):
        super(YGridSpacing_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YGridSpacing_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YGridSpacing_Type', fromsubclass_=False, pretty_print=True):
        super(YGridSpacing_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(YGridSpacing_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class YGridSpacing_Type


class XGridOrigin_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(XGridOrigin_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XGridOrigin_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XGridOrigin_Type.subclass:
            return XGridOrigin_Type.subclass(*args_, **kwargs_)
        else:
            return XGridOrigin_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(XGridOrigin_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XGridOrigin_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XGridOrigin_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'XGridOrigin_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XGridOrigin_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XGridOrigin_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XGridOrigin_Type'):
        super(XGridOrigin_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XGridOrigin_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XGridOrigin_Type', fromsubclass_=False, pretty_print=True):
        super(XGridOrigin_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(XGridOrigin_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class XGridOrigin_Type


class YGridOrigin_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(YGridOrigin_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, YGridOrigin_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if YGridOrigin_Type.subclass:
            return YGridOrigin_Type.subclass(*args_, **kwargs_)
        else:
            return YGridOrigin_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(YGridOrigin_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YGridOrigin_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('YGridOrigin_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'YGridOrigin_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YGridOrigin_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='YGridOrigin_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='YGridOrigin_Type'):
        super(YGridOrigin_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YGridOrigin_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YGridOrigin_Type', fromsubclass_=False, pretty_print=True):
        super(YGridOrigin_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(YGridOrigin_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class YGridOrigin_Type


class Hyperlink5_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Hyperlink5_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Hyperlink5_Type.subclass:
            return Hyperlink5_Type.subclass(*args_, **kwargs_)
        else:
            return Hyperlink5_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Hyperlink5_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Hyperlink5_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Hyperlink5_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Hyperlink5_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Hyperlink5_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Hyperlink5_Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Hyperlink5_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Hyperlink5_Type


class Description_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Description_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Description_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Description_Type.subclass:
            return Description_Type.subclass(*args_, **kwargs_)
        else:
            return Description_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Description_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Description_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Description_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Description_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Description_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Description_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Description_Type'):
        super(Description_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Description_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Description_Type', fromsubclass_=False, pretty_print=True):
        super(Description_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Description_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Description_Type


class Address_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Address_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Address_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Address_Type.subclass:
            return Address_Type.subclass(*args_, **kwargs_)
        else:
            return Address_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Address_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Address_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Address_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Address_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Address_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Address_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Address_Type'):
        super(Address_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Address_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Address_Type', fromsubclass_=False, pretty_print=True):
        super(Address_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Address_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Address_Type


class SubAddress_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SubAddress_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubAddress_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubAddress_Type.subclass:
            return SubAddress_Type.subclass(*args_, **kwargs_)
        else:
            return SubAddress_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(SubAddress_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubAddress_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubAddress_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SubAddress_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubAddress_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubAddress_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SubAddress_Type'):
        super(SubAddress_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubAddress_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubAddress_Type', fromsubclass_=False, pretty_print=True):
        super(SubAddress_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SubAddress_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SubAddress_Type


class ExtraInfo_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ExtraInfo_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExtraInfo_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExtraInfo_Type.subclass:
            return ExtraInfo_Type.subclass(*args_, **kwargs_)
        else:
            return ExtraInfo_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ExtraInfo_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExtraInfo_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExtraInfo_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ExtraInfo_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExtraInfo_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExtraInfo_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExtraInfo_Type'):
        super(ExtraInfo_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExtraInfo_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExtraInfo_Type', fromsubclass_=False, pretty_print=True):
        super(ExtraInfo_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExtraInfo_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ExtraInfo_Type


class Frame_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Frame_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Frame_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Frame_Type.subclass:
            return Frame_Type.subclass(*args_, **kwargs_)
        else:
            return Frame_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Frame_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Frame_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Frame_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Frame_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Frame_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Frame_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Frame_Type'):
        super(Frame_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Frame_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Frame_Type', fromsubclass_=False, pretty_print=True):
        super(Frame_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Frame_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Frame_Type


class NewWindow_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NewWindow_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NewWindow_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NewWindow_Type.subclass:
            return NewWindow_Type.subclass(*args_, **kwargs_)
        else:
            return NewWindow_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(NewWindow_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NewWindow_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NewWindow_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NewWindow_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NewWindow_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NewWindow_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NewWindow_Type'):
        super(NewWindow_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NewWindow_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NewWindow_Type', fromsubclass_=False, pretty_print=True):
        super(NewWindow_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NewWindow_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NewWindow_Type


class Default_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Default_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Default_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Default_Type.subclass:
            return Default_Type.subclass(*args_, **kwargs_)
        else:
            return Default_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Default_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Default_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Default_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Default_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Default_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Default_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Default_Type'):
        super(Default_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Default_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Default_Type', fromsubclass_=False, pretty_print=True):
        super(Default_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Default_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Default_Type


class Invisible_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Invisible_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Invisible_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Invisible_Type.subclass:
            return Invisible_Type.subclass(*args_, **kwargs_)
        else:
            return Invisible_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Invisible_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Invisible_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Invisible_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Invisible_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Invisible_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Invisible_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Invisible_Type'):
        super(Invisible_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Invisible_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Invisible_Type', fromsubclass_=False, pretty_print=True):
        super(Invisible_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Invisible_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Invisible_Type


class SortKey_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SortKey_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SortKey_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SortKey_Type.subclass:
            return SortKey_Type.subclass(*args_, **kwargs_)
        else:
            return SortKey_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(SortKey_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SortKey_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SortKey_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SortKey_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SortKey_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SortKey_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SortKey_Type'):
        super(SortKey_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SortKey_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SortKey_Type', fromsubclass_=False, pretty_print=True):
        super(SortKey_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SortKey_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SortKey_Type


class DocProps_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, OutputFormat=None, LockPreview=None, AddMarkup=None, ViewMarkup=None, PreviewQuality=None, PreviewScope=None, DocLangID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DocProps_Type, self).__init__(Del,  **kwargs_)
        if OutputFormat is None:
            self.OutputFormat = []
        else:
            self.OutputFormat = OutputFormat
        self.OutputFormat_nsprefix_ = None
        if LockPreview is None:
            self.LockPreview = []
        else:
            self.LockPreview = LockPreview
        self.LockPreview_nsprefix_ = None
        if AddMarkup is None:
            self.AddMarkup = []
        else:
            self.AddMarkup = AddMarkup
        self.AddMarkup_nsprefix_ = None
        if ViewMarkup is None:
            self.ViewMarkup = []
        else:
            self.ViewMarkup = ViewMarkup
        self.ViewMarkup_nsprefix_ = None
        if PreviewQuality is None:
            self.PreviewQuality = []
        else:
            self.PreviewQuality = PreviewQuality
        self.PreviewQuality_nsprefix_ = None
        if PreviewScope is None:
            self.PreviewScope = []
        else:
            self.PreviewScope = PreviewScope
        self.PreviewScope_nsprefix_ = None
        if DocLangID is None:
            self.DocLangID = []
        else:
            self.DocLangID = DocLangID
        self.DocLangID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocProps_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocProps_Type.subclass:
            return DocProps_Type.subclass(*args_, **kwargs_)
        else:
            return DocProps_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OutputFormat(self):
        return self.OutputFormat
    def set_OutputFormat(self, OutputFormat):
        self.OutputFormat = OutputFormat
    def add_OutputFormat(self, value):
        self.OutputFormat.append(value)
    def insert_OutputFormat_at(self, index, value):
        self.OutputFormat.insert(index, value)
    def replace_OutputFormat_at(self, index, value):
        self.OutputFormat[index] = value
    def get_LockPreview(self):
        return self.LockPreview
    def set_LockPreview(self, LockPreview):
        self.LockPreview = LockPreview
    def add_LockPreview(self, value):
        self.LockPreview.append(value)
    def insert_LockPreview_at(self, index, value):
        self.LockPreview.insert(index, value)
    def replace_LockPreview_at(self, index, value):
        self.LockPreview[index] = value
    def get_AddMarkup(self):
        return self.AddMarkup
    def set_AddMarkup(self, AddMarkup):
        self.AddMarkup = AddMarkup
    def add_AddMarkup(self, value):
        self.AddMarkup.append(value)
    def insert_AddMarkup_at(self, index, value):
        self.AddMarkup.insert(index, value)
    def replace_AddMarkup_at(self, index, value):
        self.AddMarkup[index] = value
    def get_ViewMarkup(self):
        return self.ViewMarkup
    def set_ViewMarkup(self, ViewMarkup):
        self.ViewMarkup = ViewMarkup
    def add_ViewMarkup(self, value):
        self.ViewMarkup.append(value)
    def insert_ViewMarkup_at(self, index, value):
        self.ViewMarkup.insert(index, value)
    def replace_ViewMarkup_at(self, index, value):
        self.ViewMarkup[index] = value
    def get_PreviewQuality(self):
        return self.PreviewQuality
    def set_PreviewQuality(self, PreviewQuality):
        self.PreviewQuality = PreviewQuality
    def add_PreviewQuality(self, value):
        self.PreviewQuality.append(value)
    def insert_PreviewQuality_at(self, index, value):
        self.PreviewQuality.insert(index, value)
    def replace_PreviewQuality_at(self, index, value):
        self.PreviewQuality[index] = value
    def get_PreviewScope(self):
        return self.PreviewScope
    def set_PreviewScope(self, PreviewScope):
        self.PreviewScope = PreviewScope
    def add_PreviewScope(self, value):
        self.PreviewScope.append(value)
    def insert_PreviewScope_at(self, index, value):
        self.PreviewScope.insert(index, value)
    def replace_PreviewScope_at(self, index, value):
        self.PreviewScope[index] = value
    def get_DocLangID(self):
        return self.DocLangID
    def set_DocLangID(self, DocLangID):
        self.DocLangID = DocLangID
    def add_DocLangID(self, value):
        self.DocLangID.append(value)
    def insert_DocLangID_at(self, index, value):
        self.DocLangID.insert(index, value)
    def replace_DocLangID_at(self, index, value):
        self.DocLangID[index] = value
    def hasContent_(self):
        if (
            self.OutputFormat or
            self.LockPreview or
            self.AddMarkup or
            self.ViewMarkup or
            self.PreviewQuality or
            self.PreviewScope or
            self.DocLangID or
            super(DocProps_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='DocProps_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocProps_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DocProps_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocProps_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DocProps_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DocProps_Type'):
        super(DocProps_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocProps_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='DocProps_Type', fromsubclass_=False, pretty_print=True):
        super(DocProps_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OutputFormat_ in self.OutputFormat:
            namespaceprefix_ = self.OutputFormat_nsprefix_ + ':' if (UseCapturedNS_ and self.OutputFormat_nsprefix_) else ''
            OutputFormat_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OutputFormat', pretty_print=pretty_print)
        for LockPreview_ in self.LockPreview:
            namespaceprefix_ = self.LockPreview_nsprefix_ + ':' if (UseCapturedNS_ and self.LockPreview_nsprefix_) else ''
            LockPreview_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LockPreview', pretty_print=pretty_print)
        for AddMarkup_ in self.AddMarkup:
            namespaceprefix_ = self.AddMarkup_nsprefix_ + ':' if (UseCapturedNS_ and self.AddMarkup_nsprefix_) else ''
            AddMarkup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AddMarkup', pretty_print=pretty_print)
        for ViewMarkup_ in self.ViewMarkup:
            namespaceprefix_ = self.ViewMarkup_nsprefix_ + ':' if (UseCapturedNS_ and self.ViewMarkup_nsprefix_) else ''
            ViewMarkup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ViewMarkup', pretty_print=pretty_print)
        for PreviewQuality_ in self.PreviewQuality:
            namespaceprefix_ = self.PreviewQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.PreviewQuality_nsprefix_) else ''
            PreviewQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PreviewQuality', pretty_print=pretty_print)
        for PreviewScope_ in self.PreviewScope:
            namespaceprefix_ = self.PreviewScope_nsprefix_ + ':' if (UseCapturedNS_ and self.PreviewScope_nsprefix_) else ''
            PreviewScope_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PreviewScope', pretty_print=pretty_print)
        for DocLangID_ in self.DocLangID:
            namespaceprefix_ = self.DocLangID_nsprefix_ + ':' if (UseCapturedNS_ and self.DocLangID_nsprefix_) else ''
            DocLangID_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DocLangID', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DocProps_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OutputFormat':
            obj_ = OutputFormat_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OutputFormat.append(obj_)
            obj_.original_tagname_ = 'OutputFormat'
        elif nodeName_ == 'LockPreview':
            obj_ = LockPreview_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LockPreview.append(obj_)
            obj_.original_tagname_ = 'LockPreview'
        elif nodeName_ == 'AddMarkup':
            obj_ = AddMarkup_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AddMarkup.append(obj_)
            obj_.original_tagname_ = 'AddMarkup'
        elif nodeName_ == 'ViewMarkup':
            obj_ = ViewMarkup_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ViewMarkup.append(obj_)
            obj_.original_tagname_ = 'ViewMarkup'
        elif nodeName_ == 'PreviewQuality':
            obj_ = PreviewQuality_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PreviewQuality.append(obj_)
            obj_.original_tagname_ = 'PreviewQuality'
        elif nodeName_ == 'PreviewScope':
            obj_ = PreviewScope_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PreviewScope.append(obj_)
            obj_.original_tagname_ = 'PreviewScope'
        elif nodeName_ == 'DocLangID':
            obj_ = DocLangID_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DocLangID.append(obj_)
            obj_.original_tagname_ = 'DocLangID'
        super(DocProps_Type, self).buildChildren(child_, node, nodeName_, True)
# end class DocProps_Type


class OutputFormat_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(OutputFormat_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutputFormat_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutputFormat_Type.subclass:
            return OutputFormat_Type.subclass(*args_, **kwargs_)
        else:
            return OutputFormat_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(OutputFormat_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OutputFormat_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OutputFormat_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OutputFormat_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OutputFormat_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OutputFormat_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OutputFormat_Type'):
        super(OutputFormat_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OutputFormat_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OutputFormat_Type', fromsubclass_=False, pretty_print=True):
        super(OutputFormat_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OutputFormat_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class OutputFormat_Type


class LockPreview_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LockPreview_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LockPreview_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LockPreview_Type.subclass:
            return LockPreview_Type.subclass(*args_, **kwargs_)
        else:
            return LockPreview_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LockPreview_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockPreview_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LockPreview_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LockPreview_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockPreview_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LockPreview_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LockPreview_Type'):
        super(LockPreview_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LockPreview_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LockPreview_Type', fromsubclass_=False, pretty_print=True):
        super(LockPreview_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LockPreview_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LockPreview_Type


class AddMarkup_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AddMarkup_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddMarkup_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddMarkup_Type.subclass:
            return AddMarkup_Type.subclass(*args_, **kwargs_)
        else:
            return AddMarkup_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AddMarkup_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AddMarkup_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddMarkup_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AddMarkup_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddMarkup_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AddMarkup_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AddMarkup_Type'):
        super(AddMarkup_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddMarkup_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AddMarkup_Type', fromsubclass_=False, pretty_print=True):
        super(AddMarkup_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AddMarkup_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AddMarkup_Type


class ViewMarkup_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ViewMarkup_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ViewMarkup_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ViewMarkup_Type.subclass:
            return ViewMarkup_Type.subclass(*args_, **kwargs_)
        else:
            return ViewMarkup_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ViewMarkup_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ViewMarkup_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ViewMarkup_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ViewMarkup_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ViewMarkup_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ViewMarkup_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ViewMarkup_Type'):
        super(ViewMarkup_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ViewMarkup_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ViewMarkup_Type', fromsubclass_=False, pretty_print=True):
        super(ViewMarkup_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ViewMarkup_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ViewMarkup_Type


class PreviewQuality_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PreviewQuality_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PreviewQuality_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PreviewQuality_Type.subclass:
            return PreviewQuality_Type.subclass(*args_, **kwargs_)
        else:
            return PreviewQuality_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PreviewQuality_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PreviewQuality_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PreviewQuality_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PreviewQuality_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PreviewQuality_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PreviewQuality_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PreviewQuality_Type'):
        super(PreviewQuality_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PreviewQuality_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PreviewQuality_Type', fromsubclass_=False, pretty_print=True):
        super(PreviewQuality_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PreviewQuality_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PreviewQuality_Type


class PreviewScope_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PreviewScope_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PreviewScope_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PreviewScope_Type.subclass:
            return PreviewScope_Type.subclass(*args_, **kwargs_)
        else:
            return PreviewScope_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PreviewScope_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PreviewScope_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PreviewScope_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PreviewScope_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PreviewScope_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PreviewScope_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PreviewScope_Type'):
        super(PreviewScope_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PreviewScope_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PreviewScope_Type', fromsubclass_=False, pretty_print=True):
        super(PreviewScope_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PreviewScope_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PreviewScope_Type


class DocLangID_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DocLangID_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocLangID_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocLangID_Type.subclass:
            return DocLangID_Type.subclass(*args_, **kwargs_)
        else:
            return DocLangID_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DocLangID_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DocLangID_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocLangID_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DocLangID_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocLangID_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DocLangID_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DocLangID_Type'):
        super(DocLangID_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocLangID_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DocLangID_Type', fromsubclass_=False, pretty_print=True):
        super(DocLangID_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DocLangID_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DocLangID_Type


class TextFlags_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TextFlags_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextFlags_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextFlags_Type.subclass:
            return TextFlags_Type.subclass(*args_, **kwargs_)
        else:
            return TextFlags_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TextFlags_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextFlags_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextFlags_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextFlags_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextFlags_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextFlags_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextFlags_Type'):
        super(TextFlags_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextFlags_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextFlags_Type', fromsubclass_=False, pretty_print=True):
        super(TextFlags_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TextFlags_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TextFlags_Type


class DocExProps_Type(XPropsCell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = XPropsCell_Type
    def __init__(self, XProp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DocExProps_Type, self).__init__(XProp,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocExProps_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocExProps_Type.subclass:
            return DocExProps_Type.subclass(*args_, **kwargs_)
        else:
            return DocExProps_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (
            super(DocExProps_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DocExProps_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocExProps_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DocExProps_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocExProps_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DocExProps_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DocExProps_Type'):
        super(DocExProps_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocExProps_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DocExProps_Type', fromsubclass_=False, pretty_print=True):
        super(DocExProps_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DocExProps_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DocExProps_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DocExProps_Type


class Image_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, Gamma=None, Contrast=None, Brightness=None, Sharpen=None, Blur=None, Denoise=None, Transparency=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Image_Type, self).__init__(Del,  **kwargs_)
        if Gamma is None:
            self.Gamma = []
        else:
            self.Gamma = Gamma
        self.Gamma_nsprefix_ = None
        if Contrast is None:
            self.Contrast = []
        else:
            self.Contrast = Contrast
        self.Contrast_nsprefix_ = None
        if Brightness is None:
            self.Brightness = []
        else:
            self.Brightness = Brightness
        self.Brightness_nsprefix_ = None
        if Sharpen is None:
            self.Sharpen = []
        else:
            self.Sharpen = Sharpen
        self.Sharpen_nsprefix_ = None
        if Blur is None:
            self.Blur = []
        else:
            self.Blur = Blur
        self.Blur_nsprefix_ = None
        if Denoise is None:
            self.Denoise = []
        else:
            self.Denoise = Denoise
        self.Denoise_nsprefix_ = None
        if Transparency is None:
            self.Transparency = []
        else:
            self.Transparency = Transparency
        self.Transparency_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Image_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Image_Type.subclass:
            return Image_Type.subclass(*args_, **kwargs_)
        else:
            return Image_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Gamma(self):
        return self.Gamma
    def set_Gamma(self, Gamma):
        self.Gamma = Gamma
    def add_Gamma(self, value):
        self.Gamma.append(value)
    def insert_Gamma_at(self, index, value):
        self.Gamma.insert(index, value)
    def replace_Gamma_at(self, index, value):
        self.Gamma[index] = value
    def get_Contrast(self):
        return self.Contrast
    def set_Contrast(self, Contrast):
        self.Contrast = Contrast
    def add_Contrast(self, value):
        self.Contrast.append(value)
    def insert_Contrast_at(self, index, value):
        self.Contrast.insert(index, value)
    def replace_Contrast_at(self, index, value):
        self.Contrast[index] = value
    def get_Brightness(self):
        return self.Brightness
    def set_Brightness(self, Brightness):
        self.Brightness = Brightness
    def add_Brightness(self, value):
        self.Brightness.append(value)
    def insert_Brightness_at(self, index, value):
        self.Brightness.insert(index, value)
    def replace_Brightness_at(self, index, value):
        self.Brightness[index] = value
    def get_Sharpen(self):
        return self.Sharpen
    def set_Sharpen(self, Sharpen):
        self.Sharpen = Sharpen
    def add_Sharpen(self, value):
        self.Sharpen.append(value)
    def insert_Sharpen_at(self, index, value):
        self.Sharpen.insert(index, value)
    def replace_Sharpen_at(self, index, value):
        self.Sharpen[index] = value
    def get_Blur(self):
        return self.Blur
    def set_Blur(self, Blur):
        self.Blur = Blur
    def add_Blur(self, value):
        self.Blur.append(value)
    def insert_Blur_at(self, index, value):
        self.Blur.insert(index, value)
    def replace_Blur_at(self, index, value):
        self.Blur[index] = value
    def get_Denoise(self):
        return self.Denoise
    def set_Denoise(self, Denoise):
        self.Denoise = Denoise
    def add_Denoise(self, value):
        self.Denoise.append(value)
    def insert_Denoise_at(self, index, value):
        self.Denoise.insert(index, value)
    def replace_Denoise_at(self, index, value):
        self.Denoise[index] = value
    def get_Transparency(self):
        return self.Transparency
    def set_Transparency(self, Transparency):
        self.Transparency = Transparency
    def add_Transparency(self, value):
        self.Transparency.append(value)
    def insert_Transparency_at(self, index, value):
        self.Transparency.insert(index, value)
    def replace_Transparency_at(self, index, value):
        self.Transparency[index] = value
    def hasContent_(self):
        if (
            self.Gamma or
            self.Contrast or
            self.Brightness or
            self.Sharpen or
            self.Blur or
            self.Denoise or
            self.Transparency or
            super(Image_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Image_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Image_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Image_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Image_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Image_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Image_Type'):
        super(Image_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Image_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Image_Type', fromsubclass_=False, pretty_print=True):
        super(Image_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Gamma_ in self.Gamma:
            namespaceprefix_ = self.Gamma_nsprefix_ + ':' if (UseCapturedNS_ and self.Gamma_nsprefix_) else ''
            Gamma_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Gamma', pretty_print=pretty_print)
        for Contrast_ in self.Contrast:
            namespaceprefix_ = self.Contrast_nsprefix_ + ':' if (UseCapturedNS_ and self.Contrast_nsprefix_) else ''
            Contrast_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Contrast', pretty_print=pretty_print)
        for Brightness_ in self.Brightness:
            namespaceprefix_ = self.Brightness_nsprefix_ + ':' if (UseCapturedNS_ and self.Brightness_nsprefix_) else ''
            Brightness_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Brightness', pretty_print=pretty_print)
        for Sharpen_ in self.Sharpen:
            namespaceprefix_ = self.Sharpen_nsprefix_ + ':' if (UseCapturedNS_ and self.Sharpen_nsprefix_) else ''
            Sharpen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Sharpen', pretty_print=pretty_print)
        for Blur_ in self.Blur:
            namespaceprefix_ = self.Blur_nsprefix_ + ':' if (UseCapturedNS_ and self.Blur_nsprefix_) else ''
            Blur_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Blur', pretty_print=pretty_print)
        for Denoise_ in self.Denoise:
            namespaceprefix_ = self.Denoise_nsprefix_ + ':' if (UseCapturedNS_ and self.Denoise_nsprefix_) else ''
            Denoise_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Denoise', pretty_print=pretty_print)
        for Transparency_ in self.Transparency:
            namespaceprefix_ = self.Transparency_nsprefix_ + ':' if (UseCapturedNS_ and self.Transparency_nsprefix_) else ''
            Transparency_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Transparency', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Image_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Gamma':
            obj_ = Gamma_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Gamma.append(obj_)
            obj_.original_tagname_ = 'Gamma'
        elif nodeName_ == 'Contrast':
            obj_ = Contrast_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Contrast.append(obj_)
            obj_.original_tagname_ = 'Contrast'
        elif nodeName_ == 'Brightness':
            obj_ = Brightness_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Brightness.append(obj_)
            obj_.original_tagname_ = 'Brightness'
        elif nodeName_ == 'Sharpen':
            obj_ = Sharpen_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Sharpen.append(obj_)
            obj_.original_tagname_ = 'Sharpen'
        elif nodeName_ == 'Blur':
            obj_ = Blur_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Blur.append(obj_)
            obj_.original_tagname_ = 'Blur'
        elif nodeName_ == 'Denoise':
            obj_ = Denoise_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Denoise.append(obj_)
            obj_.original_tagname_ = 'Denoise'
        elif nodeName_ == 'Transparency':
            obj_ = Transparency_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Transparency.append(obj_)
            obj_.original_tagname_ = 'Transparency'
        super(Image_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Image_Type


class Gamma_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Gamma_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Gamma_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Gamma_Type.subclass:
            return Gamma_Type.subclass(*args_, **kwargs_)
        else:
            return Gamma_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Gamma_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Gamma_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Gamma_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Gamma_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Gamma_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Gamma_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Gamma_Type'):
        super(Gamma_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Gamma_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Gamma_Type', fromsubclass_=False, pretty_print=True):
        super(Gamma_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Gamma_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Gamma_Type


class Contrast_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Contrast_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Contrast_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Contrast_Type.subclass:
            return Contrast_Type.subclass(*args_, **kwargs_)
        else:
            return Contrast_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Contrast_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Contrast_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Contrast_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Contrast_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Contrast_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Contrast_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Contrast_Type'):
        super(Contrast_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Contrast_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Contrast_Type', fromsubclass_=False, pretty_print=True):
        super(Contrast_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Contrast_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Contrast_Type


class Brightness_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Brightness_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Brightness_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Brightness_Type.subclass:
            return Brightness_Type.subclass(*args_, **kwargs_)
        else:
            return Brightness_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Brightness_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Brightness_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Brightness_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Brightness_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Brightness_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Brightness_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Brightness_Type'):
        super(Brightness_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Brightness_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Brightness_Type', fromsubclass_=False, pretty_print=True):
        super(Brightness_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Brightness_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Brightness_Type


class Sharpen_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Sharpen_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Sharpen_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Sharpen_Type.subclass:
            return Sharpen_Type.subclass(*args_, **kwargs_)
        else:
            return Sharpen_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Sharpen_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Sharpen_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Sharpen_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Sharpen_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Sharpen_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Sharpen_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Sharpen_Type'):
        super(Sharpen_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Sharpen_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Sharpen_Type', fromsubclass_=False, pretty_print=True):
        super(Sharpen_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Sharpen_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Sharpen_Type


class Blur_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Blur_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Blur_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Blur_Type.subclass:
            return Blur_Type.subclass(*args_, **kwargs_)
        else:
            return Blur_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Blur_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Blur_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Blur_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Blur_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Blur_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Blur_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Blur_Type'):
        super(Blur_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Blur_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Blur_Type', fromsubclass_=False, pretty_print=True):
        super(Blur_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Blur_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Blur_Type


class Denoise_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Denoise_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Denoise_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Denoise_Type.subclass:
            return Denoise_Type.subclass(*args_, **kwargs_)
        else:
            return Denoise_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Denoise_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Denoise_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Denoise_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Denoise_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Denoise_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Denoise_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Denoise_Type'):
        super(Denoise_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Denoise_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Denoise_Type', fromsubclass_=False, pretty_print=True):
        super(Denoise_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Denoise_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Denoise_Type


class Transparency_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Transparency_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Transparency_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Transparency_Type.subclass:
            return Transparency_Type.subclass(*args_, **kwargs_)
        else:
            return Transparency_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Transparency_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Transparency_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Transparency_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Transparency_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Transparency_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Transparency_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Transparency_Type'):
        super(Transparency_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Transparency_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Transparency_Type', fromsubclass_=False, pretty_print=True):
        super(Transparency_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Transparency_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Transparency_Type


class Group_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, SelectMode=None, DisplayMode=None, IsDropTarget=None, IsSnapTarget=None, IsTextEditTarget=None, DontMoveChildren=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Group_Type, self).__init__(Del,  **kwargs_)
        if SelectMode is None:
            self.SelectMode = []
        else:
            self.SelectMode = SelectMode
        self.SelectMode_nsprefix_ = None
        if DisplayMode is None:
            self.DisplayMode = []
        else:
            self.DisplayMode = DisplayMode
        self.DisplayMode_nsprefix_ = None
        if IsDropTarget is None:
            self.IsDropTarget = []
        else:
            self.IsDropTarget = IsDropTarget
        self.IsDropTarget_nsprefix_ = None
        if IsSnapTarget is None:
            self.IsSnapTarget = []
        else:
            self.IsSnapTarget = IsSnapTarget
        self.IsSnapTarget_nsprefix_ = None
        if IsTextEditTarget is None:
            self.IsTextEditTarget = []
        else:
            self.IsTextEditTarget = IsTextEditTarget
        self.IsTextEditTarget_nsprefix_ = None
        if DontMoveChildren is None:
            self.DontMoveChildren = []
        else:
            self.DontMoveChildren = DontMoveChildren
        self.DontMoveChildren_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Group_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Group_Type.subclass:
            return Group_Type.subclass(*args_, **kwargs_)
        else:
            return Group_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SelectMode(self):
        return self.SelectMode
    def set_SelectMode(self, SelectMode):
        self.SelectMode = SelectMode
    def add_SelectMode(self, value):
        self.SelectMode.append(value)
    def insert_SelectMode_at(self, index, value):
        self.SelectMode.insert(index, value)
    def replace_SelectMode_at(self, index, value):
        self.SelectMode[index] = value
    def get_DisplayMode(self):
        return self.DisplayMode
    def set_DisplayMode(self, DisplayMode):
        self.DisplayMode = DisplayMode
    def add_DisplayMode(self, value):
        self.DisplayMode.append(value)
    def insert_DisplayMode_at(self, index, value):
        self.DisplayMode.insert(index, value)
    def replace_DisplayMode_at(self, index, value):
        self.DisplayMode[index] = value
    def get_IsDropTarget(self):
        return self.IsDropTarget
    def set_IsDropTarget(self, IsDropTarget):
        self.IsDropTarget = IsDropTarget
    def add_IsDropTarget(self, value):
        self.IsDropTarget.append(value)
    def insert_IsDropTarget_at(self, index, value):
        self.IsDropTarget.insert(index, value)
    def replace_IsDropTarget_at(self, index, value):
        self.IsDropTarget[index] = value
    def get_IsSnapTarget(self):
        return self.IsSnapTarget
    def set_IsSnapTarget(self, IsSnapTarget):
        self.IsSnapTarget = IsSnapTarget
    def add_IsSnapTarget(self, value):
        self.IsSnapTarget.append(value)
    def insert_IsSnapTarget_at(self, index, value):
        self.IsSnapTarget.insert(index, value)
    def replace_IsSnapTarget_at(self, index, value):
        self.IsSnapTarget[index] = value
    def get_IsTextEditTarget(self):
        return self.IsTextEditTarget
    def set_IsTextEditTarget(self, IsTextEditTarget):
        self.IsTextEditTarget = IsTextEditTarget
    def add_IsTextEditTarget(self, value):
        self.IsTextEditTarget.append(value)
    def insert_IsTextEditTarget_at(self, index, value):
        self.IsTextEditTarget.insert(index, value)
    def replace_IsTextEditTarget_at(self, index, value):
        self.IsTextEditTarget[index] = value
    def get_DontMoveChildren(self):
        return self.DontMoveChildren
    def set_DontMoveChildren(self, DontMoveChildren):
        self.DontMoveChildren = DontMoveChildren
    def add_DontMoveChildren(self, value):
        self.DontMoveChildren.append(value)
    def insert_DontMoveChildren_at(self, index, value):
        self.DontMoveChildren.insert(index, value)
    def replace_DontMoveChildren_at(self, index, value):
        self.DontMoveChildren[index] = value
    def hasContent_(self):
        if (
            self.SelectMode or
            self.DisplayMode or
            self.IsDropTarget or
            self.IsSnapTarget or
            self.IsTextEditTarget or
            self.DontMoveChildren or
            super(Group_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Group_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Group_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Group_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Group_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Group_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Group_Type'):
        super(Group_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Group_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Group_Type', fromsubclass_=False, pretty_print=True):
        super(Group_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SelectMode_ in self.SelectMode:
            namespaceprefix_ = self.SelectMode_nsprefix_ + ':' if (UseCapturedNS_ and self.SelectMode_nsprefix_) else ''
            SelectMode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SelectMode', pretty_print=pretty_print)
        for DisplayMode_ in self.DisplayMode:
            namespaceprefix_ = self.DisplayMode_nsprefix_ + ':' if (UseCapturedNS_ and self.DisplayMode_nsprefix_) else ''
            DisplayMode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DisplayMode', pretty_print=pretty_print)
        for IsDropTarget_ in self.IsDropTarget:
            namespaceprefix_ = self.IsDropTarget_nsprefix_ + ':' if (UseCapturedNS_ and self.IsDropTarget_nsprefix_) else ''
            IsDropTarget_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IsDropTarget', pretty_print=pretty_print)
        for IsSnapTarget_ in self.IsSnapTarget:
            namespaceprefix_ = self.IsSnapTarget_nsprefix_ + ':' if (UseCapturedNS_ and self.IsSnapTarget_nsprefix_) else ''
            IsSnapTarget_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IsSnapTarget', pretty_print=pretty_print)
        for IsTextEditTarget_ in self.IsTextEditTarget:
            namespaceprefix_ = self.IsTextEditTarget_nsprefix_ + ':' if (UseCapturedNS_ and self.IsTextEditTarget_nsprefix_) else ''
            IsTextEditTarget_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IsTextEditTarget', pretty_print=pretty_print)
        for DontMoveChildren_ in self.DontMoveChildren:
            namespaceprefix_ = self.DontMoveChildren_nsprefix_ + ':' if (UseCapturedNS_ and self.DontMoveChildren_nsprefix_) else ''
            DontMoveChildren_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DontMoveChildren', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Group_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SelectMode':
            obj_ = SelectMode_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SelectMode.append(obj_)
            obj_.original_tagname_ = 'SelectMode'
        elif nodeName_ == 'DisplayMode':
            obj_ = DisplayMode_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DisplayMode.append(obj_)
            obj_.original_tagname_ = 'DisplayMode'
        elif nodeName_ == 'IsDropTarget':
            obj_ = IsDropTarget_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IsDropTarget.append(obj_)
            obj_.original_tagname_ = 'IsDropTarget'
        elif nodeName_ == 'IsSnapTarget':
            obj_ = IsSnapTarget_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IsSnapTarget.append(obj_)
            obj_.original_tagname_ = 'IsSnapTarget'
        elif nodeName_ == 'IsTextEditTarget':
            obj_ = IsTextEditTarget_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IsTextEditTarget.append(obj_)
            obj_.original_tagname_ = 'IsTextEditTarget'
        elif nodeName_ == 'DontMoveChildren':
            obj_ = DontMoveChildren_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DontMoveChildren.append(obj_)
            obj_.original_tagname_ = 'DontMoveChildren'
        super(Group_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Group_Type


class SelectMode_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SelectMode_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SelectMode_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SelectMode_Type.subclass:
            return SelectMode_Type.subclass(*args_, **kwargs_)
        else:
            return SelectMode_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(SelectMode_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SelectMode_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SelectMode_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SelectMode_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectMode_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SelectMode_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SelectMode_Type'):
        super(SelectMode_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectMode_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SelectMode_Type', fromsubclass_=False, pretty_print=True):
        super(SelectMode_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SelectMode_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SelectMode_Type


class DisplayMode_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DisplayMode_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DisplayMode_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DisplayMode_Type.subclass:
            return DisplayMode_Type.subclass(*args_, **kwargs_)
        else:
            return DisplayMode_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DisplayMode_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DisplayMode_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DisplayMode_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DisplayMode_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DisplayMode_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DisplayMode_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DisplayMode_Type'):
        super(DisplayMode_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DisplayMode_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DisplayMode_Type', fromsubclass_=False, pretty_print=True):
        super(DisplayMode_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DisplayMode_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DisplayMode_Type


class IsDropTarget_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IsDropTarget_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IsDropTarget_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IsDropTarget_Type.subclass:
            return IsDropTarget_Type.subclass(*args_, **kwargs_)
        else:
            return IsDropTarget_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(IsDropTarget_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IsDropTarget_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IsDropTarget_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IsDropTarget_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IsDropTarget_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IsDropTarget_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IsDropTarget_Type'):
        super(IsDropTarget_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IsDropTarget_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IsDropTarget_Type', fromsubclass_=False, pretty_print=True):
        super(IsDropTarget_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IsDropTarget_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class IsDropTarget_Type


class IsSnapTarget_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IsSnapTarget_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IsSnapTarget_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IsSnapTarget_Type.subclass:
            return IsSnapTarget_Type.subclass(*args_, **kwargs_)
        else:
            return IsSnapTarget_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(IsSnapTarget_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IsSnapTarget_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IsSnapTarget_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IsSnapTarget_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IsSnapTarget_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IsSnapTarget_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IsSnapTarget_Type'):
        super(IsSnapTarget_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IsSnapTarget_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IsSnapTarget_Type', fromsubclass_=False, pretty_print=True):
        super(IsSnapTarget_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IsSnapTarget_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class IsSnapTarget_Type


class IsTextEditTarget_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IsTextEditTarget_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IsTextEditTarget_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IsTextEditTarget_Type.subclass:
            return IsTextEditTarget_Type.subclass(*args_, **kwargs_)
        else:
            return IsTextEditTarget_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(IsTextEditTarget_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IsTextEditTarget_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IsTextEditTarget_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IsTextEditTarget_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IsTextEditTarget_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IsTextEditTarget_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IsTextEditTarget_Type'):
        super(IsTextEditTarget_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IsTextEditTarget_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IsTextEditTarget_Type', fromsubclass_=False, pretty_print=True):
        super(IsTextEditTarget_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IsTextEditTarget_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class IsTextEditTarget_Type


class DontMoveChildren_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DontMoveChildren_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DontMoveChildren_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DontMoveChildren_Type.subclass:
            return DontMoveChildren_Type.subclass(*args_, **kwargs_)
        else:
            return DontMoveChildren_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DontMoveChildren_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DontMoveChildren_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DontMoveChildren_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DontMoveChildren_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DontMoveChildren_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DontMoveChildren_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DontMoveChildren_Type'):
        super(DontMoveChildren_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DontMoveChildren_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DontMoveChildren_Type', fromsubclass_=False, pretty_print=True):
        super(DontMoveChildren_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DontMoveChildren_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DontMoveChildren_Type


class Layout_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, ShapePermeableX=None, ShapePermeableY=None, ShapePermeablePlace=None, ShapeFixedCode=None, ShapePlowCode=None, ShapeRouteStyle=None, ShapePlaceStyle=None, ConFixedCode=None, ConLineJumpCode=None, ConLineJumpStyle=None, ConLineJumpDirX=None, ConLineJumpDirY=None, ShapePlaceFlip=None, ConLineRouteExt=None, ShapeSplit=None, ShapeSplittable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Layout_Type, self).__init__(Del,  **kwargs_)
        if ShapePermeableX is None:
            self.ShapePermeableX = []
        else:
            self.ShapePermeableX = ShapePermeableX
        self.ShapePermeableX_nsprefix_ = None
        if ShapePermeableY is None:
            self.ShapePermeableY = []
        else:
            self.ShapePermeableY = ShapePermeableY
        self.ShapePermeableY_nsprefix_ = None
        if ShapePermeablePlace is None:
            self.ShapePermeablePlace = []
        else:
            self.ShapePermeablePlace = ShapePermeablePlace
        self.ShapePermeablePlace_nsprefix_ = None
        if ShapeFixedCode is None:
            self.ShapeFixedCode = []
        else:
            self.ShapeFixedCode = ShapeFixedCode
        self.ShapeFixedCode_nsprefix_ = None
        if ShapePlowCode is None:
            self.ShapePlowCode = []
        else:
            self.ShapePlowCode = ShapePlowCode
        self.ShapePlowCode_nsprefix_ = None
        if ShapeRouteStyle is None:
            self.ShapeRouteStyle = []
        else:
            self.ShapeRouteStyle = ShapeRouteStyle
        self.ShapeRouteStyle_nsprefix_ = None
        if ShapePlaceStyle is None:
            self.ShapePlaceStyle = []
        else:
            self.ShapePlaceStyle = ShapePlaceStyle
        self.ShapePlaceStyle_nsprefix_ = None
        if ConFixedCode is None:
            self.ConFixedCode = []
        else:
            self.ConFixedCode = ConFixedCode
        self.ConFixedCode_nsprefix_ = None
        if ConLineJumpCode is None:
            self.ConLineJumpCode = []
        else:
            self.ConLineJumpCode = ConLineJumpCode
        self.ConLineJumpCode_nsprefix_ = None
        if ConLineJumpStyle is None:
            self.ConLineJumpStyle = []
        else:
            self.ConLineJumpStyle = ConLineJumpStyle
        self.ConLineJumpStyle_nsprefix_ = None
        if ConLineJumpDirX is None:
            self.ConLineJumpDirX = []
        else:
            self.ConLineJumpDirX = ConLineJumpDirX
        self.ConLineJumpDirX_nsprefix_ = None
        if ConLineJumpDirY is None:
            self.ConLineJumpDirY = []
        else:
            self.ConLineJumpDirY = ConLineJumpDirY
        self.ConLineJumpDirY_nsprefix_ = None
        if ShapePlaceFlip is None:
            self.ShapePlaceFlip = []
        else:
            self.ShapePlaceFlip = ShapePlaceFlip
        self.ShapePlaceFlip_nsprefix_ = None
        if ConLineRouteExt is None:
            self.ConLineRouteExt = []
        else:
            self.ConLineRouteExt = ConLineRouteExt
        self.ConLineRouteExt_nsprefix_ = None
        if ShapeSplit is None:
            self.ShapeSplit = []
        else:
            self.ShapeSplit = ShapeSplit
        self.ShapeSplit_nsprefix_ = None
        if ShapeSplittable is None:
            self.ShapeSplittable = []
        else:
            self.ShapeSplittable = ShapeSplittable
        self.ShapeSplittable_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Layout_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Layout_Type.subclass:
            return Layout_Type.subclass(*args_, **kwargs_)
        else:
            return Layout_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ShapePermeableX(self):
        return self.ShapePermeableX
    def set_ShapePermeableX(self, ShapePermeableX):
        self.ShapePermeableX = ShapePermeableX
    def add_ShapePermeableX(self, value):
        self.ShapePermeableX.append(value)
    def insert_ShapePermeableX_at(self, index, value):
        self.ShapePermeableX.insert(index, value)
    def replace_ShapePermeableX_at(self, index, value):
        self.ShapePermeableX[index] = value
    def get_ShapePermeableY(self):
        return self.ShapePermeableY
    def set_ShapePermeableY(self, ShapePermeableY):
        self.ShapePermeableY = ShapePermeableY
    def add_ShapePermeableY(self, value):
        self.ShapePermeableY.append(value)
    def insert_ShapePermeableY_at(self, index, value):
        self.ShapePermeableY.insert(index, value)
    def replace_ShapePermeableY_at(self, index, value):
        self.ShapePermeableY[index] = value
    def get_ShapePermeablePlace(self):
        return self.ShapePermeablePlace
    def set_ShapePermeablePlace(self, ShapePermeablePlace):
        self.ShapePermeablePlace = ShapePermeablePlace
    def add_ShapePermeablePlace(self, value):
        self.ShapePermeablePlace.append(value)
    def insert_ShapePermeablePlace_at(self, index, value):
        self.ShapePermeablePlace.insert(index, value)
    def replace_ShapePermeablePlace_at(self, index, value):
        self.ShapePermeablePlace[index] = value
    def get_ShapeFixedCode(self):
        return self.ShapeFixedCode
    def set_ShapeFixedCode(self, ShapeFixedCode):
        self.ShapeFixedCode = ShapeFixedCode
    def add_ShapeFixedCode(self, value):
        self.ShapeFixedCode.append(value)
    def insert_ShapeFixedCode_at(self, index, value):
        self.ShapeFixedCode.insert(index, value)
    def replace_ShapeFixedCode_at(self, index, value):
        self.ShapeFixedCode[index] = value
    def get_ShapePlowCode(self):
        return self.ShapePlowCode
    def set_ShapePlowCode(self, ShapePlowCode):
        self.ShapePlowCode = ShapePlowCode
    def add_ShapePlowCode(self, value):
        self.ShapePlowCode.append(value)
    def insert_ShapePlowCode_at(self, index, value):
        self.ShapePlowCode.insert(index, value)
    def replace_ShapePlowCode_at(self, index, value):
        self.ShapePlowCode[index] = value
    def get_ShapeRouteStyle(self):
        return self.ShapeRouteStyle
    def set_ShapeRouteStyle(self, ShapeRouteStyle):
        self.ShapeRouteStyle = ShapeRouteStyle
    def add_ShapeRouteStyle(self, value):
        self.ShapeRouteStyle.append(value)
    def insert_ShapeRouteStyle_at(self, index, value):
        self.ShapeRouteStyle.insert(index, value)
    def replace_ShapeRouteStyle_at(self, index, value):
        self.ShapeRouteStyle[index] = value
    def get_ShapePlaceStyle(self):
        return self.ShapePlaceStyle
    def set_ShapePlaceStyle(self, ShapePlaceStyle):
        self.ShapePlaceStyle = ShapePlaceStyle
    def add_ShapePlaceStyle(self, value):
        self.ShapePlaceStyle.append(value)
    def insert_ShapePlaceStyle_at(self, index, value):
        self.ShapePlaceStyle.insert(index, value)
    def replace_ShapePlaceStyle_at(self, index, value):
        self.ShapePlaceStyle[index] = value
    def get_ConFixedCode(self):
        return self.ConFixedCode
    def set_ConFixedCode(self, ConFixedCode):
        self.ConFixedCode = ConFixedCode
    def add_ConFixedCode(self, value):
        self.ConFixedCode.append(value)
    def insert_ConFixedCode_at(self, index, value):
        self.ConFixedCode.insert(index, value)
    def replace_ConFixedCode_at(self, index, value):
        self.ConFixedCode[index] = value
    def get_ConLineJumpCode(self):
        return self.ConLineJumpCode
    def set_ConLineJumpCode(self, ConLineJumpCode):
        self.ConLineJumpCode = ConLineJumpCode
    def add_ConLineJumpCode(self, value):
        self.ConLineJumpCode.append(value)
    def insert_ConLineJumpCode_at(self, index, value):
        self.ConLineJumpCode.insert(index, value)
    def replace_ConLineJumpCode_at(self, index, value):
        self.ConLineJumpCode[index] = value
    def get_ConLineJumpStyle(self):
        return self.ConLineJumpStyle
    def set_ConLineJumpStyle(self, ConLineJumpStyle):
        self.ConLineJumpStyle = ConLineJumpStyle
    def add_ConLineJumpStyle(self, value):
        self.ConLineJumpStyle.append(value)
    def insert_ConLineJumpStyle_at(self, index, value):
        self.ConLineJumpStyle.insert(index, value)
    def replace_ConLineJumpStyle_at(self, index, value):
        self.ConLineJumpStyle[index] = value
    def get_ConLineJumpDirX(self):
        return self.ConLineJumpDirX
    def set_ConLineJumpDirX(self, ConLineJumpDirX):
        self.ConLineJumpDirX = ConLineJumpDirX
    def add_ConLineJumpDirX(self, value):
        self.ConLineJumpDirX.append(value)
    def insert_ConLineJumpDirX_at(self, index, value):
        self.ConLineJumpDirX.insert(index, value)
    def replace_ConLineJumpDirX_at(self, index, value):
        self.ConLineJumpDirX[index] = value
    def get_ConLineJumpDirY(self):
        return self.ConLineJumpDirY
    def set_ConLineJumpDirY(self, ConLineJumpDirY):
        self.ConLineJumpDirY = ConLineJumpDirY
    def add_ConLineJumpDirY(self, value):
        self.ConLineJumpDirY.append(value)
    def insert_ConLineJumpDirY_at(self, index, value):
        self.ConLineJumpDirY.insert(index, value)
    def replace_ConLineJumpDirY_at(self, index, value):
        self.ConLineJumpDirY[index] = value
    def get_ShapePlaceFlip(self):
        return self.ShapePlaceFlip
    def set_ShapePlaceFlip(self, ShapePlaceFlip):
        self.ShapePlaceFlip = ShapePlaceFlip
    def add_ShapePlaceFlip(self, value):
        self.ShapePlaceFlip.append(value)
    def insert_ShapePlaceFlip_at(self, index, value):
        self.ShapePlaceFlip.insert(index, value)
    def replace_ShapePlaceFlip_at(self, index, value):
        self.ShapePlaceFlip[index] = value
    def get_ConLineRouteExt(self):
        return self.ConLineRouteExt
    def set_ConLineRouteExt(self, ConLineRouteExt):
        self.ConLineRouteExt = ConLineRouteExt
    def add_ConLineRouteExt(self, value):
        self.ConLineRouteExt.append(value)
    def insert_ConLineRouteExt_at(self, index, value):
        self.ConLineRouteExt.insert(index, value)
    def replace_ConLineRouteExt_at(self, index, value):
        self.ConLineRouteExt[index] = value
    def get_ShapeSplit(self):
        return self.ShapeSplit
    def set_ShapeSplit(self, ShapeSplit):
        self.ShapeSplit = ShapeSplit
    def add_ShapeSplit(self, value):
        self.ShapeSplit.append(value)
    def insert_ShapeSplit_at(self, index, value):
        self.ShapeSplit.insert(index, value)
    def replace_ShapeSplit_at(self, index, value):
        self.ShapeSplit[index] = value
    def get_ShapeSplittable(self):
        return self.ShapeSplittable
    def set_ShapeSplittable(self, ShapeSplittable):
        self.ShapeSplittable = ShapeSplittable
    def add_ShapeSplittable(self, value):
        self.ShapeSplittable.append(value)
    def insert_ShapeSplittable_at(self, index, value):
        self.ShapeSplittable.insert(index, value)
    def replace_ShapeSplittable_at(self, index, value):
        self.ShapeSplittable[index] = value
    def hasContent_(self):
        if (
            self.ShapePermeableX or
            self.ShapePermeableY or
            self.ShapePermeablePlace or
            self.ShapeFixedCode or
            self.ShapePlowCode or
            self.ShapeRouteStyle or
            self.ShapePlaceStyle or
            self.ConFixedCode or
            self.ConLineJumpCode or
            self.ConLineJumpStyle or
            self.ConLineJumpDirX or
            self.ConLineJumpDirY or
            self.ShapePlaceFlip or
            self.ConLineRouteExt or
            self.ShapeSplit or
            self.ShapeSplittable or
            super(Layout_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Layout_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Layout_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Layout_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Layout_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Layout_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Layout_Type'):
        super(Layout_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Layout_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Layout_Type', fromsubclass_=False, pretty_print=True):
        super(Layout_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ShapePermeableX_ in self.ShapePermeableX:
            namespaceprefix_ = self.ShapePermeableX_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapePermeableX_nsprefix_) else ''
            ShapePermeableX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapePermeableX', pretty_print=pretty_print)
        for ShapePermeableY_ in self.ShapePermeableY:
            namespaceprefix_ = self.ShapePermeableY_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapePermeableY_nsprefix_) else ''
            ShapePermeableY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapePermeableY', pretty_print=pretty_print)
        for ShapePermeablePlace_ in self.ShapePermeablePlace:
            namespaceprefix_ = self.ShapePermeablePlace_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapePermeablePlace_nsprefix_) else ''
            ShapePermeablePlace_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapePermeablePlace', pretty_print=pretty_print)
        for ShapeFixedCode_ in self.ShapeFixedCode:
            namespaceprefix_ = self.ShapeFixedCode_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapeFixedCode_nsprefix_) else ''
            ShapeFixedCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapeFixedCode', pretty_print=pretty_print)
        for ShapePlowCode_ in self.ShapePlowCode:
            namespaceprefix_ = self.ShapePlowCode_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapePlowCode_nsprefix_) else ''
            ShapePlowCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapePlowCode', pretty_print=pretty_print)
        for ShapeRouteStyle_ in self.ShapeRouteStyle:
            namespaceprefix_ = self.ShapeRouteStyle_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapeRouteStyle_nsprefix_) else ''
            ShapeRouteStyle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapeRouteStyle', pretty_print=pretty_print)
        for ShapePlaceStyle_ in self.ShapePlaceStyle:
            namespaceprefix_ = self.ShapePlaceStyle_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapePlaceStyle_nsprefix_) else ''
            ShapePlaceStyle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapePlaceStyle', pretty_print=pretty_print)
        for ConFixedCode_ in self.ConFixedCode:
            namespaceprefix_ = self.ConFixedCode_nsprefix_ + ':' if (UseCapturedNS_ and self.ConFixedCode_nsprefix_) else ''
            ConFixedCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ConFixedCode', pretty_print=pretty_print)
        for ConLineJumpCode_ in self.ConLineJumpCode:
            namespaceprefix_ = self.ConLineJumpCode_nsprefix_ + ':' if (UseCapturedNS_ and self.ConLineJumpCode_nsprefix_) else ''
            ConLineJumpCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ConLineJumpCode', pretty_print=pretty_print)
        for ConLineJumpStyle_ in self.ConLineJumpStyle:
            namespaceprefix_ = self.ConLineJumpStyle_nsprefix_ + ':' if (UseCapturedNS_ and self.ConLineJumpStyle_nsprefix_) else ''
            ConLineJumpStyle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ConLineJumpStyle', pretty_print=pretty_print)
        for ConLineJumpDirX_ in self.ConLineJumpDirX:
            namespaceprefix_ = self.ConLineJumpDirX_nsprefix_ + ':' if (UseCapturedNS_ and self.ConLineJumpDirX_nsprefix_) else ''
            ConLineJumpDirX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ConLineJumpDirX', pretty_print=pretty_print)
        for ConLineJumpDirY_ in self.ConLineJumpDirY:
            namespaceprefix_ = self.ConLineJumpDirY_nsprefix_ + ':' if (UseCapturedNS_ and self.ConLineJumpDirY_nsprefix_) else ''
            ConLineJumpDirY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ConLineJumpDirY', pretty_print=pretty_print)
        for ShapePlaceFlip_ in self.ShapePlaceFlip:
            namespaceprefix_ = self.ShapePlaceFlip_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapePlaceFlip_nsprefix_) else ''
            ShapePlaceFlip_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapePlaceFlip', pretty_print=pretty_print)
        for ConLineRouteExt_ in self.ConLineRouteExt:
            namespaceprefix_ = self.ConLineRouteExt_nsprefix_ + ':' if (UseCapturedNS_ and self.ConLineRouteExt_nsprefix_) else ''
            ConLineRouteExt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ConLineRouteExt', pretty_print=pretty_print)
        for ShapeSplit_ in self.ShapeSplit:
            namespaceprefix_ = self.ShapeSplit_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapeSplit_nsprefix_) else ''
            ShapeSplit_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapeSplit', pretty_print=pretty_print)
        for ShapeSplittable_ in self.ShapeSplittable:
            namespaceprefix_ = self.ShapeSplittable_nsprefix_ + ':' if (UseCapturedNS_ and self.ShapeSplittable_nsprefix_) else ''
            ShapeSplittable_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ShapeSplittable', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Layout_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ShapePermeableX':
            obj_ = ShapePermeableX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapePermeableX.append(obj_)
            obj_.original_tagname_ = 'ShapePermeableX'
        elif nodeName_ == 'ShapePermeableY':
            obj_ = ShapePermeableY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapePermeableY.append(obj_)
            obj_.original_tagname_ = 'ShapePermeableY'
        elif nodeName_ == 'ShapePermeablePlace':
            obj_ = ShapePermeablePlace_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapePermeablePlace.append(obj_)
            obj_.original_tagname_ = 'ShapePermeablePlace'
        elif nodeName_ == 'ShapeFixedCode':
            obj_ = ShapeFixedCode_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapeFixedCode.append(obj_)
            obj_.original_tagname_ = 'ShapeFixedCode'
        elif nodeName_ == 'ShapePlowCode':
            obj_ = ShapePlowCode_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapePlowCode.append(obj_)
            obj_.original_tagname_ = 'ShapePlowCode'
        elif nodeName_ == 'ShapeRouteStyle':
            obj_ = ShapeRouteStyle_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapeRouteStyle.append(obj_)
            obj_.original_tagname_ = 'ShapeRouteStyle'
        elif nodeName_ == 'ShapePlaceStyle':
            obj_ = ShapePlaceStyle_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapePlaceStyle.append(obj_)
            obj_.original_tagname_ = 'ShapePlaceStyle'
        elif nodeName_ == 'ConFixedCode':
            obj_ = ConFixedCode_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConFixedCode.append(obj_)
            obj_.original_tagname_ = 'ConFixedCode'
        elif nodeName_ == 'ConLineJumpCode':
            obj_ = ConLineJumpCode_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConLineJumpCode.append(obj_)
            obj_.original_tagname_ = 'ConLineJumpCode'
        elif nodeName_ == 'ConLineJumpStyle':
            obj_ = ConLineJumpStyle_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConLineJumpStyle.append(obj_)
            obj_.original_tagname_ = 'ConLineJumpStyle'
        elif nodeName_ == 'ConLineJumpDirX':
            obj_ = ConLineJumpDirX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConLineJumpDirX.append(obj_)
            obj_.original_tagname_ = 'ConLineJumpDirX'
        elif nodeName_ == 'ConLineJumpDirY':
            obj_ = ConLineJumpDirY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConLineJumpDirY.append(obj_)
            obj_.original_tagname_ = 'ConLineJumpDirY'
        elif nodeName_ == 'ShapePlaceFlip':
            obj_ = ShapePlaceFlip_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapePlaceFlip.append(obj_)
            obj_.original_tagname_ = 'ShapePlaceFlip'
        elif nodeName_ == 'ConLineRouteExt':
            obj_ = ConLineRouteExt_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConLineRouteExt.append(obj_)
            obj_.original_tagname_ = 'ConLineRouteExt'
        elif nodeName_ == 'ShapeSplit':
            obj_ = ShapeSplit_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapeSplit.append(obj_)
            obj_.original_tagname_ = 'ShapeSplit'
        elif nodeName_ == 'ShapeSplittable':
            obj_ = ShapeSplittable_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ShapeSplittable.append(obj_)
            obj_.original_tagname_ = 'ShapeSplittable'
        super(Layout_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Layout_Type


class ShapePermeableX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapePermeableX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapePermeableX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapePermeableX_Type.subclass:
            return ShapePermeableX_Type.subclass(*args_, **kwargs_)
        else:
            return ShapePermeableX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapePermeableX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapePermeableX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapePermeableX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapePermeableX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapePermeableX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapePermeableX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapePermeableX_Type'):
        super(ShapePermeableX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapePermeableX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapePermeableX_Type', fromsubclass_=False, pretty_print=True):
        super(ShapePermeableX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapePermeableX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapePermeableX_Type


class ShapePermeableY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapePermeableY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapePermeableY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapePermeableY_Type.subclass:
            return ShapePermeableY_Type.subclass(*args_, **kwargs_)
        else:
            return ShapePermeableY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapePermeableY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapePermeableY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapePermeableY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapePermeableY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapePermeableY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapePermeableY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapePermeableY_Type'):
        super(ShapePermeableY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapePermeableY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapePermeableY_Type', fromsubclass_=False, pretty_print=True):
        super(ShapePermeableY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapePermeableY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapePermeableY_Type


class ShapePermeablePlace_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapePermeablePlace_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapePermeablePlace_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapePermeablePlace_Type.subclass:
            return ShapePermeablePlace_Type.subclass(*args_, **kwargs_)
        else:
            return ShapePermeablePlace_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapePermeablePlace_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapePermeablePlace_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapePermeablePlace_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapePermeablePlace_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapePermeablePlace_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapePermeablePlace_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapePermeablePlace_Type'):
        super(ShapePermeablePlace_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapePermeablePlace_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapePermeablePlace_Type', fromsubclass_=False, pretty_print=True):
        super(ShapePermeablePlace_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapePermeablePlace_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapePermeablePlace_Type


class ShapeFixedCode_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapeFixedCode_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapeFixedCode_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapeFixedCode_Type.subclass:
            return ShapeFixedCode_Type.subclass(*args_, **kwargs_)
        else:
            return ShapeFixedCode_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapeFixedCode_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeFixedCode_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapeFixedCode_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapeFixedCode_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeFixedCode_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapeFixedCode_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapeFixedCode_Type'):
        super(ShapeFixedCode_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeFixedCode_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeFixedCode_Type', fromsubclass_=False, pretty_print=True):
        super(ShapeFixedCode_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapeFixedCode_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapeFixedCode_Type


class ShapePlowCode_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapePlowCode_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapePlowCode_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapePlowCode_Type.subclass:
            return ShapePlowCode_Type.subclass(*args_, **kwargs_)
        else:
            return ShapePlowCode_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapePlowCode_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapePlowCode_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapePlowCode_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapePlowCode_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapePlowCode_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapePlowCode_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapePlowCode_Type'):
        super(ShapePlowCode_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapePlowCode_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapePlowCode_Type', fromsubclass_=False, pretty_print=True):
        super(ShapePlowCode_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapePlowCode_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapePlowCode_Type


class ShapeRouteStyle_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapeRouteStyle_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapeRouteStyle_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapeRouteStyle_Type.subclass:
            return ShapeRouteStyle_Type.subclass(*args_, **kwargs_)
        else:
            return ShapeRouteStyle_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapeRouteStyle_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeRouteStyle_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapeRouteStyle_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapeRouteStyle_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeRouteStyle_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapeRouteStyle_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapeRouteStyle_Type'):
        super(ShapeRouteStyle_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeRouteStyle_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeRouteStyle_Type', fromsubclass_=False, pretty_print=True):
        super(ShapeRouteStyle_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapeRouteStyle_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapeRouteStyle_Type


class ShapePlaceStyle_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapePlaceStyle_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapePlaceStyle_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapePlaceStyle_Type.subclass:
            return ShapePlaceStyle_Type.subclass(*args_, **kwargs_)
        else:
            return ShapePlaceStyle_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapePlaceStyle_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapePlaceStyle_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapePlaceStyle_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapePlaceStyle_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapePlaceStyle_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapePlaceStyle_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapePlaceStyle_Type'):
        super(ShapePlaceStyle_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapePlaceStyle_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapePlaceStyle_Type', fromsubclass_=False, pretty_print=True):
        super(ShapePlaceStyle_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapePlaceStyle_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapePlaceStyle_Type


class ConFixedCode_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ConFixedCode_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConFixedCode_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConFixedCode_Type.subclass:
            return ConFixedCode_Type.subclass(*args_, **kwargs_)
        else:
            return ConFixedCode_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ConFixedCode_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConFixedCode_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConFixedCode_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConFixedCode_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConFixedCode_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConFixedCode_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConFixedCode_Type'):
        super(ConFixedCode_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConFixedCode_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConFixedCode_Type', fromsubclass_=False, pretty_print=True):
        super(ConFixedCode_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConFixedCode_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ConFixedCode_Type


class ConLineJumpCode_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ConLineJumpCode_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConLineJumpCode_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConLineJumpCode_Type.subclass:
            return ConLineJumpCode_Type.subclass(*args_, **kwargs_)
        else:
            return ConLineJumpCode_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ConLineJumpCode_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConLineJumpCode_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConLineJumpCode_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConLineJumpCode_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConLineJumpCode_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConLineJumpCode_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConLineJumpCode_Type'):
        super(ConLineJumpCode_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConLineJumpCode_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConLineJumpCode_Type', fromsubclass_=False, pretty_print=True):
        super(ConLineJumpCode_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConLineJumpCode_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ConLineJumpCode_Type


class ConLineJumpStyle_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ConLineJumpStyle_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConLineJumpStyle_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConLineJumpStyle_Type.subclass:
            return ConLineJumpStyle_Type.subclass(*args_, **kwargs_)
        else:
            return ConLineJumpStyle_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ConLineJumpStyle_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConLineJumpStyle_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConLineJumpStyle_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConLineJumpStyle_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConLineJumpStyle_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConLineJumpStyle_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConLineJumpStyle_Type'):
        super(ConLineJumpStyle_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConLineJumpStyle_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConLineJumpStyle_Type', fromsubclass_=False, pretty_print=True):
        super(ConLineJumpStyle_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConLineJumpStyle_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ConLineJumpStyle_Type


class ConLineJumpDirX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ConLineJumpDirX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConLineJumpDirX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConLineJumpDirX_Type.subclass:
            return ConLineJumpDirX_Type.subclass(*args_, **kwargs_)
        else:
            return ConLineJumpDirX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ConLineJumpDirX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConLineJumpDirX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConLineJumpDirX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConLineJumpDirX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConLineJumpDirX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConLineJumpDirX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConLineJumpDirX_Type'):
        super(ConLineJumpDirX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConLineJumpDirX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConLineJumpDirX_Type', fromsubclass_=False, pretty_print=True):
        super(ConLineJumpDirX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConLineJumpDirX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ConLineJumpDirX_Type


class ConLineJumpDirY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ConLineJumpDirY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConLineJumpDirY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConLineJumpDirY_Type.subclass:
            return ConLineJumpDirY_Type.subclass(*args_, **kwargs_)
        else:
            return ConLineJumpDirY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ConLineJumpDirY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConLineJumpDirY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConLineJumpDirY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConLineJumpDirY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConLineJumpDirY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConLineJumpDirY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConLineJumpDirY_Type'):
        super(ConLineJumpDirY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConLineJumpDirY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConLineJumpDirY_Type', fromsubclass_=False, pretty_print=True):
        super(ConLineJumpDirY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConLineJumpDirY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ConLineJumpDirY_Type


class ShapePlaceFlip_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapePlaceFlip_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapePlaceFlip_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapePlaceFlip_Type.subclass:
            return ShapePlaceFlip_Type.subclass(*args_, **kwargs_)
        else:
            return ShapePlaceFlip_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapePlaceFlip_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapePlaceFlip_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapePlaceFlip_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapePlaceFlip_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapePlaceFlip_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapePlaceFlip_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapePlaceFlip_Type'):
        super(ShapePlaceFlip_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapePlaceFlip_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapePlaceFlip_Type', fromsubclass_=False, pretty_print=True):
        super(ShapePlaceFlip_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapePlaceFlip_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapePlaceFlip_Type


class ConLineRouteExt_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ConLineRouteExt_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConLineRouteExt_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConLineRouteExt_Type.subclass:
            return ConLineRouteExt_Type.subclass(*args_, **kwargs_)
        else:
            return ConLineRouteExt_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ConLineRouteExt_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConLineRouteExt_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConLineRouteExt_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConLineRouteExt_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConLineRouteExt_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConLineRouteExt_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConLineRouteExt_Type'):
        super(ConLineRouteExt_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConLineRouteExt_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConLineRouteExt_Type', fromsubclass_=False, pretty_print=True):
        super(ConLineRouteExt_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConLineRouteExt_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ConLineRouteExt_Type


class ShapeSplit_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapeSplit_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapeSplit_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapeSplit_Type.subclass:
            return ShapeSplit_Type.subclass(*args_, **kwargs_)
        else:
            return ShapeSplit_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapeSplit_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeSplit_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapeSplit_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapeSplit_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeSplit_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapeSplit_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapeSplit_Type'):
        super(ShapeSplit_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeSplit_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeSplit_Type', fromsubclass_=False, pretty_print=True):
        super(ShapeSplit_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapeSplit_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapeSplit_Type


class ShapeSplittable_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ShapeSplittable_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShapeSplittable_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShapeSplittable_Type.subclass:
            return ShapeSplittable_Type.subclass(*args_, **kwargs_)
        else:
            return ShapeSplittable_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ShapeSplittable_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeSplittable_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShapeSplittable_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ShapeSplittable_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeSplittable_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ShapeSplittable_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ShapeSplittable_Type'):
        super(ShapeSplittable_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ShapeSplittable_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ShapeSplittable_Type', fromsubclass_=False, pretty_print=True):
        super(ShapeSplittable_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ShapeSplittable_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ShapeSplittable_Type


class PageLayout_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, ResizePage=None, EnableGrid=None, DynamicsOff=None, CtrlAsInput=None, PlaceStyle=None, RouteStyle=None, PlaceDepth=None, PlowCode=None, LineJumpCode=None, LineJumpStyle=None, PageLineJumpDirX=None, PageLineJumpDirY=None, LineToNodeX=None, LineToNodeY=None, BlockSizeX=None, BlockSizeY=None, AvenueSizeX=None, AvenueSizeY=None, LineToLineX=None, LineToLineY=None, LineJumpFactorX=None, LineJumpFactorY=None, LineAdjustFrom=None, LineAdjustTo=None, PlaceFlip=None, LineRouteExt=None, PageShapeSplit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PageLayout_Type, self).__init__(Del,  **kwargs_)
        if ResizePage is None:
            self.ResizePage = []
        else:
            self.ResizePage = ResizePage
        self.ResizePage_nsprefix_ = None
        if EnableGrid is None:
            self.EnableGrid = []
        else:
            self.EnableGrid = EnableGrid
        self.EnableGrid_nsprefix_ = None
        if DynamicsOff is None:
            self.DynamicsOff = []
        else:
            self.DynamicsOff = DynamicsOff
        self.DynamicsOff_nsprefix_ = None
        if CtrlAsInput is None:
            self.CtrlAsInput = []
        else:
            self.CtrlAsInput = CtrlAsInput
        self.CtrlAsInput_nsprefix_ = None
        if PlaceStyle is None:
            self.PlaceStyle = []
        else:
            self.PlaceStyle = PlaceStyle
        self.PlaceStyle_nsprefix_ = None
        if RouteStyle is None:
            self.RouteStyle = []
        else:
            self.RouteStyle = RouteStyle
        self.RouteStyle_nsprefix_ = None
        if PlaceDepth is None:
            self.PlaceDepth = []
        else:
            self.PlaceDepth = PlaceDepth
        self.PlaceDepth_nsprefix_ = None
        if PlowCode is None:
            self.PlowCode = []
        else:
            self.PlowCode = PlowCode
        self.PlowCode_nsprefix_ = None
        if LineJumpCode is None:
            self.LineJumpCode = []
        else:
            self.LineJumpCode = LineJumpCode
        self.LineJumpCode_nsprefix_ = None
        if LineJumpStyle is None:
            self.LineJumpStyle = []
        else:
            self.LineJumpStyle = LineJumpStyle
        self.LineJumpStyle_nsprefix_ = None
        if PageLineJumpDirX is None:
            self.PageLineJumpDirX = []
        else:
            self.PageLineJumpDirX = PageLineJumpDirX
        self.PageLineJumpDirX_nsprefix_ = None
        if PageLineJumpDirY is None:
            self.PageLineJumpDirY = []
        else:
            self.PageLineJumpDirY = PageLineJumpDirY
        self.PageLineJumpDirY_nsprefix_ = None
        if LineToNodeX is None:
            self.LineToNodeX = []
        else:
            self.LineToNodeX = LineToNodeX
        self.LineToNodeX_nsprefix_ = None
        if LineToNodeY is None:
            self.LineToNodeY = []
        else:
            self.LineToNodeY = LineToNodeY
        self.LineToNodeY_nsprefix_ = None
        if BlockSizeX is None:
            self.BlockSizeX = []
        else:
            self.BlockSizeX = BlockSizeX
        self.BlockSizeX_nsprefix_ = None
        if BlockSizeY is None:
            self.BlockSizeY = []
        else:
            self.BlockSizeY = BlockSizeY
        self.BlockSizeY_nsprefix_ = None
        if AvenueSizeX is None:
            self.AvenueSizeX = []
        else:
            self.AvenueSizeX = AvenueSizeX
        self.AvenueSizeX_nsprefix_ = None
        if AvenueSizeY is None:
            self.AvenueSizeY = []
        else:
            self.AvenueSizeY = AvenueSizeY
        self.AvenueSizeY_nsprefix_ = None
        if LineToLineX is None:
            self.LineToLineX = []
        else:
            self.LineToLineX = LineToLineX
        self.LineToLineX_nsprefix_ = None
        if LineToLineY is None:
            self.LineToLineY = []
        else:
            self.LineToLineY = LineToLineY
        self.LineToLineY_nsprefix_ = None
        if LineJumpFactorX is None:
            self.LineJumpFactorX = []
        else:
            self.LineJumpFactorX = LineJumpFactorX
        self.LineJumpFactorX_nsprefix_ = None
        if LineJumpFactorY is None:
            self.LineJumpFactorY = []
        else:
            self.LineJumpFactorY = LineJumpFactorY
        self.LineJumpFactorY_nsprefix_ = None
        if LineAdjustFrom is None:
            self.LineAdjustFrom = []
        else:
            self.LineAdjustFrom = LineAdjustFrom
        self.LineAdjustFrom_nsprefix_ = None
        if LineAdjustTo is None:
            self.LineAdjustTo = []
        else:
            self.LineAdjustTo = LineAdjustTo
        self.LineAdjustTo_nsprefix_ = None
        if PlaceFlip is None:
            self.PlaceFlip = []
        else:
            self.PlaceFlip = PlaceFlip
        self.PlaceFlip_nsprefix_ = None
        if LineRouteExt is None:
            self.LineRouteExt = []
        else:
            self.LineRouteExt = LineRouteExt
        self.LineRouteExt_nsprefix_ = None
        if PageShapeSplit is None:
            self.PageShapeSplit = []
        else:
            self.PageShapeSplit = PageShapeSplit
        self.PageShapeSplit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PageLayout_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PageLayout_Type.subclass:
            return PageLayout_Type.subclass(*args_, **kwargs_)
        else:
            return PageLayout_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ResizePage(self):
        return self.ResizePage
    def set_ResizePage(self, ResizePage):
        self.ResizePage = ResizePage
    def add_ResizePage(self, value):
        self.ResizePage.append(value)
    def insert_ResizePage_at(self, index, value):
        self.ResizePage.insert(index, value)
    def replace_ResizePage_at(self, index, value):
        self.ResizePage[index] = value
    def get_EnableGrid(self):
        return self.EnableGrid
    def set_EnableGrid(self, EnableGrid):
        self.EnableGrid = EnableGrid
    def add_EnableGrid(self, value):
        self.EnableGrid.append(value)
    def insert_EnableGrid_at(self, index, value):
        self.EnableGrid.insert(index, value)
    def replace_EnableGrid_at(self, index, value):
        self.EnableGrid[index] = value
    def get_DynamicsOff(self):
        return self.DynamicsOff
    def set_DynamicsOff(self, DynamicsOff):
        self.DynamicsOff = DynamicsOff
    def add_DynamicsOff(self, value):
        self.DynamicsOff.append(value)
    def insert_DynamicsOff_at(self, index, value):
        self.DynamicsOff.insert(index, value)
    def replace_DynamicsOff_at(self, index, value):
        self.DynamicsOff[index] = value
    def get_CtrlAsInput(self):
        return self.CtrlAsInput
    def set_CtrlAsInput(self, CtrlAsInput):
        self.CtrlAsInput = CtrlAsInput
    def add_CtrlAsInput(self, value):
        self.CtrlAsInput.append(value)
    def insert_CtrlAsInput_at(self, index, value):
        self.CtrlAsInput.insert(index, value)
    def replace_CtrlAsInput_at(self, index, value):
        self.CtrlAsInput[index] = value
    def get_PlaceStyle(self):
        return self.PlaceStyle
    def set_PlaceStyle(self, PlaceStyle):
        self.PlaceStyle = PlaceStyle
    def add_PlaceStyle(self, value):
        self.PlaceStyle.append(value)
    def insert_PlaceStyle_at(self, index, value):
        self.PlaceStyle.insert(index, value)
    def replace_PlaceStyle_at(self, index, value):
        self.PlaceStyle[index] = value
    def get_RouteStyle(self):
        return self.RouteStyle
    def set_RouteStyle(self, RouteStyle):
        self.RouteStyle = RouteStyle
    def add_RouteStyle(self, value):
        self.RouteStyle.append(value)
    def insert_RouteStyle_at(self, index, value):
        self.RouteStyle.insert(index, value)
    def replace_RouteStyle_at(self, index, value):
        self.RouteStyle[index] = value
    def get_PlaceDepth(self):
        return self.PlaceDepth
    def set_PlaceDepth(self, PlaceDepth):
        self.PlaceDepth = PlaceDepth
    def add_PlaceDepth(self, value):
        self.PlaceDepth.append(value)
    def insert_PlaceDepth_at(self, index, value):
        self.PlaceDepth.insert(index, value)
    def replace_PlaceDepth_at(self, index, value):
        self.PlaceDepth[index] = value
    def get_PlowCode(self):
        return self.PlowCode
    def set_PlowCode(self, PlowCode):
        self.PlowCode = PlowCode
    def add_PlowCode(self, value):
        self.PlowCode.append(value)
    def insert_PlowCode_at(self, index, value):
        self.PlowCode.insert(index, value)
    def replace_PlowCode_at(self, index, value):
        self.PlowCode[index] = value
    def get_LineJumpCode(self):
        return self.LineJumpCode
    def set_LineJumpCode(self, LineJumpCode):
        self.LineJumpCode = LineJumpCode
    def add_LineJumpCode(self, value):
        self.LineJumpCode.append(value)
    def insert_LineJumpCode_at(self, index, value):
        self.LineJumpCode.insert(index, value)
    def replace_LineJumpCode_at(self, index, value):
        self.LineJumpCode[index] = value
    def get_LineJumpStyle(self):
        return self.LineJumpStyle
    def set_LineJumpStyle(self, LineJumpStyle):
        self.LineJumpStyle = LineJumpStyle
    def add_LineJumpStyle(self, value):
        self.LineJumpStyle.append(value)
    def insert_LineJumpStyle_at(self, index, value):
        self.LineJumpStyle.insert(index, value)
    def replace_LineJumpStyle_at(self, index, value):
        self.LineJumpStyle[index] = value
    def get_PageLineJumpDirX(self):
        return self.PageLineJumpDirX
    def set_PageLineJumpDirX(self, PageLineJumpDirX):
        self.PageLineJumpDirX = PageLineJumpDirX
    def add_PageLineJumpDirX(self, value):
        self.PageLineJumpDirX.append(value)
    def insert_PageLineJumpDirX_at(self, index, value):
        self.PageLineJumpDirX.insert(index, value)
    def replace_PageLineJumpDirX_at(self, index, value):
        self.PageLineJumpDirX[index] = value
    def get_PageLineJumpDirY(self):
        return self.PageLineJumpDirY
    def set_PageLineJumpDirY(self, PageLineJumpDirY):
        self.PageLineJumpDirY = PageLineJumpDirY
    def add_PageLineJumpDirY(self, value):
        self.PageLineJumpDirY.append(value)
    def insert_PageLineJumpDirY_at(self, index, value):
        self.PageLineJumpDirY.insert(index, value)
    def replace_PageLineJumpDirY_at(self, index, value):
        self.PageLineJumpDirY[index] = value
    def get_LineToNodeX(self):
        return self.LineToNodeX
    def set_LineToNodeX(self, LineToNodeX):
        self.LineToNodeX = LineToNodeX
    def add_LineToNodeX(self, value):
        self.LineToNodeX.append(value)
    def insert_LineToNodeX_at(self, index, value):
        self.LineToNodeX.insert(index, value)
    def replace_LineToNodeX_at(self, index, value):
        self.LineToNodeX[index] = value
    def get_LineToNodeY(self):
        return self.LineToNodeY
    def set_LineToNodeY(self, LineToNodeY):
        self.LineToNodeY = LineToNodeY
    def add_LineToNodeY(self, value):
        self.LineToNodeY.append(value)
    def insert_LineToNodeY_at(self, index, value):
        self.LineToNodeY.insert(index, value)
    def replace_LineToNodeY_at(self, index, value):
        self.LineToNodeY[index] = value
    def get_BlockSizeX(self):
        return self.BlockSizeX
    def set_BlockSizeX(self, BlockSizeX):
        self.BlockSizeX = BlockSizeX
    def add_BlockSizeX(self, value):
        self.BlockSizeX.append(value)
    def insert_BlockSizeX_at(self, index, value):
        self.BlockSizeX.insert(index, value)
    def replace_BlockSizeX_at(self, index, value):
        self.BlockSizeX[index] = value
    def get_BlockSizeY(self):
        return self.BlockSizeY
    def set_BlockSizeY(self, BlockSizeY):
        self.BlockSizeY = BlockSizeY
    def add_BlockSizeY(self, value):
        self.BlockSizeY.append(value)
    def insert_BlockSizeY_at(self, index, value):
        self.BlockSizeY.insert(index, value)
    def replace_BlockSizeY_at(self, index, value):
        self.BlockSizeY[index] = value
    def get_AvenueSizeX(self):
        return self.AvenueSizeX
    def set_AvenueSizeX(self, AvenueSizeX):
        self.AvenueSizeX = AvenueSizeX
    def add_AvenueSizeX(self, value):
        self.AvenueSizeX.append(value)
    def insert_AvenueSizeX_at(self, index, value):
        self.AvenueSizeX.insert(index, value)
    def replace_AvenueSizeX_at(self, index, value):
        self.AvenueSizeX[index] = value
    def get_AvenueSizeY(self):
        return self.AvenueSizeY
    def set_AvenueSizeY(self, AvenueSizeY):
        self.AvenueSizeY = AvenueSizeY
    def add_AvenueSizeY(self, value):
        self.AvenueSizeY.append(value)
    def insert_AvenueSizeY_at(self, index, value):
        self.AvenueSizeY.insert(index, value)
    def replace_AvenueSizeY_at(self, index, value):
        self.AvenueSizeY[index] = value
    def get_LineToLineX(self):
        return self.LineToLineX
    def set_LineToLineX(self, LineToLineX):
        self.LineToLineX = LineToLineX
    def add_LineToLineX(self, value):
        self.LineToLineX.append(value)
    def insert_LineToLineX_at(self, index, value):
        self.LineToLineX.insert(index, value)
    def replace_LineToLineX_at(self, index, value):
        self.LineToLineX[index] = value
    def get_LineToLineY(self):
        return self.LineToLineY
    def set_LineToLineY(self, LineToLineY):
        self.LineToLineY = LineToLineY
    def add_LineToLineY(self, value):
        self.LineToLineY.append(value)
    def insert_LineToLineY_at(self, index, value):
        self.LineToLineY.insert(index, value)
    def replace_LineToLineY_at(self, index, value):
        self.LineToLineY[index] = value
    def get_LineJumpFactorX(self):
        return self.LineJumpFactorX
    def set_LineJumpFactorX(self, LineJumpFactorX):
        self.LineJumpFactorX = LineJumpFactorX
    def add_LineJumpFactorX(self, value):
        self.LineJumpFactorX.append(value)
    def insert_LineJumpFactorX_at(self, index, value):
        self.LineJumpFactorX.insert(index, value)
    def replace_LineJumpFactorX_at(self, index, value):
        self.LineJumpFactorX[index] = value
    def get_LineJumpFactorY(self):
        return self.LineJumpFactorY
    def set_LineJumpFactorY(self, LineJumpFactorY):
        self.LineJumpFactorY = LineJumpFactorY
    def add_LineJumpFactorY(self, value):
        self.LineJumpFactorY.append(value)
    def insert_LineJumpFactorY_at(self, index, value):
        self.LineJumpFactorY.insert(index, value)
    def replace_LineJumpFactorY_at(self, index, value):
        self.LineJumpFactorY[index] = value
    def get_LineAdjustFrom(self):
        return self.LineAdjustFrom
    def set_LineAdjustFrom(self, LineAdjustFrom):
        self.LineAdjustFrom = LineAdjustFrom
    def add_LineAdjustFrom(self, value):
        self.LineAdjustFrom.append(value)
    def insert_LineAdjustFrom_at(self, index, value):
        self.LineAdjustFrom.insert(index, value)
    def replace_LineAdjustFrom_at(self, index, value):
        self.LineAdjustFrom[index] = value
    def get_LineAdjustTo(self):
        return self.LineAdjustTo
    def set_LineAdjustTo(self, LineAdjustTo):
        self.LineAdjustTo = LineAdjustTo
    def add_LineAdjustTo(self, value):
        self.LineAdjustTo.append(value)
    def insert_LineAdjustTo_at(self, index, value):
        self.LineAdjustTo.insert(index, value)
    def replace_LineAdjustTo_at(self, index, value):
        self.LineAdjustTo[index] = value
    def get_PlaceFlip(self):
        return self.PlaceFlip
    def set_PlaceFlip(self, PlaceFlip):
        self.PlaceFlip = PlaceFlip
    def add_PlaceFlip(self, value):
        self.PlaceFlip.append(value)
    def insert_PlaceFlip_at(self, index, value):
        self.PlaceFlip.insert(index, value)
    def replace_PlaceFlip_at(self, index, value):
        self.PlaceFlip[index] = value
    def get_LineRouteExt(self):
        return self.LineRouteExt
    def set_LineRouteExt(self, LineRouteExt):
        self.LineRouteExt = LineRouteExt
    def add_LineRouteExt(self, value):
        self.LineRouteExt.append(value)
    def insert_LineRouteExt_at(self, index, value):
        self.LineRouteExt.insert(index, value)
    def replace_LineRouteExt_at(self, index, value):
        self.LineRouteExt[index] = value
    def get_PageShapeSplit(self):
        return self.PageShapeSplit
    def set_PageShapeSplit(self, PageShapeSplit):
        self.PageShapeSplit = PageShapeSplit
    def add_PageShapeSplit(self, value):
        self.PageShapeSplit.append(value)
    def insert_PageShapeSplit_at(self, index, value):
        self.PageShapeSplit.insert(index, value)
    def replace_PageShapeSplit_at(self, index, value):
        self.PageShapeSplit[index] = value
    def hasContent_(self):
        if (
            self.ResizePage or
            self.EnableGrid or
            self.DynamicsOff or
            self.CtrlAsInput or
            self.PlaceStyle or
            self.RouteStyle or
            self.PlaceDepth or
            self.PlowCode or
            self.LineJumpCode or
            self.LineJumpStyle or
            self.PageLineJumpDirX or
            self.PageLineJumpDirY or
            self.LineToNodeX or
            self.LineToNodeY or
            self.BlockSizeX or
            self.BlockSizeY or
            self.AvenueSizeX or
            self.AvenueSizeY or
            self.LineToLineX or
            self.LineToLineY or
            self.LineJumpFactorX or
            self.LineJumpFactorY or
            self.LineAdjustFrom or
            self.LineAdjustTo or
            self.PlaceFlip or
            self.LineRouteExt or
            self.PageShapeSplit or
            super(PageLayout_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='PageLayout_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PageLayout_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PageLayout_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageLayout_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PageLayout_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PageLayout_Type'):
        super(PageLayout_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageLayout_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='PageLayout_Type', fromsubclass_=False, pretty_print=True):
        super(PageLayout_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResizePage_ in self.ResizePage:
            namespaceprefix_ = self.ResizePage_nsprefix_ + ':' if (UseCapturedNS_ and self.ResizePage_nsprefix_) else ''
            ResizePage_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ResizePage', pretty_print=pretty_print)
        for EnableGrid_ in self.EnableGrid:
            namespaceprefix_ = self.EnableGrid_nsprefix_ + ':' if (UseCapturedNS_ and self.EnableGrid_nsprefix_) else ''
            EnableGrid_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EnableGrid', pretty_print=pretty_print)
        for DynamicsOff_ in self.DynamicsOff:
            namespaceprefix_ = self.DynamicsOff_nsprefix_ + ':' if (UseCapturedNS_ and self.DynamicsOff_nsprefix_) else ''
            DynamicsOff_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DynamicsOff', pretty_print=pretty_print)
        for CtrlAsInput_ in self.CtrlAsInput:
            namespaceprefix_ = self.CtrlAsInput_nsprefix_ + ':' if (UseCapturedNS_ and self.CtrlAsInput_nsprefix_) else ''
            CtrlAsInput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CtrlAsInput', pretty_print=pretty_print)
        for PlaceStyle_ in self.PlaceStyle:
            namespaceprefix_ = self.PlaceStyle_nsprefix_ + ':' if (UseCapturedNS_ and self.PlaceStyle_nsprefix_) else ''
            PlaceStyle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PlaceStyle', pretty_print=pretty_print)
        for RouteStyle_ in self.RouteStyle:
            namespaceprefix_ = self.RouteStyle_nsprefix_ + ':' if (UseCapturedNS_ and self.RouteStyle_nsprefix_) else ''
            RouteStyle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RouteStyle', pretty_print=pretty_print)
        for PlaceDepth_ in self.PlaceDepth:
            namespaceprefix_ = self.PlaceDepth_nsprefix_ + ':' if (UseCapturedNS_ and self.PlaceDepth_nsprefix_) else ''
            PlaceDepth_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PlaceDepth', pretty_print=pretty_print)
        for PlowCode_ in self.PlowCode:
            namespaceprefix_ = self.PlowCode_nsprefix_ + ':' if (UseCapturedNS_ and self.PlowCode_nsprefix_) else ''
            PlowCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PlowCode', pretty_print=pretty_print)
        for LineJumpCode_ in self.LineJumpCode:
            namespaceprefix_ = self.LineJumpCode_nsprefix_ + ':' if (UseCapturedNS_ and self.LineJumpCode_nsprefix_) else ''
            LineJumpCode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineJumpCode', pretty_print=pretty_print)
        for LineJumpStyle_ in self.LineJumpStyle:
            namespaceprefix_ = self.LineJumpStyle_nsprefix_ + ':' if (UseCapturedNS_ and self.LineJumpStyle_nsprefix_) else ''
            LineJumpStyle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineJumpStyle', pretty_print=pretty_print)
        for PageLineJumpDirX_ in self.PageLineJumpDirX:
            namespaceprefix_ = self.PageLineJumpDirX_nsprefix_ + ':' if (UseCapturedNS_ and self.PageLineJumpDirX_nsprefix_) else ''
            PageLineJumpDirX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PageLineJumpDirX', pretty_print=pretty_print)
        for PageLineJumpDirY_ in self.PageLineJumpDirY:
            namespaceprefix_ = self.PageLineJumpDirY_nsprefix_ + ':' if (UseCapturedNS_ and self.PageLineJumpDirY_nsprefix_) else ''
            PageLineJumpDirY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PageLineJumpDirY', pretty_print=pretty_print)
        for LineToNodeX_ in self.LineToNodeX:
            namespaceprefix_ = self.LineToNodeX_nsprefix_ + ':' if (UseCapturedNS_ and self.LineToNodeX_nsprefix_) else ''
            LineToNodeX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineToNodeX', pretty_print=pretty_print)
        for LineToNodeY_ in self.LineToNodeY:
            namespaceprefix_ = self.LineToNodeY_nsprefix_ + ':' if (UseCapturedNS_ and self.LineToNodeY_nsprefix_) else ''
            LineToNodeY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineToNodeY', pretty_print=pretty_print)
        for BlockSizeX_ in self.BlockSizeX:
            namespaceprefix_ = self.BlockSizeX_nsprefix_ + ':' if (UseCapturedNS_ and self.BlockSizeX_nsprefix_) else ''
            BlockSizeX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BlockSizeX', pretty_print=pretty_print)
        for BlockSizeY_ in self.BlockSizeY:
            namespaceprefix_ = self.BlockSizeY_nsprefix_ + ':' if (UseCapturedNS_ and self.BlockSizeY_nsprefix_) else ''
            BlockSizeY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BlockSizeY', pretty_print=pretty_print)
        for AvenueSizeX_ in self.AvenueSizeX:
            namespaceprefix_ = self.AvenueSizeX_nsprefix_ + ':' if (UseCapturedNS_ and self.AvenueSizeX_nsprefix_) else ''
            AvenueSizeX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AvenueSizeX', pretty_print=pretty_print)
        for AvenueSizeY_ in self.AvenueSizeY:
            namespaceprefix_ = self.AvenueSizeY_nsprefix_ + ':' if (UseCapturedNS_ and self.AvenueSizeY_nsprefix_) else ''
            AvenueSizeY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AvenueSizeY', pretty_print=pretty_print)
        for LineToLineX_ in self.LineToLineX:
            namespaceprefix_ = self.LineToLineX_nsprefix_ + ':' if (UseCapturedNS_ and self.LineToLineX_nsprefix_) else ''
            LineToLineX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineToLineX', pretty_print=pretty_print)
        for LineToLineY_ in self.LineToLineY:
            namespaceprefix_ = self.LineToLineY_nsprefix_ + ':' if (UseCapturedNS_ and self.LineToLineY_nsprefix_) else ''
            LineToLineY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineToLineY', pretty_print=pretty_print)
        for LineJumpFactorX_ in self.LineJumpFactorX:
            namespaceprefix_ = self.LineJumpFactorX_nsprefix_ + ':' if (UseCapturedNS_ and self.LineJumpFactorX_nsprefix_) else ''
            LineJumpFactorX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineJumpFactorX', pretty_print=pretty_print)
        for LineJumpFactorY_ in self.LineJumpFactorY:
            namespaceprefix_ = self.LineJumpFactorY_nsprefix_ + ':' if (UseCapturedNS_ and self.LineJumpFactorY_nsprefix_) else ''
            LineJumpFactorY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineJumpFactorY', pretty_print=pretty_print)
        for LineAdjustFrom_ in self.LineAdjustFrom:
            namespaceprefix_ = self.LineAdjustFrom_nsprefix_ + ':' if (UseCapturedNS_ and self.LineAdjustFrom_nsprefix_) else ''
            LineAdjustFrom_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineAdjustFrom', pretty_print=pretty_print)
        for LineAdjustTo_ in self.LineAdjustTo:
            namespaceprefix_ = self.LineAdjustTo_nsprefix_ + ':' if (UseCapturedNS_ and self.LineAdjustTo_nsprefix_) else ''
            LineAdjustTo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineAdjustTo', pretty_print=pretty_print)
        for PlaceFlip_ in self.PlaceFlip:
            namespaceprefix_ = self.PlaceFlip_nsprefix_ + ':' if (UseCapturedNS_ and self.PlaceFlip_nsprefix_) else ''
            PlaceFlip_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PlaceFlip', pretty_print=pretty_print)
        for LineRouteExt_ in self.LineRouteExt:
            namespaceprefix_ = self.LineRouteExt_nsprefix_ + ':' if (UseCapturedNS_ and self.LineRouteExt_nsprefix_) else ''
            LineRouteExt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineRouteExt', pretty_print=pretty_print)
        for PageShapeSplit_ in self.PageShapeSplit:
            namespaceprefix_ = self.PageShapeSplit_nsprefix_ + ':' if (UseCapturedNS_ and self.PageShapeSplit_nsprefix_) else ''
            PageShapeSplit_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PageShapeSplit', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PageLayout_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ResizePage':
            obj_ = ResizePage_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ResizePage.append(obj_)
            obj_.original_tagname_ = 'ResizePage'
        elif nodeName_ == 'EnableGrid':
            obj_ = EnableGrid_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnableGrid.append(obj_)
            obj_.original_tagname_ = 'EnableGrid'
        elif nodeName_ == 'DynamicsOff':
            obj_ = DynamicsOff_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DynamicsOff.append(obj_)
            obj_.original_tagname_ = 'DynamicsOff'
        elif nodeName_ == 'CtrlAsInput':
            obj_ = CtrlAsInput_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CtrlAsInput.append(obj_)
            obj_.original_tagname_ = 'CtrlAsInput'
        elif nodeName_ == 'PlaceStyle':
            obj_ = PlaceStyle_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PlaceStyle.append(obj_)
            obj_.original_tagname_ = 'PlaceStyle'
        elif nodeName_ == 'RouteStyle':
            obj_ = RouteStyle_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RouteStyle.append(obj_)
            obj_.original_tagname_ = 'RouteStyle'
        elif nodeName_ == 'PlaceDepth':
            obj_ = PlaceDepth_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PlaceDepth.append(obj_)
            obj_.original_tagname_ = 'PlaceDepth'
        elif nodeName_ == 'PlowCode':
            obj_ = PlowCode_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PlowCode.append(obj_)
            obj_.original_tagname_ = 'PlowCode'
        elif nodeName_ == 'LineJumpCode':
            obj_ = LineJumpCode_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineJumpCode.append(obj_)
            obj_.original_tagname_ = 'LineJumpCode'
        elif nodeName_ == 'LineJumpStyle':
            obj_ = LineJumpStyle_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineJumpStyle.append(obj_)
            obj_.original_tagname_ = 'LineJumpStyle'
        elif nodeName_ == 'PageLineJumpDirX':
            obj_ = PageLineJumpDirX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PageLineJumpDirX.append(obj_)
            obj_.original_tagname_ = 'PageLineJumpDirX'
        elif nodeName_ == 'PageLineJumpDirY':
            obj_ = PageLineJumpDirY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PageLineJumpDirY.append(obj_)
            obj_.original_tagname_ = 'PageLineJumpDirY'
        elif nodeName_ == 'LineToNodeX':
            obj_ = LineToNodeX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineToNodeX.append(obj_)
            obj_.original_tagname_ = 'LineToNodeX'
        elif nodeName_ == 'LineToNodeY':
            obj_ = LineToNodeY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineToNodeY.append(obj_)
            obj_.original_tagname_ = 'LineToNodeY'
        elif nodeName_ == 'BlockSizeX':
            obj_ = BlockSizeX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BlockSizeX.append(obj_)
            obj_.original_tagname_ = 'BlockSizeX'
        elif nodeName_ == 'BlockSizeY':
            obj_ = BlockSizeY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BlockSizeY.append(obj_)
            obj_.original_tagname_ = 'BlockSizeY'
        elif nodeName_ == 'AvenueSizeX':
            obj_ = AvenueSizeX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AvenueSizeX.append(obj_)
            obj_.original_tagname_ = 'AvenueSizeX'
        elif nodeName_ == 'AvenueSizeY':
            obj_ = AvenueSizeY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AvenueSizeY.append(obj_)
            obj_.original_tagname_ = 'AvenueSizeY'
        elif nodeName_ == 'LineToLineX':
            obj_ = LineToLineX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineToLineX.append(obj_)
            obj_.original_tagname_ = 'LineToLineX'
        elif nodeName_ == 'LineToLineY':
            obj_ = LineToLineY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineToLineY.append(obj_)
            obj_.original_tagname_ = 'LineToLineY'
        elif nodeName_ == 'LineJumpFactorX':
            obj_ = LineJumpFactorX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineJumpFactorX.append(obj_)
            obj_.original_tagname_ = 'LineJumpFactorX'
        elif nodeName_ == 'LineJumpFactorY':
            obj_ = LineJumpFactorY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineJumpFactorY.append(obj_)
            obj_.original_tagname_ = 'LineJumpFactorY'
        elif nodeName_ == 'LineAdjustFrom':
            obj_ = LineAdjustFrom_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineAdjustFrom.append(obj_)
            obj_.original_tagname_ = 'LineAdjustFrom'
        elif nodeName_ == 'LineAdjustTo':
            obj_ = LineAdjustTo_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineAdjustTo.append(obj_)
            obj_.original_tagname_ = 'LineAdjustTo'
        elif nodeName_ == 'PlaceFlip':
            obj_ = PlaceFlip_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PlaceFlip.append(obj_)
            obj_.original_tagname_ = 'PlaceFlip'
        elif nodeName_ == 'LineRouteExt':
            obj_ = LineRouteExt_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineRouteExt.append(obj_)
            obj_.original_tagname_ = 'LineRouteExt'
        elif nodeName_ == 'PageShapeSplit':
            obj_ = PageShapeSplit_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PageShapeSplit.append(obj_)
            obj_.original_tagname_ = 'PageShapeSplit'
        super(PageLayout_Type, self).buildChildren(child_, node, nodeName_, True)
# end class PageLayout_Type


class ResizePage_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ResizePage_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResizePage_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResizePage_Type.subclass:
            return ResizePage_Type.subclass(*args_, **kwargs_)
        else:
            return ResizePage_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ResizePage_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ResizePage_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResizePage_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ResizePage_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResizePage_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResizePage_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResizePage_Type'):
        super(ResizePage_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResizePage_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ResizePage_Type', fromsubclass_=False, pretty_print=True):
        super(ResizePage_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ResizePage_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ResizePage_Type


class EnableGrid_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EnableGrid_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnableGrid_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnableGrid_Type.subclass:
            return EnableGrid_Type.subclass(*args_, **kwargs_)
        else:
            return EnableGrid_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EnableGrid_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnableGrid_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnableGrid_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EnableGrid_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnableGrid_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EnableGrid_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EnableGrid_Type'):
        super(EnableGrid_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnableGrid_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EnableGrid_Type', fromsubclass_=False, pretty_print=True):
        super(EnableGrid_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EnableGrid_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EnableGrid_Type


class DynamicsOff_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DynamicsOff_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DynamicsOff_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DynamicsOff_Type.subclass:
            return DynamicsOff_Type.subclass(*args_, **kwargs_)
        else:
            return DynamicsOff_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DynamicsOff_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DynamicsOff_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DynamicsOff_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DynamicsOff_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DynamicsOff_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DynamicsOff_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DynamicsOff_Type'):
        super(DynamicsOff_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DynamicsOff_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DynamicsOff_Type', fromsubclass_=False, pretty_print=True):
        super(DynamicsOff_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DynamicsOff_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DynamicsOff_Type


class CtrlAsInput_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CtrlAsInput_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CtrlAsInput_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CtrlAsInput_Type.subclass:
            return CtrlAsInput_Type.subclass(*args_, **kwargs_)
        else:
            return CtrlAsInput_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(CtrlAsInput_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CtrlAsInput_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CtrlAsInput_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CtrlAsInput_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CtrlAsInput_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CtrlAsInput_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CtrlAsInput_Type'):
        super(CtrlAsInput_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CtrlAsInput_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CtrlAsInput_Type', fromsubclass_=False, pretty_print=True):
        super(CtrlAsInput_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CtrlAsInput_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CtrlAsInput_Type


class PlaceStyle_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PlaceStyle_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlaceStyle_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlaceStyle_Type.subclass:
            return PlaceStyle_Type.subclass(*args_, **kwargs_)
        else:
            return PlaceStyle_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PlaceStyle_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PlaceStyle_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PlaceStyle_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PlaceStyle_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PlaceStyle_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PlaceStyle_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PlaceStyle_Type'):
        super(PlaceStyle_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PlaceStyle_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PlaceStyle_Type', fromsubclass_=False, pretty_print=True):
        super(PlaceStyle_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PlaceStyle_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PlaceStyle_Type


class RouteStyle_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RouteStyle_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RouteStyle_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RouteStyle_Type.subclass:
            return RouteStyle_Type.subclass(*args_, **kwargs_)
        else:
            return RouteStyle_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(RouteStyle_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RouteStyle_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RouteStyle_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RouteStyle_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RouteStyle_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RouteStyle_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RouteStyle_Type'):
        super(RouteStyle_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RouteStyle_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RouteStyle_Type', fromsubclass_=False, pretty_print=True):
        super(RouteStyle_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RouteStyle_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RouteStyle_Type


class PlaceDepth_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PlaceDepth_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlaceDepth_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlaceDepth_Type.subclass:
            return PlaceDepth_Type.subclass(*args_, **kwargs_)
        else:
            return PlaceDepth_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PlaceDepth_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PlaceDepth_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PlaceDepth_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PlaceDepth_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PlaceDepth_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PlaceDepth_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PlaceDepth_Type'):
        super(PlaceDepth_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PlaceDepth_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PlaceDepth_Type', fromsubclass_=False, pretty_print=True):
        super(PlaceDepth_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PlaceDepth_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PlaceDepth_Type


class PlowCode_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PlowCode_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlowCode_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlowCode_Type.subclass:
            return PlowCode_Type.subclass(*args_, **kwargs_)
        else:
            return PlowCode_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PlowCode_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PlowCode_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PlowCode_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PlowCode_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PlowCode_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PlowCode_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PlowCode_Type'):
        super(PlowCode_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PlowCode_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PlowCode_Type', fromsubclass_=False, pretty_print=True):
        super(PlowCode_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PlowCode_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PlowCode_Type


class LineJumpCode_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineJumpCode_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineJumpCode_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineJumpCode_Type.subclass:
            return LineJumpCode_Type.subclass(*args_, **kwargs_)
        else:
            return LineJumpCode_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LineJumpCode_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineJumpCode_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineJumpCode_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineJumpCode_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineJumpCode_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineJumpCode_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineJumpCode_Type'):
        super(LineJumpCode_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineJumpCode_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineJumpCode_Type', fromsubclass_=False, pretty_print=True):
        super(LineJumpCode_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineJumpCode_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LineJumpCode_Type


class LineJumpStyle_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineJumpStyle_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineJumpStyle_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineJumpStyle_Type.subclass:
            return LineJumpStyle_Type.subclass(*args_, **kwargs_)
        else:
            return LineJumpStyle_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LineJumpStyle_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineJumpStyle_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineJumpStyle_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineJumpStyle_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineJumpStyle_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineJumpStyle_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineJumpStyle_Type'):
        super(LineJumpStyle_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineJumpStyle_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineJumpStyle_Type', fromsubclass_=False, pretty_print=True):
        super(LineJumpStyle_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineJumpStyle_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LineJumpStyle_Type


class PageLineJumpDirX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PageLineJumpDirX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PageLineJumpDirX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PageLineJumpDirX_Type.subclass:
            return PageLineJumpDirX_Type.subclass(*args_, **kwargs_)
        else:
            return PageLineJumpDirX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PageLineJumpDirX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageLineJumpDirX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PageLineJumpDirX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PageLineJumpDirX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageLineJumpDirX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PageLineJumpDirX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PageLineJumpDirX_Type'):
        super(PageLineJumpDirX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageLineJumpDirX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageLineJumpDirX_Type', fromsubclass_=False, pretty_print=True):
        super(PageLineJumpDirX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PageLineJumpDirX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PageLineJumpDirX_Type


class PageLineJumpDirY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PageLineJumpDirY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PageLineJumpDirY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PageLineJumpDirY_Type.subclass:
            return PageLineJumpDirY_Type.subclass(*args_, **kwargs_)
        else:
            return PageLineJumpDirY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PageLineJumpDirY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageLineJumpDirY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PageLineJumpDirY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PageLineJumpDirY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageLineJumpDirY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PageLineJumpDirY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PageLineJumpDirY_Type'):
        super(PageLineJumpDirY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageLineJumpDirY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageLineJumpDirY_Type', fromsubclass_=False, pretty_print=True):
        super(PageLineJumpDirY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PageLineJumpDirY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PageLineJumpDirY_Type


class LineToNodeX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineToNodeX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineToNodeX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineToNodeX_Type.subclass:
            return LineToNodeX_Type.subclass(*args_, **kwargs_)
        else:
            return LineToNodeX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LineToNodeX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineToNodeX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineToNodeX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineToNodeX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineToNodeX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineToNodeX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineToNodeX_Type'):
        super(LineToNodeX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineToNodeX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineToNodeX_Type', fromsubclass_=False, pretty_print=True):
        super(LineToNodeX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineToNodeX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LineToNodeX_Type


class LineToNodeY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineToNodeY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineToNodeY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineToNodeY_Type.subclass:
            return LineToNodeY_Type.subclass(*args_, **kwargs_)
        else:
            return LineToNodeY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LineToNodeY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineToNodeY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineToNodeY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineToNodeY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineToNodeY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineToNodeY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineToNodeY_Type'):
        super(LineToNodeY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineToNodeY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineToNodeY_Type', fromsubclass_=False, pretty_print=True):
        super(LineToNodeY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineToNodeY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LineToNodeY_Type


class BlockSizeX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BlockSizeX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BlockSizeX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BlockSizeX_Type.subclass:
            return BlockSizeX_Type.subclass(*args_, **kwargs_)
        else:
            return BlockSizeX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(BlockSizeX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BlockSizeX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BlockSizeX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BlockSizeX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BlockSizeX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BlockSizeX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BlockSizeX_Type'):
        super(BlockSizeX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BlockSizeX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BlockSizeX_Type', fromsubclass_=False, pretty_print=True):
        super(BlockSizeX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BlockSizeX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BlockSizeX_Type


class BlockSizeY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BlockSizeY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BlockSizeY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BlockSizeY_Type.subclass:
            return BlockSizeY_Type.subclass(*args_, **kwargs_)
        else:
            return BlockSizeY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(BlockSizeY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BlockSizeY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BlockSizeY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BlockSizeY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BlockSizeY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BlockSizeY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BlockSizeY_Type'):
        super(BlockSizeY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BlockSizeY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BlockSizeY_Type', fromsubclass_=False, pretty_print=True):
        super(BlockSizeY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BlockSizeY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BlockSizeY_Type


class AvenueSizeX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AvenueSizeX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AvenueSizeX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AvenueSizeX_Type.subclass:
            return AvenueSizeX_Type.subclass(*args_, **kwargs_)
        else:
            return AvenueSizeX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AvenueSizeX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AvenueSizeX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AvenueSizeX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AvenueSizeX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AvenueSizeX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AvenueSizeX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AvenueSizeX_Type'):
        super(AvenueSizeX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AvenueSizeX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AvenueSizeX_Type', fromsubclass_=False, pretty_print=True):
        super(AvenueSizeX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AvenueSizeX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AvenueSizeX_Type


class AvenueSizeY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AvenueSizeY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AvenueSizeY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AvenueSizeY_Type.subclass:
            return AvenueSizeY_Type.subclass(*args_, **kwargs_)
        else:
            return AvenueSizeY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AvenueSizeY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AvenueSizeY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AvenueSizeY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AvenueSizeY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AvenueSizeY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AvenueSizeY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AvenueSizeY_Type'):
        super(AvenueSizeY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AvenueSizeY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AvenueSizeY_Type', fromsubclass_=False, pretty_print=True):
        super(AvenueSizeY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AvenueSizeY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AvenueSizeY_Type


class LineToLineX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineToLineX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineToLineX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineToLineX_Type.subclass:
            return LineToLineX_Type.subclass(*args_, **kwargs_)
        else:
            return LineToLineX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LineToLineX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineToLineX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineToLineX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineToLineX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineToLineX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineToLineX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineToLineX_Type'):
        super(LineToLineX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineToLineX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineToLineX_Type', fromsubclass_=False, pretty_print=True):
        super(LineToLineX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineToLineX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LineToLineX_Type


class LineToLineY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineToLineY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineToLineY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineToLineY_Type.subclass:
            return LineToLineY_Type.subclass(*args_, **kwargs_)
        else:
            return LineToLineY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LineToLineY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineToLineY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineToLineY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineToLineY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineToLineY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineToLineY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineToLineY_Type'):
        super(LineToLineY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineToLineY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineToLineY_Type', fromsubclass_=False, pretty_print=True):
        super(LineToLineY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineToLineY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LineToLineY_Type


class LineJumpFactorX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineJumpFactorX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineJumpFactorX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineJumpFactorX_Type.subclass:
            return LineJumpFactorX_Type.subclass(*args_, **kwargs_)
        else:
            return LineJumpFactorX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LineJumpFactorX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineJumpFactorX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineJumpFactorX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineJumpFactorX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineJumpFactorX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineJumpFactorX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineJumpFactorX_Type'):
        super(LineJumpFactorX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineJumpFactorX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineJumpFactorX_Type', fromsubclass_=False, pretty_print=True):
        super(LineJumpFactorX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineJumpFactorX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LineJumpFactorX_Type


class LineJumpFactorY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineJumpFactorY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineJumpFactorY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineJumpFactorY_Type.subclass:
            return LineJumpFactorY_Type.subclass(*args_, **kwargs_)
        else:
            return LineJumpFactorY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LineJumpFactorY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineJumpFactorY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineJumpFactorY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineJumpFactorY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineJumpFactorY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineJumpFactorY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineJumpFactorY_Type'):
        super(LineJumpFactorY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineJumpFactorY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineJumpFactorY_Type', fromsubclass_=False, pretty_print=True):
        super(LineJumpFactorY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineJumpFactorY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LineJumpFactorY_Type


class LineAdjustFrom_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineAdjustFrom_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineAdjustFrom_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineAdjustFrom_Type.subclass:
            return LineAdjustFrom_Type.subclass(*args_, **kwargs_)
        else:
            return LineAdjustFrom_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LineAdjustFrom_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineAdjustFrom_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineAdjustFrom_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineAdjustFrom_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineAdjustFrom_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineAdjustFrom_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineAdjustFrom_Type'):
        super(LineAdjustFrom_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineAdjustFrom_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineAdjustFrom_Type', fromsubclass_=False, pretty_print=True):
        super(LineAdjustFrom_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineAdjustFrom_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LineAdjustFrom_Type


class LineAdjustTo_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineAdjustTo_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineAdjustTo_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineAdjustTo_Type.subclass:
            return LineAdjustTo_Type.subclass(*args_, **kwargs_)
        else:
            return LineAdjustTo_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LineAdjustTo_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineAdjustTo_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineAdjustTo_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineAdjustTo_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineAdjustTo_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineAdjustTo_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineAdjustTo_Type'):
        super(LineAdjustTo_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineAdjustTo_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineAdjustTo_Type', fromsubclass_=False, pretty_print=True):
        super(LineAdjustTo_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineAdjustTo_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LineAdjustTo_Type


class PlaceFlip_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PlaceFlip_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlaceFlip_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlaceFlip_Type.subclass:
            return PlaceFlip_Type.subclass(*args_, **kwargs_)
        else:
            return PlaceFlip_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PlaceFlip_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PlaceFlip_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PlaceFlip_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PlaceFlip_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PlaceFlip_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PlaceFlip_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PlaceFlip_Type'):
        super(PlaceFlip_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PlaceFlip_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PlaceFlip_Type', fromsubclass_=False, pretty_print=True):
        super(PlaceFlip_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PlaceFlip_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PlaceFlip_Type


class LineRouteExt_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineRouteExt_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineRouteExt_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineRouteExt_Type.subclass:
            return LineRouteExt_Type.subclass(*args_, **kwargs_)
        else:
            return LineRouteExt_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LineRouteExt_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineRouteExt_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineRouteExt_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineRouteExt_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineRouteExt_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineRouteExt_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineRouteExt_Type'):
        super(LineRouteExt_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineRouteExt_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LineRouteExt_Type', fromsubclass_=False, pretty_print=True):
        super(LineRouteExt_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineRouteExt_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LineRouteExt_Type


class PageShapeSplit_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PageShapeSplit_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PageShapeSplit_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PageShapeSplit_Type.subclass:
            return PageShapeSplit_Type.subclass(*args_, **kwargs_)
        else:
            return PageShapeSplit_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PageShapeSplit_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageShapeSplit_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PageShapeSplit_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PageShapeSplit_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageShapeSplit_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PageShapeSplit_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PageShapeSplit_Type'):
        super(PageShapeSplit_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageShapeSplit_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageShapeSplit_Type', fromsubclass_=False, pretty_print=True):
        super(PageShapeSplit_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PageShapeSplit_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PageShapeSplit_Type


class PrintProps_Type(Row_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Row_Type
    def __init__(self, Del=None, PageLeftMargin=None, PageRightMargin=None, PageTopMargin=None, PageBottomMargin=None, ScaleX=None, ScaleY=None, PagesX=None, PagesY=None, CenterX=None, CenterY=None, OnPage=None, PrintGrid=None, PrintPageOrientation=None, PaperKind=None, PaperSource=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PrintProps_Type, self).__init__(Del,  **kwargs_)
        if PageLeftMargin is None:
            self.PageLeftMargin = []
        else:
            self.PageLeftMargin = PageLeftMargin
        self.PageLeftMargin_nsprefix_ = None
        if PageRightMargin is None:
            self.PageRightMargin = []
        else:
            self.PageRightMargin = PageRightMargin
        self.PageRightMargin_nsprefix_ = None
        if PageTopMargin is None:
            self.PageTopMargin = []
        else:
            self.PageTopMargin = PageTopMargin
        self.PageTopMargin_nsprefix_ = None
        if PageBottomMargin is None:
            self.PageBottomMargin = []
        else:
            self.PageBottomMargin = PageBottomMargin
        self.PageBottomMargin_nsprefix_ = None
        if ScaleX is None:
            self.ScaleX = []
        else:
            self.ScaleX = ScaleX
        self.ScaleX_nsprefix_ = None
        if ScaleY is None:
            self.ScaleY = []
        else:
            self.ScaleY = ScaleY
        self.ScaleY_nsprefix_ = None
        if PagesX is None:
            self.PagesX = []
        else:
            self.PagesX = PagesX
        self.PagesX_nsprefix_ = None
        if PagesY is None:
            self.PagesY = []
        else:
            self.PagesY = PagesY
        self.PagesY_nsprefix_ = None
        if CenterX is None:
            self.CenterX = []
        else:
            self.CenterX = CenterX
        self.CenterX_nsprefix_ = None
        if CenterY is None:
            self.CenterY = []
        else:
            self.CenterY = CenterY
        self.CenterY_nsprefix_ = None
        if OnPage is None:
            self.OnPage = []
        else:
            self.OnPage = OnPage
        self.OnPage_nsprefix_ = None
        if PrintGrid is None:
            self.PrintGrid = []
        else:
            self.PrintGrid = PrintGrid
        self.PrintGrid_nsprefix_ = None
        if PrintPageOrientation is None:
            self.PrintPageOrientation = []
        else:
            self.PrintPageOrientation = PrintPageOrientation
        self.PrintPageOrientation_nsprefix_ = None
        if PaperKind is None:
            self.PaperKind = []
        else:
            self.PaperKind = PaperKind
        self.PaperKind_nsprefix_ = None
        if PaperSource is None:
            self.PaperSource = []
        else:
            self.PaperSource = PaperSource
        self.PaperSource_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrintProps_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrintProps_Type.subclass:
            return PrintProps_Type.subclass(*args_, **kwargs_)
        else:
            return PrintProps_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PageLeftMargin(self):
        return self.PageLeftMargin
    def set_PageLeftMargin(self, PageLeftMargin):
        self.PageLeftMargin = PageLeftMargin
    def add_PageLeftMargin(self, value):
        self.PageLeftMargin.append(value)
    def insert_PageLeftMargin_at(self, index, value):
        self.PageLeftMargin.insert(index, value)
    def replace_PageLeftMargin_at(self, index, value):
        self.PageLeftMargin[index] = value
    def get_PageRightMargin(self):
        return self.PageRightMargin
    def set_PageRightMargin(self, PageRightMargin):
        self.PageRightMargin = PageRightMargin
    def add_PageRightMargin(self, value):
        self.PageRightMargin.append(value)
    def insert_PageRightMargin_at(self, index, value):
        self.PageRightMargin.insert(index, value)
    def replace_PageRightMargin_at(self, index, value):
        self.PageRightMargin[index] = value
    def get_PageTopMargin(self):
        return self.PageTopMargin
    def set_PageTopMargin(self, PageTopMargin):
        self.PageTopMargin = PageTopMargin
    def add_PageTopMargin(self, value):
        self.PageTopMargin.append(value)
    def insert_PageTopMargin_at(self, index, value):
        self.PageTopMargin.insert(index, value)
    def replace_PageTopMargin_at(self, index, value):
        self.PageTopMargin[index] = value
    def get_PageBottomMargin(self):
        return self.PageBottomMargin
    def set_PageBottomMargin(self, PageBottomMargin):
        self.PageBottomMargin = PageBottomMargin
    def add_PageBottomMargin(self, value):
        self.PageBottomMargin.append(value)
    def insert_PageBottomMargin_at(self, index, value):
        self.PageBottomMargin.insert(index, value)
    def replace_PageBottomMargin_at(self, index, value):
        self.PageBottomMargin[index] = value
    def get_ScaleX(self):
        return self.ScaleX
    def set_ScaleX(self, ScaleX):
        self.ScaleX = ScaleX
    def add_ScaleX(self, value):
        self.ScaleX.append(value)
    def insert_ScaleX_at(self, index, value):
        self.ScaleX.insert(index, value)
    def replace_ScaleX_at(self, index, value):
        self.ScaleX[index] = value
    def get_ScaleY(self):
        return self.ScaleY
    def set_ScaleY(self, ScaleY):
        self.ScaleY = ScaleY
    def add_ScaleY(self, value):
        self.ScaleY.append(value)
    def insert_ScaleY_at(self, index, value):
        self.ScaleY.insert(index, value)
    def replace_ScaleY_at(self, index, value):
        self.ScaleY[index] = value
    def get_PagesX(self):
        return self.PagesX
    def set_PagesX(self, PagesX):
        self.PagesX = PagesX
    def add_PagesX(self, value):
        self.PagesX.append(value)
    def insert_PagesX_at(self, index, value):
        self.PagesX.insert(index, value)
    def replace_PagesX_at(self, index, value):
        self.PagesX[index] = value
    def get_PagesY(self):
        return self.PagesY
    def set_PagesY(self, PagesY):
        self.PagesY = PagesY
    def add_PagesY(self, value):
        self.PagesY.append(value)
    def insert_PagesY_at(self, index, value):
        self.PagesY.insert(index, value)
    def replace_PagesY_at(self, index, value):
        self.PagesY[index] = value
    def get_CenterX(self):
        return self.CenterX
    def set_CenterX(self, CenterX):
        self.CenterX = CenterX
    def add_CenterX(self, value):
        self.CenterX.append(value)
    def insert_CenterX_at(self, index, value):
        self.CenterX.insert(index, value)
    def replace_CenterX_at(self, index, value):
        self.CenterX[index] = value
    def get_CenterY(self):
        return self.CenterY
    def set_CenterY(self, CenterY):
        self.CenterY = CenterY
    def add_CenterY(self, value):
        self.CenterY.append(value)
    def insert_CenterY_at(self, index, value):
        self.CenterY.insert(index, value)
    def replace_CenterY_at(self, index, value):
        self.CenterY[index] = value
    def get_OnPage(self):
        return self.OnPage
    def set_OnPage(self, OnPage):
        self.OnPage = OnPage
    def add_OnPage(self, value):
        self.OnPage.append(value)
    def insert_OnPage_at(self, index, value):
        self.OnPage.insert(index, value)
    def replace_OnPage_at(self, index, value):
        self.OnPage[index] = value
    def get_PrintGrid(self):
        return self.PrintGrid
    def set_PrintGrid(self, PrintGrid):
        self.PrintGrid = PrintGrid
    def add_PrintGrid(self, value):
        self.PrintGrid.append(value)
    def insert_PrintGrid_at(self, index, value):
        self.PrintGrid.insert(index, value)
    def replace_PrintGrid_at(self, index, value):
        self.PrintGrid[index] = value
    def get_PrintPageOrientation(self):
        return self.PrintPageOrientation
    def set_PrintPageOrientation(self, PrintPageOrientation):
        self.PrintPageOrientation = PrintPageOrientation
    def add_PrintPageOrientation(self, value):
        self.PrintPageOrientation.append(value)
    def insert_PrintPageOrientation_at(self, index, value):
        self.PrintPageOrientation.insert(index, value)
    def replace_PrintPageOrientation_at(self, index, value):
        self.PrintPageOrientation[index] = value
    def get_PaperKind(self):
        return self.PaperKind
    def set_PaperKind(self, PaperKind):
        self.PaperKind = PaperKind
    def add_PaperKind(self, value):
        self.PaperKind.append(value)
    def insert_PaperKind_at(self, index, value):
        self.PaperKind.insert(index, value)
    def replace_PaperKind_at(self, index, value):
        self.PaperKind[index] = value
    def get_PaperSource(self):
        return self.PaperSource
    def set_PaperSource(self, PaperSource):
        self.PaperSource = PaperSource
    def add_PaperSource(self, value):
        self.PaperSource.append(value)
    def insert_PaperSource_at(self, index, value):
        self.PaperSource.insert(index, value)
    def replace_PaperSource_at(self, index, value):
        self.PaperSource[index] = value
    def hasContent_(self):
        if (
            self.PageLeftMargin or
            self.PageRightMargin or
            self.PageTopMargin or
            self.PageBottomMargin or
            self.ScaleX or
            self.ScaleY or
            self.PagesX or
            self.PagesY or
            self.CenterX or
            self.CenterY or
            self.OnPage or
            self.PrintGrid or
            self.PrintPageOrientation or
            self.PaperKind or
            self.PaperSource or
            super(PrintProps_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='PrintProps_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PrintProps_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PrintProps_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrintProps_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PrintProps_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PrintProps_Type'):
        super(PrintProps_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrintProps_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='PrintProps_Type', fromsubclass_=False, pretty_print=True):
        super(PrintProps_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PageLeftMargin_ in self.PageLeftMargin:
            namespaceprefix_ = self.PageLeftMargin_nsprefix_ + ':' if (UseCapturedNS_ and self.PageLeftMargin_nsprefix_) else ''
            PageLeftMargin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PageLeftMargin', pretty_print=pretty_print)
        for PageRightMargin_ in self.PageRightMargin:
            namespaceprefix_ = self.PageRightMargin_nsprefix_ + ':' if (UseCapturedNS_ and self.PageRightMargin_nsprefix_) else ''
            PageRightMargin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PageRightMargin', pretty_print=pretty_print)
        for PageTopMargin_ in self.PageTopMargin:
            namespaceprefix_ = self.PageTopMargin_nsprefix_ + ':' if (UseCapturedNS_ and self.PageTopMargin_nsprefix_) else ''
            PageTopMargin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PageTopMargin', pretty_print=pretty_print)
        for PageBottomMargin_ in self.PageBottomMargin:
            namespaceprefix_ = self.PageBottomMargin_nsprefix_ + ':' if (UseCapturedNS_ and self.PageBottomMargin_nsprefix_) else ''
            PageBottomMargin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PageBottomMargin', pretty_print=pretty_print)
        for ScaleX_ in self.ScaleX:
            namespaceprefix_ = self.ScaleX_nsprefix_ + ':' if (UseCapturedNS_ and self.ScaleX_nsprefix_) else ''
            ScaleX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ScaleX', pretty_print=pretty_print)
        for ScaleY_ in self.ScaleY:
            namespaceprefix_ = self.ScaleY_nsprefix_ + ':' if (UseCapturedNS_ and self.ScaleY_nsprefix_) else ''
            ScaleY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ScaleY', pretty_print=pretty_print)
        for PagesX_ in self.PagesX:
            namespaceprefix_ = self.PagesX_nsprefix_ + ':' if (UseCapturedNS_ and self.PagesX_nsprefix_) else ''
            PagesX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PagesX', pretty_print=pretty_print)
        for PagesY_ in self.PagesY:
            namespaceprefix_ = self.PagesY_nsprefix_ + ':' if (UseCapturedNS_ and self.PagesY_nsprefix_) else ''
            PagesY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PagesY', pretty_print=pretty_print)
        for CenterX_ in self.CenterX:
            namespaceprefix_ = self.CenterX_nsprefix_ + ':' if (UseCapturedNS_ and self.CenterX_nsprefix_) else ''
            CenterX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CenterX', pretty_print=pretty_print)
        for CenterY_ in self.CenterY:
            namespaceprefix_ = self.CenterY_nsprefix_ + ':' if (UseCapturedNS_ and self.CenterY_nsprefix_) else ''
            CenterY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CenterY', pretty_print=pretty_print)
        for OnPage_ in self.OnPage:
            namespaceprefix_ = self.OnPage_nsprefix_ + ':' if (UseCapturedNS_ and self.OnPage_nsprefix_) else ''
            OnPage_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OnPage', pretty_print=pretty_print)
        for PrintGrid_ in self.PrintGrid:
            namespaceprefix_ = self.PrintGrid_nsprefix_ + ':' if (UseCapturedNS_ and self.PrintGrid_nsprefix_) else ''
            PrintGrid_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PrintGrid', pretty_print=pretty_print)
        for PrintPageOrientation_ in self.PrintPageOrientation:
            namespaceprefix_ = self.PrintPageOrientation_nsprefix_ + ':' if (UseCapturedNS_ and self.PrintPageOrientation_nsprefix_) else ''
            PrintPageOrientation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PrintPageOrientation', pretty_print=pretty_print)
        for PaperKind_ in self.PaperKind:
            namespaceprefix_ = self.PaperKind_nsprefix_ + ':' if (UseCapturedNS_ and self.PaperKind_nsprefix_) else ''
            PaperKind_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PaperKind', pretty_print=pretty_print)
        for PaperSource_ in self.PaperSource:
            namespaceprefix_ = self.PaperSource_nsprefix_ + ':' if (UseCapturedNS_ and self.PaperSource_nsprefix_) else ''
            PaperSource_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PaperSource', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PrintProps_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PageLeftMargin':
            obj_ = PageLeftMargin_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PageLeftMargin.append(obj_)
            obj_.original_tagname_ = 'PageLeftMargin'
        elif nodeName_ == 'PageRightMargin':
            obj_ = PageRightMargin_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PageRightMargin.append(obj_)
            obj_.original_tagname_ = 'PageRightMargin'
        elif nodeName_ == 'PageTopMargin':
            obj_ = PageTopMargin_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PageTopMargin.append(obj_)
            obj_.original_tagname_ = 'PageTopMargin'
        elif nodeName_ == 'PageBottomMargin':
            obj_ = PageBottomMargin_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PageBottomMargin.append(obj_)
            obj_.original_tagname_ = 'PageBottomMargin'
        elif nodeName_ == 'ScaleX':
            obj_ = ScaleX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ScaleX.append(obj_)
            obj_.original_tagname_ = 'ScaleX'
        elif nodeName_ == 'ScaleY':
            obj_ = ScaleY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ScaleY.append(obj_)
            obj_.original_tagname_ = 'ScaleY'
        elif nodeName_ == 'PagesX':
            obj_ = PagesX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PagesX.append(obj_)
            obj_.original_tagname_ = 'PagesX'
        elif nodeName_ == 'PagesY':
            obj_ = PagesY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PagesY.append(obj_)
            obj_.original_tagname_ = 'PagesY'
        elif nodeName_ == 'CenterX':
            obj_ = CenterX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CenterX.append(obj_)
            obj_.original_tagname_ = 'CenterX'
        elif nodeName_ == 'CenterY':
            obj_ = CenterY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CenterY.append(obj_)
            obj_.original_tagname_ = 'CenterY'
        elif nodeName_ == 'OnPage':
            obj_ = OnPage_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OnPage.append(obj_)
            obj_.original_tagname_ = 'OnPage'
        elif nodeName_ == 'PrintGrid':
            obj_ = PrintGrid_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrintGrid.append(obj_)
            obj_.original_tagname_ = 'PrintGrid'
        elif nodeName_ == 'PrintPageOrientation':
            obj_ = PrintPageOrientation_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrintPageOrientation.append(obj_)
            obj_.original_tagname_ = 'PrintPageOrientation'
        elif nodeName_ == 'PaperKind':
            obj_ = PaperKind_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PaperKind.append(obj_)
            obj_.original_tagname_ = 'PaperKind'
        elif nodeName_ == 'PaperSource':
            obj_ = PaperSource_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PaperSource.append(obj_)
            obj_.original_tagname_ = 'PaperSource'
        super(PrintProps_Type, self).buildChildren(child_, node, nodeName_, True)
# end class PrintProps_Type


class PageLeftMargin_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PageLeftMargin_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PageLeftMargin_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PageLeftMargin_Type.subclass:
            return PageLeftMargin_Type.subclass(*args_, **kwargs_)
        else:
            return PageLeftMargin_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PageLeftMargin_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageLeftMargin_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PageLeftMargin_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PageLeftMargin_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageLeftMargin_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PageLeftMargin_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PageLeftMargin_Type'):
        super(PageLeftMargin_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageLeftMargin_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageLeftMargin_Type', fromsubclass_=False, pretty_print=True):
        super(PageLeftMargin_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PageLeftMargin_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PageLeftMargin_Type


class PageRightMargin_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PageRightMargin_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PageRightMargin_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PageRightMargin_Type.subclass:
            return PageRightMargin_Type.subclass(*args_, **kwargs_)
        else:
            return PageRightMargin_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PageRightMargin_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageRightMargin_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PageRightMargin_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PageRightMargin_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageRightMargin_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PageRightMargin_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PageRightMargin_Type'):
        super(PageRightMargin_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageRightMargin_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageRightMargin_Type', fromsubclass_=False, pretty_print=True):
        super(PageRightMargin_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PageRightMargin_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PageRightMargin_Type


class PageTopMargin_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PageTopMargin_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PageTopMargin_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PageTopMargin_Type.subclass:
            return PageTopMargin_Type.subclass(*args_, **kwargs_)
        else:
            return PageTopMargin_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PageTopMargin_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageTopMargin_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PageTopMargin_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PageTopMargin_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageTopMargin_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PageTopMargin_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PageTopMargin_Type'):
        super(PageTopMargin_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageTopMargin_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageTopMargin_Type', fromsubclass_=False, pretty_print=True):
        super(PageTopMargin_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PageTopMargin_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PageTopMargin_Type


class PageBottomMargin_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PageBottomMargin_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PageBottomMargin_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PageBottomMargin_Type.subclass:
            return PageBottomMargin_Type.subclass(*args_, **kwargs_)
        else:
            return PageBottomMargin_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PageBottomMargin_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageBottomMargin_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PageBottomMargin_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PageBottomMargin_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageBottomMargin_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PageBottomMargin_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PageBottomMargin_Type'):
        super(PageBottomMargin_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PageBottomMargin_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PageBottomMargin_Type', fromsubclass_=False, pretty_print=True):
        super(PageBottomMargin_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PageBottomMargin_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PageBottomMargin_Type


class ScaleX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ScaleX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScaleX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScaleX_Type.subclass:
            return ScaleX_Type.subclass(*args_, **kwargs_)
        else:
            return ScaleX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ScaleX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ScaleX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ScaleX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ScaleX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ScaleX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ScaleX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ScaleX_Type'):
        super(ScaleX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ScaleX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ScaleX_Type', fromsubclass_=False, pretty_print=True):
        super(ScaleX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ScaleX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ScaleX_Type


class ScaleY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ScaleY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScaleY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScaleY_Type.subclass:
            return ScaleY_Type.subclass(*args_, **kwargs_)
        else:
            return ScaleY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ScaleY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ScaleY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ScaleY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ScaleY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ScaleY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ScaleY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ScaleY_Type'):
        super(ScaleY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ScaleY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ScaleY_Type', fromsubclass_=False, pretty_print=True):
        super(ScaleY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ScaleY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ScaleY_Type


class PagesX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PagesX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PagesX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PagesX_Type.subclass:
            return PagesX_Type.subclass(*args_, **kwargs_)
        else:
            return PagesX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PagesX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PagesX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PagesX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PagesX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PagesX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PagesX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PagesX_Type'):
        super(PagesX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PagesX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PagesX_Type', fromsubclass_=False, pretty_print=True):
        super(PagesX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PagesX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PagesX_Type


class PagesY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PagesY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PagesY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PagesY_Type.subclass:
            return PagesY_Type.subclass(*args_, **kwargs_)
        else:
            return PagesY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PagesY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PagesY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PagesY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PagesY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PagesY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PagesY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PagesY_Type'):
        super(PagesY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PagesY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PagesY_Type', fromsubclass_=False, pretty_print=True):
        super(PagesY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PagesY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PagesY_Type


class CenterX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CenterX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CenterX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CenterX_Type.subclass:
            return CenterX_Type.subclass(*args_, **kwargs_)
        else:
            return CenterX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(CenterX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CenterX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CenterX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CenterX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CenterX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CenterX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CenterX_Type'):
        super(CenterX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CenterX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CenterX_Type', fromsubclass_=False, pretty_print=True):
        super(CenterX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CenterX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CenterX_Type


class CenterY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CenterY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CenterY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CenterY_Type.subclass:
            return CenterY_Type.subclass(*args_, **kwargs_)
        else:
            return CenterY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(CenterY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CenterY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CenterY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CenterY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CenterY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CenterY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CenterY_Type'):
        super(CenterY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CenterY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CenterY_Type', fromsubclass_=False, pretty_print=True):
        super(CenterY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CenterY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CenterY_Type


class OnPage_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(OnPage_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OnPage_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OnPage_Type.subclass:
            return OnPage_Type.subclass(*args_, **kwargs_)
        else:
            return OnPage_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(OnPage_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OnPage_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OnPage_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OnPage_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OnPage_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OnPage_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OnPage_Type'):
        super(OnPage_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OnPage_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OnPage_Type', fromsubclass_=False, pretty_print=True):
        super(OnPage_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OnPage_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class OnPage_Type


class PrintGrid_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PrintGrid_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrintGrid_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrintGrid_Type.subclass:
            return PrintGrid_Type.subclass(*args_, **kwargs_)
        else:
            return PrintGrid_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PrintGrid_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrintGrid_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PrintGrid_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PrintGrid_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrintGrid_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PrintGrid_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PrintGrid_Type'):
        super(PrintGrid_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrintGrid_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrintGrid_Type', fromsubclass_=False, pretty_print=True):
        super(PrintGrid_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PrintGrid_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PrintGrid_Type


class PrintPageOrientation_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PrintPageOrientation_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrintPageOrientation_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrintPageOrientation_Type.subclass:
            return PrintPageOrientation_Type.subclass(*args_, **kwargs_)
        else:
            return PrintPageOrientation_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PrintPageOrientation_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrintPageOrientation_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PrintPageOrientation_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PrintPageOrientation_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrintPageOrientation_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PrintPageOrientation_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PrintPageOrientation_Type'):
        super(PrintPageOrientation_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrintPageOrientation_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrintPageOrientation_Type', fromsubclass_=False, pretty_print=True):
        super(PrintPageOrientation_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PrintPageOrientation_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PrintPageOrientation_Type


class PaperKind_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PaperKind_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaperKind_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaperKind_Type.subclass:
            return PaperKind_Type.subclass(*args_, **kwargs_)
        else:
            return PaperKind_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PaperKind_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PaperKind_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PaperKind_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PaperKind_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PaperKind_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PaperKind_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PaperKind_Type'):
        super(PaperKind_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PaperKind_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PaperKind_Type', fromsubclass_=False, pretty_print=True):
        super(PaperKind_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PaperKind_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PaperKind_Type


class PaperSource_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PaperSource_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaperSource_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaperSource_Type.subclass:
            return PaperSource_Type.subclass(*args_, **kwargs_)
        else:
            return PaperSource_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(PaperSource_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PaperSource_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PaperSource_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PaperSource_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PaperSource_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PaperSource_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PaperSource_Type'):
        super(PaperSource_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PaperSource_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PaperSource_Type', fromsubclass_=False, pretty_print=True):
        super(PaperSource_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PaperSource_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PaperSource_Type


class Char_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, Font=None, Color=None, Style=None, Case=None, Pos=None, FontScale=None, Locale=None, Size=None, DblUnderline=None, Overline=None, Strikethru=None, Highlight=None, Perpendicular=None, DoubleStrikethrough=None, RTLText=None, UseVertical=None, Letterspace=None, ColorTrans=None, AsianFont=None, ComplexScriptFont=None, LocalizeFont=None, ComplexScriptSize=None, LangID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Char_Type, self).__init__(IX, Del,  **kwargs_)
        self.Font = Font
        self.Font_nsprefix_ = None
        self.Color = Color
        self.Color_nsprefix_ = None
        self.Style = Style
        self.Style_nsprefix_ = None
        self.Case = Case
        self.Case_nsprefix_ = None
        self.Pos = Pos
        self.Pos_nsprefix_ = None
        self.FontScale = FontScale
        self.FontScale_nsprefix_ = None
        self.Locale = Locale
        self.Locale_nsprefix_ = None
        self.Size = Size
        self.Size_nsprefix_ = None
        self.DblUnderline = DblUnderline
        self.DblUnderline_nsprefix_ = None
        self.Overline = Overline
        self.Overline_nsprefix_ = None
        self.Strikethru = Strikethru
        self.Strikethru_nsprefix_ = None
        self.Highlight = Highlight
        self.Highlight_nsprefix_ = None
        self.Perpendicular = Perpendicular
        self.Perpendicular_nsprefix_ = None
        self.DoubleStrikethrough = DoubleStrikethrough
        self.DoubleStrikethrough_nsprefix_ = None
        self.RTLText = RTLText
        self.RTLText_nsprefix_ = None
        self.UseVertical = UseVertical
        self.UseVertical_nsprefix_ = None
        self.Letterspace = Letterspace
        self.Letterspace_nsprefix_ = None
        self.ColorTrans = ColorTrans
        self.ColorTrans_nsprefix_ = None
        self.AsianFont = AsianFont
        self.AsianFont_nsprefix_ = None
        self.ComplexScriptFont = ComplexScriptFont
        self.ComplexScriptFont_nsprefix_ = None
        self.LocalizeFont = LocalizeFont
        self.LocalizeFont_nsprefix_ = None
        self.ComplexScriptSize = ComplexScriptSize
        self.ComplexScriptSize_nsprefix_ = None
        self.LangID = LangID
        self.LangID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Char_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Char_Type.subclass:
            return Char_Type.subclass(*args_, **kwargs_)
        else:
            return Char_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Font(self):
        return self.Font
    def set_Font(self, Font):
        self.Font = Font
    def get_Color(self):
        return self.Color
    def set_Color(self, Color):
        self.Color = Color
    def get_Style(self):
        return self.Style
    def set_Style(self, Style):
        self.Style = Style
    def get_Case(self):
        return self.Case
    def set_Case(self, Case):
        self.Case = Case
    def get_Pos(self):
        return self.Pos
    def set_Pos(self, Pos):
        self.Pos = Pos
    def get_FontScale(self):
        return self.FontScale
    def set_FontScale(self, FontScale):
        self.FontScale = FontScale
    def get_Locale(self):
        return self.Locale
    def set_Locale(self, Locale):
        self.Locale = Locale
    def get_Size(self):
        return self.Size
    def set_Size(self, Size):
        self.Size = Size
    def get_DblUnderline(self):
        return self.DblUnderline
    def set_DblUnderline(self, DblUnderline):
        self.DblUnderline = DblUnderline
    def get_Overline(self):
        return self.Overline
    def set_Overline(self, Overline):
        self.Overline = Overline
    def get_Strikethru(self):
        return self.Strikethru
    def set_Strikethru(self, Strikethru):
        self.Strikethru = Strikethru
    def get_Highlight(self):
        return self.Highlight
    def set_Highlight(self, Highlight):
        self.Highlight = Highlight
    def get_Perpendicular(self):
        return self.Perpendicular
    def set_Perpendicular(self, Perpendicular):
        self.Perpendicular = Perpendicular
    def get_DoubleStrikethrough(self):
        return self.DoubleStrikethrough
    def set_DoubleStrikethrough(self, DoubleStrikethrough):
        self.DoubleStrikethrough = DoubleStrikethrough
    def get_RTLText(self):
        return self.RTLText
    def set_RTLText(self, RTLText):
        self.RTLText = RTLText
    def get_UseVertical(self):
        return self.UseVertical
    def set_UseVertical(self, UseVertical):
        self.UseVertical = UseVertical
    def get_Letterspace(self):
        return self.Letterspace
    def set_Letterspace(self, Letterspace):
        self.Letterspace = Letterspace
    def get_ColorTrans(self):
        return self.ColorTrans
    def set_ColorTrans(self, ColorTrans):
        self.ColorTrans = ColorTrans
    def get_AsianFont(self):
        return self.AsianFont
    def set_AsianFont(self, AsianFont):
        self.AsianFont = AsianFont
    def get_ComplexScriptFont(self):
        return self.ComplexScriptFont
    def set_ComplexScriptFont(self, ComplexScriptFont):
        self.ComplexScriptFont = ComplexScriptFont
    def get_LocalizeFont(self):
        return self.LocalizeFont
    def set_LocalizeFont(self, LocalizeFont):
        self.LocalizeFont = LocalizeFont
    def get_ComplexScriptSize(self):
        return self.ComplexScriptSize
    def set_ComplexScriptSize(self, ComplexScriptSize):
        self.ComplexScriptSize = ComplexScriptSize
    def get_LangID(self):
        return self.LangID
    def set_LangID(self, LangID):
        self.LangID = LangID
    def hasContent_(self):
        if (
            self.Font is not None or
            self.Color is not None or
            self.Style is not None or
            self.Case is not None or
            self.Pos is not None or
            self.FontScale is not None or
            self.Locale is not None or
            self.Size is not None or
            self.DblUnderline is not None or
            self.Overline is not None or
            self.Strikethru is not None or
            self.Highlight is not None or
            self.Perpendicular is not None or
            self.DoubleStrikethrough is not None or
            self.RTLText is not None or
            self.UseVertical is not None or
            self.Letterspace is not None or
            self.ColorTrans is not None or
            self.AsianFont is not None or
            self.ComplexScriptFont is not None or
            self.LocalizeFont is not None or
            self.ComplexScriptSize is not None or
            self.LangID is not None or
            super(Char_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Char_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Char_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Char_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Char_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Char_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Char_Type'):
        super(Char_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Char_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Char_Type', fromsubclass_=False, pretty_print=True):
        super(Char_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Font is not None:
            namespaceprefix_ = self.Font_nsprefix_ + ':' if (UseCapturedNS_ and self.Font_nsprefix_) else ''
            self.Font.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Font', pretty_print=pretty_print)
        if self.Color is not None:
            namespaceprefix_ = self.Color_nsprefix_ + ':' if (UseCapturedNS_ and self.Color_nsprefix_) else ''
            self.Color.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Color', pretty_print=pretty_print)
        if self.Style is not None:
            namespaceprefix_ = self.Style_nsprefix_ + ':' if (UseCapturedNS_ and self.Style_nsprefix_) else ''
            self.Style.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Style', pretty_print=pretty_print)
        if self.Case is not None:
            namespaceprefix_ = self.Case_nsprefix_ + ':' if (UseCapturedNS_ and self.Case_nsprefix_) else ''
            self.Case.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Case', pretty_print=pretty_print)
        if self.Pos is not None:
            namespaceprefix_ = self.Pos_nsprefix_ + ':' if (UseCapturedNS_ and self.Pos_nsprefix_) else ''
            self.Pos.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Pos', pretty_print=pretty_print)
        if self.FontScale is not None:
            namespaceprefix_ = self.FontScale_nsprefix_ + ':' if (UseCapturedNS_ and self.FontScale_nsprefix_) else ''
            self.FontScale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FontScale', pretty_print=pretty_print)
        if self.Locale is not None:
            namespaceprefix_ = self.Locale_nsprefix_ + ':' if (UseCapturedNS_ and self.Locale_nsprefix_) else ''
            self.Locale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Locale', pretty_print=pretty_print)
        if self.Size is not None:
            namespaceprefix_ = self.Size_nsprefix_ + ':' if (UseCapturedNS_ and self.Size_nsprefix_) else ''
            self.Size.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Size', pretty_print=pretty_print)
        if self.DblUnderline is not None:
            namespaceprefix_ = self.DblUnderline_nsprefix_ + ':' if (UseCapturedNS_ and self.DblUnderline_nsprefix_) else ''
            self.DblUnderline.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DblUnderline', pretty_print=pretty_print)
        if self.Overline is not None:
            namespaceprefix_ = self.Overline_nsprefix_ + ':' if (UseCapturedNS_ and self.Overline_nsprefix_) else ''
            self.Overline.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Overline', pretty_print=pretty_print)
        if self.Strikethru is not None:
            namespaceprefix_ = self.Strikethru_nsprefix_ + ':' if (UseCapturedNS_ and self.Strikethru_nsprefix_) else ''
            self.Strikethru.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Strikethru', pretty_print=pretty_print)
        if self.Highlight is not None:
            namespaceprefix_ = self.Highlight_nsprefix_ + ':' if (UseCapturedNS_ and self.Highlight_nsprefix_) else ''
            self.Highlight.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Highlight', pretty_print=pretty_print)
        if self.Perpendicular is not None:
            namespaceprefix_ = self.Perpendicular_nsprefix_ + ':' if (UseCapturedNS_ and self.Perpendicular_nsprefix_) else ''
            self.Perpendicular.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Perpendicular', pretty_print=pretty_print)
        if self.DoubleStrikethrough is not None:
            namespaceprefix_ = self.DoubleStrikethrough_nsprefix_ + ':' if (UseCapturedNS_ and self.DoubleStrikethrough_nsprefix_) else ''
            self.DoubleStrikethrough.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DoubleStrikethrough', pretty_print=pretty_print)
        if self.RTLText is not None:
            namespaceprefix_ = self.RTLText_nsprefix_ + ':' if (UseCapturedNS_ and self.RTLText_nsprefix_) else ''
            self.RTLText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RTLText', pretty_print=pretty_print)
        if self.UseVertical is not None:
            namespaceprefix_ = self.UseVertical_nsprefix_ + ':' if (UseCapturedNS_ and self.UseVertical_nsprefix_) else ''
            self.UseVertical.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UseVertical', pretty_print=pretty_print)
        if self.Letterspace is not None:
            namespaceprefix_ = self.Letterspace_nsprefix_ + ':' if (UseCapturedNS_ and self.Letterspace_nsprefix_) else ''
            self.Letterspace.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Letterspace', pretty_print=pretty_print)
        if self.ColorTrans is not None:
            namespaceprefix_ = self.ColorTrans_nsprefix_ + ':' if (UseCapturedNS_ and self.ColorTrans_nsprefix_) else ''
            self.ColorTrans.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ColorTrans', pretty_print=pretty_print)
        if self.AsianFont is not None:
            namespaceprefix_ = self.AsianFont_nsprefix_ + ':' if (UseCapturedNS_ and self.AsianFont_nsprefix_) else ''
            self.AsianFont.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AsianFont', pretty_print=pretty_print)
        if self.ComplexScriptFont is not None:
            namespaceprefix_ = self.ComplexScriptFont_nsprefix_ + ':' if (UseCapturedNS_ and self.ComplexScriptFont_nsprefix_) else ''
            self.ComplexScriptFont.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ComplexScriptFont', pretty_print=pretty_print)
        if self.LocalizeFont is not None:
            namespaceprefix_ = self.LocalizeFont_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalizeFont_nsprefix_) else ''
            self.LocalizeFont.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalizeFont', pretty_print=pretty_print)
        if self.ComplexScriptSize is not None:
            namespaceprefix_ = self.ComplexScriptSize_nsprefix_ + ':' if (UseCapturedNS_ and self.ComplexScriptSize_nsprefix_) else ''
            self.ComplexScriptSize.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ComplexScriptSize', pretty_print=pretty_print)
        if self.LangID is not None:
            namespaceprefix_ = self.LangID_nsprefix_ + ':' if (UseCapturedNS_ and self.LangID_nsprefix_) else ''
            self.LangID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LangID', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Char_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Font':
            obj_ = Font_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Font = obj_
            obj_.original_tagname_ = 'Font'
        elif nodeName_ == 'Color':
            obj_ = Color_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Color = obj_
            obj_.original_tagname_ = 'Color'
        elif nodeName_ == 'Style':
            obj_ = Style_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Style = obj_
            obj_.original_tagname_ = 'Style'
        elif nodeName_ == 'Case':
            obj_ = Case_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Case = obj_
            obj_.original_tagname_ = 'Case'
        elif nodeName_ == 'Pos':
            obj_ = Pos_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Pos = obj_
            obj_.original_tagname_ = 'Pos'
        elif nodeName_ == 'FontScale':
            obj_ = FontScale_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FontScale = obj_
            obj_.original_tagname_ = 'FontScale'
        elif nodeName_ == 'Locale':
            obj_ = Locale_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Locale = obj_
            obj_.original_tagname_ = 'Locale'
        elif nodeName_ == 'Size':
            obj_ = Size_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Size = obj_
            obj_.original_tagname_ = 'Size'
        elif nodeName_ == 'DblUnderline':
            obj_ = DblUnderline_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DblUnderline = obj_
            obj_.original_tagname_ = 'DblUnderline'
        elif nodeName_ == 'Overline':
            obj_ = Overline_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Overline = obj_
            obj_.original_tagname_ = 'Overline'
        elif nodeName_ == 'Strikethru':
            obj_ = Strikethru_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Strikethru = obj_
            obj_.original_tagname_ = 'Strikethru'
        elif nodeName_ == 'Highlight':
            obj_ = Highlight_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Highlight = obj_
            obj_.original_tagname_ = 'Highlight'
        elif nodeName_ == 'Perpendicular':
            obj_ = Perpendicular_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Perpendicular = obj_
            obj_.original_tagname_ = 'Perpendicular'
        elif nodeName_ == 'DoubleStrikethrough':
            obj_ = DoubleStrikethrough_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DoubleStrikethrough = obj_
            obj_.original_tagname_ = 'DoubleStrikethrough'
        elif nodeName_ == 'RTLText':
            obj_ = RTLText_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RTLText = obj_
            obj_.original_tagname_ = 'RTLText'
        elif nodeName_ == 'UseVertical':
            obj_ = UseVertical_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UseVertical = obj_
            obj_.original_tagname_ = 'UseVertical'
        elif nodeName_ == 'Letterspace':
            obj_ = Letterspace_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Letterspace = obj_
            obj_.original_tagname_ = 'Letterspace'
        elif nodeName_ == 'ColorTrans':
            obj_ = ColorTrans_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ColorTrans = obj_
            obj_.original_tagname_ = 'ColorTrans'
        elif nodeName_ == 'AsianFont':
            obj_ = AsianFont_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AsianFont = obj_
            obj_.original_tagname_ = 'AsianFont'
        elif nodeName_ == 'ComplexScriptFont':
            obj_ = ComplexScriptFont_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ComplexScriptFont = obj_
            obj_.original_tagname_ = 'ComplexScriptFont'
        elif nodeName_ == 'LocalizeFont':
            obj_ = LocalizeFont_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalizeFont = obj_
            obj_.original_tagname_ = 'LocalizeFont'
        elif nodeName_ == 'ComplexScriptSize':
            obj_ = ComplexScriptSize_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ComplexScriptSize = obj_
            obj_.original_tagname_ = 'ComplexScriptSize'
        elif nodeName_ == 'LangID':
            obj_ = LangID_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LangID = obj_
            obj_.original_tagname_ = 'LangID'
        super(Char_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Char_Type


class Font_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Font_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Font_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Font_Type.subclass:
            return Font_Type.subclass(*args_, **kwargs_)
        else:
            return Font_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Font_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Font_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Font_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Font_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Font_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Font_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Font_Type'):
        super(Font_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Font_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Font_Type', fromsubclass_=False, pretty_print=True):
        super(Font_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Font_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Font_Type


class Color_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Color_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Color_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Color_Type.subclass:
            return Color_Type.subclass(*args_, **kwargs_)
        else:
            return Color_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Color_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Color_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Color_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Color_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Color_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Color_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Color_Type'):
        super(Color_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Color_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Color_Type', fromsubclass_=False, pretty_print=True):
        super(Color_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Color_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Color_Type


class Style_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Style_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Style_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Style_Type.subclass:
            return Style_Type.subclass(*args_, **kwargs_)
        else:
            return Style_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Style_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Style_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Style_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Style_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Style_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Style_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Style_Type'):
        super(Style_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Style_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Style_Type', fromsubclass_=False, pretty_print=True):
        super(Style_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Style_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Style_Type


class Case_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Case_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Case_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Case_Type.subclass:
            return Case_Type.subclass(*args_, **kwargs_)
        else:
            return Case_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Case_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Case_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Case_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Case_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Case_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Case_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Case_Type'):
        super(Case_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Case_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Case_Type', fromsubclass_=False, pretty_print=True):
        super(Case_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Case_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Case_Type


class Pos_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Pos_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Pos_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Pos_Type.subclass:
            return Pos_Type.subclass(*args_, **kwargs_)
        else:
            return Pos_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Pos_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Pos_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Pos_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Pos_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Pos_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Pos_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Pos_Type'):
        super(Pos_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Pos_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Pos_Type', fromsubclass_=False, pretty_print=True):
        super(Pos_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Pos_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Pos_Type


class FontScale_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FontScale_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FontScale_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FontScale_Type.subclass:
            return FontScale_Type.subclass(*args_, **kwargs_)
        else:
            return FontScale_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(FontScale_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FontScale_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FontScale_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FontScale_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FontScale_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FontScale_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FontScale_Type'):
        super(FontScale_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FontScale_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FontScale_Type', fromsubclass_=False, pretty_print=True):
        super(FontScale_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FontScale_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FontScale_Type


class Locale_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Locale_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Locale_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Locale_Type.subclass:
            return Locale_Type.subclass(*args_, **kwargs_)
        else:
            return Locale_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Locale_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Locale_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Locale_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Locale_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Locale_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Locale_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Locale_Type'):
        super(Locale_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Locale_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Locale_Type', fromsubclass_=False, pretty_print=True):
        super(Locale_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Locale_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Locale_Type


class Size_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Size_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Size_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Size_Type.subclass:
            return Size_Type.subclass(*args_, **kwargs_)
        else:
            return Size_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Size_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Size_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Size_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Size_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Size_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Size_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Size_Type'):
        super(Size_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Size_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Size_Type', fromsubclass_=False, pretty_print=True):
        super(Size_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Size_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Size_Type


class DblUnderline_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DblUnderline_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DblUnderline_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DblUnderline_Type.subclass:
            return DblUnderline_Type.subclass(*args_, **kwargs_)
        else:
            return DblUnderline_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DblUnderline_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DblUnderline_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DblUnderline_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DblUnderline_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DblUnderline_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DblUnderline_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DblUnderline_Type'):
        super(DblUnderline_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DblUnderline_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DblUnderline_Type', fromsubclass_=False, pretty_print=True):
        super(DblUnderline_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DblUnderline_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DblUnderline_Type


class Overline_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Overline_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Overline_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Overline_Type.subclass:
            return Overline_Type.subclass(*args_, **kwargs_)
        else:
            return Overline_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Overline_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Overline_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Overline_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Overline_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Overline_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Overline_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Overline_Type'):
        super(Overline_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Overline_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Overline_Type', fromsubclass_=False, pretty_print=True):
        super(Overline_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Overline_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Overline_Type


class Strikethru_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Strikethru_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Strikethru_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Strikethru_Type.subclass:
            return Strikethru_Type.subclass(*args_, **kwargs_)
        else:
            return Strikethru_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Strikethru_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Strikethru_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Strikethru_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Strikethru_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Strikethru_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Strikethru_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Strikethru_Type'):
        super(Strikethru_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Strikethru_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Strikethru_Type', fromsubclass_=False, pretty_print=True):
        super(Strikethru_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Strikethru_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Strikethru_Type


class Highlight_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Highlight_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Highlight_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Highlight_Type.subclass:
            return Highlight_Type.subclass(*args_, **kwargs_)
        else:
            return Highlight_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Highlight_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Highlight_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Highlight_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Highlight_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Highlight_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Highlight_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Highlight_Type'):
        super(Highlight_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Highlight_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Highlight_Type', fromsubclass_=False, pretty_print=True):
        super(Highlight_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Highlight_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Highlight_Type


class Perpendicular_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Perpendicular_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Perpendicular_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Perpendicular_Type.subclass:
            return Perpendicular_Type.subclass(*args_, **kwargs_)
        else:
            return Perpendicular_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Perpendicular_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Perpendicular_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Perpendicular_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Perpendicular_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Perpendicular_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Perpendicular_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Perpendicular_Type'):
        super(Perpendicular_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Perpendicular_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Perpendicular_Type', fromsubclass_=False, pretty_print=True):
        super(Perpendicular_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Perpendicular_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Perpendicular_Type


class DoubleStrikethrough_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DoubleStrikethrough_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DoubleStrikethrough_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DoubleStrikethrough_Type.subclass:
            return DoubleStrikethrough_Type.subclass(*args_, **kwargs_)
        else:
            return DoubleStrikethrough_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DoubleStrikethrough_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DoubleStrikethrough_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DoubleStrikethrough_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DoubleStrikethrough_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DoubleStrikethrough_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DoubleStrikethrough_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DoubleStrikethrough_Type'):
        super(DoubleStrikethrough_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DoubleStrikethrough_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DoubleStrikethrough_Type', fromsubclass_=False, pretty_print=True):
        super(DoubleStrikethrough_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DoubleStrikethrough_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DoubleStrikethrough_Type


class RTLText_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RTLText_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RTLText_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RTLText_Type.subclass:
            return RTLText_Type.subclass(*args_, **kwargs_)
        else:
            return RTLText_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(RTLText_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RTLText_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RTLText_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RTLText_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTLText_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RTLText_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RTLText_Type'):
        super(RTLText_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RTLText_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RTLText_Type', fromsubclass_=False, pretty_print=True):
        super(RTLText_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RTLText_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RTLText_Type


class UseVertical_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(UseVertical_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UseVertical_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UseVertical_Type.subclass:
            return UseVertical_Type.subclass(*args_, **kwargs_)
        else:
            return UseVertical_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(UseVertical_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UseVertical_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UseVertical_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UseVertical_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UseVertical_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UseVertical_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UseVertical_Type'):
        super(UseVertical_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UseVertical_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UseVertical_Type', fromsubclass_=False, pretty_print=True):
        super(UseVertical_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UseVertical_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class UseVertical_Type


class Letterspace_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Letterspace_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Letterspace_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Letterspace_Type.subclass:
            return Letterspace_Type.subclass(*args_, **kwargs_)
        else:
            return Letterspace_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Letterspace_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Letterspace_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Letterspace_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Letterspace_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Letterspace_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Letterspace_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Letterspace_Type'):
        super(Letterspace_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Letterspace_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Letterspace_Type', fromsubclass_=False, pretty_print=True):
        super(Letterspace_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Letterspace_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Letterspace_Type


class ColorTrans_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ColorTrans_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ColorTrans_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ColorTrans_Type.subclass:
            return ColorTrans_Type.subclass(*args_, **kwargs_)
        else:
            return ColorTrans_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ColorTrans_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ColorTrans_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ColorTrans_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ColorTrans_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ColorTrans_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ColorTrans_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ColorTrans_Type'):
        super(ColorTrans_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ColorTrans_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ColorTrans_Type', fromsubclass_=False, pretty_print=True):
        super(ColorTrans_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ColorTrans_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ColorTrans_Type


class Hidden_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Hidden_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Hidden_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Hidden_Type.subclass:
            return Hidden_Type.subclass(*args_, **kwargs_)
        else:
            return Hidden_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Hidden_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Hidden_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Hidden_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Hidden_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Hidden_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Hidden_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Hidden_Type'):
        super(Hidden_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Hidden_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Hidden_Type', fromsubclass_=False, pretty_print=True):
        super(Hidden_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Hidden_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Hidden_Type


class UseKerning_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(UseKerning_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UseKerning_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UseKerning_Type.subclass:
            return UseKerning_Type.subclass(*args_, **kwargs_)
        else:
            return UseKerning_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(UseKerning_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UseKerning_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UseKerning_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UseKerning_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UseKerning_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UseKerning_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UseKerning_Type'):
        super(UseKerning_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UseKerning_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UseKerning_Type', fromsubclass_=False, pretty_print=True):
        super(UseKerning_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UseKerning_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class UseKerning_Type


class UseNationalDigit_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(UseNationalDigit_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UseNationalDigit_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UseNationalDigit_Type.subclass:
            return UseNationalDigit_Type.subclass(*args_, **kwargs_)
        else:
            return UseNationalDigit_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(UseNationalDigit_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UseNationalDigit_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UseNationalDigit_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UseNationalDigit_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UseNationalDigit_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UseNationalDigit_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UseNationalDigit_Type'):
        super(UseNationalDigit_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UseNationalDigit_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UseNationalDigit_Type', fromsubclass_=False, pretty_print=True):
        super(UseNationalDigit_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UseNationalDigit_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class UseNationalDigit_Type


class NoBreak_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NoBreak_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoBreak_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoBreak_Type.subclass:
            return NoBreak_Type.subclass(*args_, **kwargs_)
        else:
            return NoBreak_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(NoBreak_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoBreak_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NoBreak_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NoBreak_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoBreak_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NoBreak_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NoBreak_Type'):
        super(NoBreak_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoBreak_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoBreak_Type', fromsubclass_=False, pretty_print=True):
        super(NoBreak_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NoBreak_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NoBreak_Type


class Outline_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Outline_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Outline_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Outline_Type.subclass:
            return Outline_Type.subclass(*args_, **kwargs_)
        else:
            return Outline_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Outline_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Outline_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Outline_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Outline_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Outline_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Outline_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Outline_Type'):
        super(Outline_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Outline_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Outline_Type', fromsubclass_=False, pretty_print=True):
        super(Outline_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Outline_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Outline_Type


class NoHyphenate_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NoHyphenate_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoHyphenate_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoHyphenate_Type.subclass:
            return NoHyphenate_Type.subclass(*args_, **kwargs_)
        else:
            return NoHyphenate_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(NoHyphenate_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoHyphenate_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NoHyphenate_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NoHyphenate_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoHyphenate_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NoHyphenate_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NoHyphenate_Type'):
        super(NoHyphenate_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoHyphenate_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoHyphenate_Type', fromsubclass_=False, pretty_print=True):
        super(NoHyphenate_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NoHyphenate_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NoHyphenate_Type


class FontDirection_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FontDirection_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FontDirection_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FontDirection_Type.subclass:
            return FontDirection_Type.subclass(*args_, **kwargs_)
        else:
            return FontDirection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(FontDirection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FontDirection_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FontDirection_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FontDirection_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FontDirection_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FontDirection_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FontDirection_Type'):
        super(FontDirection_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FontDirection_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FontDirection_Type', fromsubclass_=False, pretty_print=True):
        super(FontDirection_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FontDirection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FontDirection_Type


class Spelling_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Spelling_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Spelling_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Spelling_Type.subclass:
            return Spelling_Type.subclass(*args_, **kwargs_)
        else:
            return Spelling_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Spelling_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Spelling_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Spelling_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Spelling_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Spelling_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Spelling_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Spelling_Type'):
        super(Spelling_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Spelling_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Spelling_Type', fromsubclass_=False, pretty_print=True):
        super(Spelling_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Spelling_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Spelling_Type


class Grammar_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Grammar_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Grammar_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Grammar_Type.subclass:
            return Grammar_Type.subclass(*args_, **kwargs_)
        else:
            return Grammar_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Grammar_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Grammar_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Grammar_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Grammar_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Grammar_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Grammar_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Grammar_Type'):
        super(Grammar_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Grammar_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Grammar_Type', fromsubclass_=False, pretty_print=True):
        super(Grammar_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Grammar_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Grammar_Type


class Inconsistent_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Inconsistent_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Inconsistent_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Inconsistent_Type.subclass:
            return Inconsistent_Type.subclass(*args_, **kwargs_)
        else:
            return Inconsistent_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Inconsistent_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Inconsistent_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Inconsistent_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Inconsistent_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Inconsistent_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Inconsistent_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Inconsistent_Type'):
        super(Inconsistent_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Inconsistent_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Inconsistent_Type', fromsubclass_=False, pretty_print=True):
        super(Inconsistent_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Inconsistent_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Inconsistent_Type


class SmartTag_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SmartTag_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SmartTag_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SmartTag_Type.subclass:
            return SmartTag_Type.subclass(*args_, **kwargs_)
        else:
            return SmartTag_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(SmartTag_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SmartTag_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SmartTag_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SmartTag_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SmartTag_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SmartTag_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SmartTag_Type'):
        super(SmartTag_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SmartTag_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SmartTag_Type', fromsubclass_=False, pretty_print=True):
        super(SmartTag_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SmartTag_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SmartTag_Type


class AsianFont_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AsianFont_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AsianFont_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AsianFont_Type.subclass:
            return AsianFont_Type.subclass(*args_, **kwargs_)
        else:
            return AsianFont_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AsianFont_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AsianFont_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AsianFont_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AsianFont_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AsianFont_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AsianFont_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AsianFont_Type'):
        super(AsianFont_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AsianFont_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AsianFont_Type', fromsubclass_=False, pretty_print=True):
        super(AsianFont_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AsianFont_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AsianFont_Type


class ComplexScriptFont_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ComplexScriptFont_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComplexScriptFont_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComplexScriptFont_Type.subclass:
            return ComplexScriptFont_Type.subclass(*args_, **kwargs_)
        else:
            return ComplexScriptFont_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ComplexScriptFont_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ComplexScriptFont_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ComplexScriptFont_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ComplexScriptFont_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ComplexScriptFont_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ComplexScriptFont_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ComplexScriptFont_Type'):
        super(ComplexScriptFont_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ComplexScriptFont_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ComplexScriptFont_Type', fromsubclass_=False, pretty_print=True):
        super(ComplexScriptFont_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ComplexScriptFont_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ComplexScriptFont_Type


class LocalizeFont_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LocalizeFont_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocalizeFont_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalizeFont_Type.subclass:
            return LocalizeFont_Type.subclass(*args_, **kwargs_)
        else:
            return LocalizeFont_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LocalizeFont_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LocalizeFont_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocalizeFont_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LocalizeFont_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocalizeFont_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LocalizeFont_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LocalizeFont_Type'):
        super(LocalizeFont_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocalizeFont_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LocalizeFont_Type', fromsubclass_=False, pretty_print=True):
        super(LocalizeFont_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LocalizeFont_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LocalizeFont_Type


class ComplexScriptSize_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ComplexScriptSize_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComplexScriptSize_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComplexScriptSize_Type.subclass:
            return ComplexScriptSize_Type.subclass(*args_, **kwargs_)
        else:
            return ComplexScriptSize_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ComplexScriptSize_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ComplexScriptSize_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ComplexScriptSize_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ComplexScriptSize_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ComplexScriptSize_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ComplexScriptSize_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ComplexScriptSize_Type'):
        super(ComplexScriptSize_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ComplexScriptSize_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ComplexScriptSize_Type', fromsubclass_=False, pretty_print=True):
        super(ComplexScriptSize_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ComplexScriptSize_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ComplexScriptSize_Type


class FontPosition_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(FontPosition_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FontPosition_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FontPosition_Type.subclass:
            return FontPosition_Type.subclass(*args_, **kwargs_)
        else:
            return FontPosition_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(FontPosition_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FontPosition_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FontPosition_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FontPosition_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FontPosition_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FontPosition_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FontPosition_Type'):
        super(FontPosition_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FontPosition_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FontPosition_Type', fromsubclass_=False, pretty_print=True):
        super(FontPosition_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FontPosition_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FontPosition_Type


class Para_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, IndFirst=None, IndLeft=None, IndRight=None, SpLine=None, SpBefore=None, SpAfter=None, HorzAlign=None, Bullet=None, BulletStr=None, BulletFont=None, LocalizeBulletFont=None, BulletFontSize=None, TextPosAfterBullet=None, Flags=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Para_Type, self).__init__(IX, Del,  **kwargs_)
        self.IndFirst = IndFirst
        self.IndFirst_nsprefix_ = None
        self.IndLeft = IndLeft
        self.IndLeft_nsprefix_ = None
        self.IndRight = IndRight
        self.IndRight_nsprefix_ = None
        self.SpLine = SpLine
        self.SpLine_nsprefix_ = None
        self.SpBefore = SpBefore
        self.SpBefore_nsprefix_ = None
        self.SpAfter = SpAfter
        self.SpAfter_nsprefix_ = None
        self.HorzAlign = HorzAlign
        self.HorzAlign_nsprefix_ = None
        self.Bullet = Bullet
        self.Bullet_nsprefix_ = None
        self.BulletStr = BulletStr
        self.BulletStr_nsprefix_ = None
        self.BulletFont = BulletFont
        self.BulletFont_nsprefix_ = None
        self.LocalizeBulletFont = LocalizeBulletFont
        self.LocalizeBulletFont_nsprefix_ = None
        self.BulletFontSize = BulletFontSize
        self.BulletFontSize_nsprefix_ = None
        self.TextPosAfterBullet = TextPosAfterBullet
        self.TextPosAfterBullet_nsprefix_ = None
        self.Flags = Flags
        self.Flags_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Para_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Para_Type.subclass:
            return Para_Type.subclass(*args_, **kwargs_)
        else:
            return Para_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IndFirst(self):
        return self.IndFirst
    def set_IndFirst(self, IndFirst):
        self.IndFirst = IndFirst
    def get_IndLeft(self):
        return self.IndLeft
    def set_IndLeft(self, IndLeft):
        self.IndLeft = IndLeft
    def get_IndRight(self):
        return self.IndRight
    def set_IndRight(self, IndRight):
        self.IndRight = IndRight
    def get_SpLine(self):
        return self.SpLine
    def set_SpLine(self, SpLine):
        self.SpLine = SpLine
    def get_SpBefore(self):
        return self.SpBefore
    def set_SpBefore(self, SpBefore):
        self.SpBefore = SpBefore
    def get_SpAfter(self):
        return self.SpAfter
    def set_SpAfter(self, SpAfter):
        self.SpAfter = SpAfter
    def get_HorzAlign(self):
        return self.HorzAlign
    def set_HorzAlign(self, HorzAlign):
        self.HorzAlign = HorzAlign
    def get_Bullet(self):
        return self.Bullet
    def set_Bullet(self, Bullet):
        self.Bullet = Bullet
    def get_BulletStr(self):
        return self.BulletStr
    def set_BulletStr(self, BulletStr):
        self.BulletStr = BulletStr
    def get_BulletFont(self):
        return self.BulletFont
    def set_BulletFont(self, BulletFont):
        self.BulletFont = BulletFont
    def get_LocalizeBulletFont(self):
        return self.LocalizeBulletFont
    def set_LocalizeBulletFont(self, LocalizeBulletFont):
        self.LocalizeBulletFont = LocalizeBulletFont
    def get_BulletFontSize(self):
        return self.BulletFontSize
    def set_BulletFontSize(self, BulletFontSize):
        self.BulletFontSize = BulletFontSize
    def get_TextPosAfterBullet(self):
        return self.TextPosAfterBullet
    def set_TextPosAfterBullet(self, TextPosAfterBullet):
        self.TextPosAfterBullet = TextPosAfterBullet
    def get_Flags(self):
        return self.Flags
    def set_Flags(self, Flags):
        self.Flags = Flags
    def hasContent_(self):
        if (
            self.IndFirst is not None or
            self.IndLeft is not None or
            self.IndRight is not None or
            self.SpLine is not None or
            self.SpBefore is not None or
            self.SpAfter is not None or
            self.HorzAlign is not None or
            self.Bullet is not None or
            self.BulletStr is not None or
            self.BulletFont is not None or
            self.LocalizeBulletFont is not None or
            self.BulletFontSize is not None or
            self.TextPosAfterBullet is not None or
            self.Flags is not None or
            super(Para_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Para_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Para_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Para_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Para_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Para_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Para_Type'):
        super(Para_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Para_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Para_Type', fromsubclass_=False, pretty_print=True):
        super(Para_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IndFirst is not None:
            namespaceprefix_ = self.IndFirst_nsprefix_ + ':' if (UseCapturedNS_ and self.IndFirst_nsprefix_) else ''
            self.IndFirst.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IndFirst', pretty_print=pretty_print)
        if self.IndLeft is not None:
            namespaceprefix_ = self.IndLeft_nsprefix_ + ':' if (UseCapturedNS_ and self.IndLeft_nsprefix_) else ''
            self.IndLeft.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IndLeft', pretty_print=pretty_print)
        if self.IndRight is not None:
            namespaceprefix_ = self.IndRight_nsprefix_ + ':' if (UseCapturedNS_ and self.IndRight_nsprefix_) else ''
            self.IndRight.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IndRight', pretty_print=pretty_print)
        if self.SpLine is not None:
            namespaceprefix_ = self.SpLine_nsprefix_ + ':' if (UseCapturedNS_ and self.SpLine_nsprefix_) else ''
            self.SpLine.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SpLine', pretty_print=pretty_print)
        if self.SpBefore is not None:
            namespaceprefix_ = self.SpBefore_nsprefix_ + ':' if (UseCapturedNS_ and self.SpBefore_nsprefix_) else ''
            self.SpBefore.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SpBefore', pretty_print=pretty_print)
        if self.SpAfter is not None:
            namespaceprefix_ = self.SpAfter_nsprefix_ + ':' if (UseCapturedNS_ and self.SpAfter_nsprefix_) else ''
            self.SpAfter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SpAfter', pretty_print=pretty_print)
        if self.HorzAlign is not None:
            namespaceprefix_ = self.HorzAlign_nsprefix_ + ':' if (UseCapturedNS_ and self.HorzAlign_nsprefix_) else ''
            self.HorzAlign.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HorzAlign', pretty_print=pretty_print)
        if self.Bullet is not None:
            namespaceprefix_ = self.Bullet_nsprefix_ + ':' if (UseCapturedNS_ and self.Bullet_nsprefix_) else ''
            self.Bullet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Bullet', pretty_print=pretty_print)
        if self.BulletStr is not None:
            namespaceprefix_ = self.BulletStr_nsprefix_ + ':' if (UseCapturedNS_ and self.BulletStr_nsprefix_) else ''
            self.BulletStr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BulletStr', pretty_print=pretty_print)
        if self.BulletFont is not None:
            namespaceprefix_ = self.BulletFont_nsprefix_ + ':' if (UseCapturedNS_ and self.BulletFont_nsprefix_) else ''
            self.BulletFont.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BulletFont', pretty_print=pretty_print)
        if self.LocalizeBulletFont is not None:
            namespaceprefix_ = self.LocalizeBulletFont_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalizeBulletFont_nsprefix_) else ''
            self.LocalizeBulletFont.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalizeBulletFont', pretty_print=pretty_print)
        if self.BulletFontSize is not None:
            namespaceprefix_ = self.BulletFontSize_nsprefix_ + ':' if (UseCapturedNS_ and self.BulletFontSize_nsprefix_) else ''
            self.BulletFontSize.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BulletFontSize', pretty_print=pretty_print)
        if self.TextPosAfterBullet is not None:
            namespaceprefix_ = self.TextPosAfterBullet_nsprefix_ + ':' if (UseCapturedNS_ and self.TextPosAfterBullet_nsprefix_) else ''
            self.TextPosAfterBullet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextPosAfterBullet', pretty_print=pretty_print)
        if self.Flags is not None:
            namespaceprefix_ = self.Flags_nsprefix_ + ':' if (UseCapturedNS_ and self.Flags_nsprefix_) else ''
            self.Flags.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Flags', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Para_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IndFirst':
            obj_ = IndFirst_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IndFirst = obj_
            obj_.original_tagname_ = 'IndFirst'
        elif nodeName_ == 'IndLeft':
            obj_ = IndLeft_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IndLeft = obj_
            obj_.original_tagname_ = 'IndLeft'
        elif nodeName_ == 'IndRight':
            obj_ = IndRight_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IndRight = obj_
            obj_.original_tagname_ = 'IndRight'
        elif nodeName_ == 'SpLine':
            obj_ = SpLine_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SpLine = obj_
            obj_.original_tagname_ = 'SpLine'
        elif nodeName_ == 'SpBefore':
            obj_ = SpBefore_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SpBefore = obj_
            obj_.original_tagname_ = 'SpBefore'
        elif nodeName_ == 'SpAfter':
            obj_ = SpAfter_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SpAfter = obj_
            obj_.original_tagname_ = 'SpAfter'
        elif nodeName_ == 'HorzAlign':
            obj_ = HorzAlign_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HorzAlign = obj_
            obj_.original_tagname_ = 'HorzAlign'
        elif nodeName_ == 'Bullet':
            obj_ = Bullet_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Bullet = obj_
            obj_.original_tagname_ = 'Bullet'
        elif nodeName_ == 'BulletStr':
            obj_ = BulletStr_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BulletStr = obj_
            obj_.original_tagname_ = 'BulletStr'
        elif nodeName_ == 'BulletFont':
            obj_ = BulletFont_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BulletFont = obj_
            obj_.original_tagname_ = 'BulletFont'
        elif nodeName_ == 'LocalizeBulletFont':
            obj_ = LocalizeBulletFont_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalizeBulletFont = obj_
            obj_.original_tagname_ = 'LocalizeBulletFont'
        elif nodeName_ == 'BulletFontSize':
            obj_ = BulletFontSize_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BulletFontSize = obj_
            obj_.original_tagname_ = 'BulletFontSize'
        elif nodeName_ == 'TextPosAfterBullet':
            obj_ = TextPosAfterBullet_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TextPosAfterBullet = obj_
            obj_.original_tagname_ = 'TextPosAfterBullet'
        elif nodeName_ == 'Flags':
            obj_ = Flags_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Flags = obj_
            obj_.original_tagname_ = 'Flags'
        super(Para_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Para_Type


class IndFirst_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IndFirst_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndFirst_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndFirst_Type.subclass:
            return IndFirst_Type.subclass(*args_, **kwargs_)
        else:
            return IndFirst_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(IndFirst_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IndFirst_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IndFirst_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IndFirst_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IndFirst_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IndFirst_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IndFirst_Type'):
        super(IndFirst_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IndFirst_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IndFirst_Type', fromsubclass_=False, pretty_print=True):
        super(IndFirst_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IndFirst_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class IndFirst_Type


class IndLeft_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IndLeft_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndLeft_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndLeft_Type.subclass:
            return IndLeft_Type.subclass(*args_, **kwargs_)
        else:
            return IndLeft_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(IndLeft_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IndLeft_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IndLeft_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IndLeft_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IndLeft_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IndLeft_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IndLeft_Type'):
        super(IndLeft_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IndLeft_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IndLeft_Type', fromsubclass_=False, pretty_print=True):
        super(IndLeft_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IndLeft_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class IndLeft_Type


class IndRight_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IndRight_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndRight_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndRight_Type.subclass:
            return IndRight_Type.subclass(*args_, **kwargs_)
        else:
            return IndRight_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(IndRight_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IndRight_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IndRight_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IndRight_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IndRight_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IndRight_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IndRight_Type'):
        super(IndRight_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IndRight_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IndRight_Type', fromsubclass_=False, pretty_print=True):
        super(IndRight_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IndRight_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class IndRight_Type


class SpLine_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SpLine_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpLine_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpLine_Type.subclass:
            return SpLine_Type.subclass(*args_, **kwargs_)
        else:
            return SpLine_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(SpLine_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpLine_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpLine_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SpLine_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpLine_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpLine_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpLine_Type'):
        super(SpLine_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpLine_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpLine_Type', fromsubclass_=False, pretty_print=True):
        super(SpLine_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SpLine_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SpLine_Type


class SpBefore_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SpBefore_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpBefore_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpBefore_Type.subclass:
            return SpBefore_Type.subclass(*args_, **kwargs_)
        else:
            return SpBefore_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(SpBefore_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpBefore_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpBefore_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SpBefore_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpBefore_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpBefore_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpBefore_Type'):
        super(SpBefore_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpBefore_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpBefore_Type', fromsubclass_=False, pretty_print=True):
        super(SpBefore_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SpBefore_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SpBefore_Type


class SpAfter_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SpAfter_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpAfter_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpAfter_Type.subclass:
            return SpAfter_Type.subclass(*args_, **kwargs_)
        else:
            return SpAfter_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(SpAfter_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpAfter_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpAfter_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SpAfter_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpAfter_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpAfter_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpAfter_Type'):
        super(SpAfter_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpAfter_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpAfter_Type', fromsubclass_=False, pretty_print=True):
        super(SpAfter_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SpAfter_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SpAfter_Type


class HorzAlign_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(HorzAlign_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HorzAlign_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HorzAlign_Type.subclass:
            return HorzAlign_Type.subclass(*args_, **kwargs_)
        else:
            return HorzAlign_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(HorzAlign_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HorzAlign_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HorzAlign_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HorzAlign_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HorzAlign_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HorzAlign_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HorzAlign_Type'):
        super(HorzAlign_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HorzAlign_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HorzAlign_Type', fromsubclass_=False, pretty_print=True):
        super(HorzAlign_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HorzAlign_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class HorzAlign_Type


class Bullet_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Bullet_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Bullet_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Bullet_Type.subclass:
            return Bullet_Type.subclass(*args_, **kwargs_)
        else:
            return Bullet_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Bullet_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Bullet_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Bullet_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Bullet_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Bullet_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Bullet_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Bullet_Type'):
        super(Bullet_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Bullet_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Bullet_Type', fromsubclass_=False, pretty_print=True):
        super(Bullet_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Bullet_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Bullet_Type


class BulletStr_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BulletStr_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BulletStr_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BulletStr_Type.subclass:
            return BulletStr_Type.subclass(*args_, **kwargs_)
        else:
            return BulletStr_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(BulletStr_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BulletStr_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BulletStr_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BulletStr_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BulletStr_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BulletStr_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BulletStr_Type'):
        super(BulletStr_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BulletStr_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BulletStr_Type', fromsubclass_=False, pretty_print=True):
        super(BulletStr_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BulletStr_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BulletStr_Type


class BulletFont_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BulletFont_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BulletFont_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BulletFont_Type.subclass:
            return BulletFont_Type.subclass(*args_, **kwargs_)
        else:
            return BulletFont_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(BulletFont_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BulletFont_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BulletFont_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BulletFont_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BulletFont_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BulletFont_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BulletFont_Type'):
        super(BulletFont_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BulletFont_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BulletFont_Type', fromsubclass_=False, pretty_print=True):
        super(BulletFont_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BulletFont_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BulletFont_Type


class LocalizeBulletFont_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LocalizeBulletFont_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocalizeBulletFont_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalizeBulletFont_Type.subclass:
            return LocalizeBulletFont_Type.subclass(*args_, **kwargs_)
        else:
            return LocalizeBulletFont_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(LocalizeBulletFont_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LocalizeBulletFont_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocalizeBulletFont_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LocalizeBulletFont_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocalizeBulletFont_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LocalizeBulletFont_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LocalizeBulletFont_Type'):
        super(LocalizeBulletFont_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocalizeBulletFont_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LocalizeBulletFont_Type', fromsubclass_=False, pretty_print=True):
        super(LocalizeBulletFont_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LocalizeBulletFont_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LocalizeBulletFont_Type


class BulletFontSize_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BulletFontSize_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BulletFontSize_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BulletFontSize_Type.subclass:
            return BulletFontSize_Type.subclass(*args_, **kwargs_)
        else:
            return BulletFontSize_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(BulletFontSize_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BulletFontSize_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BulletFontSize_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BulletFontSize_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BulletFontSize_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BulletFontSize_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BulletFontSize_Type'):
        super(BulletFontSize_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BulletFontSize_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BulletFontSize_Type', fromsubclass_=False, pretty_print=True):
        super(BulletFontSize_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BulletFontSize_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BulletFontSize_Type


class TextPosAfterBullet_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TextPosAfterBullet_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextPosAfterBullet_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextPosAfterBullet_Type.subclass:
            return TextPosAfterBullet_Type.subclass(*args_, **kwargs_)
        else:
            return TextPosAfterBullet_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TextPosAfterBullet_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextPosAfterBullet_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextPosAfterBullet_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextPosAfterBullet_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextPosAfterBullet_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextPosAfterBullet_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextPosAfterBullet_Type'):
        super(TextPosAfterBullet_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextPosAfterBullet_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextPosAfterBullet_Type', fromsubclass_=False, pretty_print=True):
        super(TextPosAfterBullet_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TextPosAfterBullet_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TextPosAfterBullet_Type


class Tabs_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, Tab=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Tabs_Type, self).__init__(IX, Del,  **kwargs_)
        if Tab is None:
            self.Tab = []
        else:
            self.Tab = Tab
        self.Tab_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Tabs_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Tabs_Type.subclass:
            return Tabs_Type.subclass(*args_, **kwargs_)
        else:
            return Tabs_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Tab(self):
        return self.Tab
    def set_Tab(self, Tab):
        self.Tab = Tab
    def add_Tab(self, value):
        self.Tab.append(value)
    def insert_Tab_at(self, index, value):
        self.Tab.insert(index, value)
    def replace_Tab_at(self, index, value):
        self.Tab[index] = value
    def hasContent_(self):
        if (
            self.Tab or
            super(Tabs_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Tabs_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Tabs_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Tabs_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Tabs_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Tabs_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Tabs_Type'):
        super(Tabs_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Tabs_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Tabs_Type', fromsubclass_=False, pretty_print=True):
        super(Tabs_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Tab_ in self.Tab:
            namespaceprefix_ = self.Tab_nsprefix_ + ':' if (UseCapturedNS_ and self.Tab_nsprefix_) else ''
            Tab_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Tab', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Tabs_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Tab':
            obj_ = Tab_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Tab.append(obj_)
            obj_.original_tagname_ = 'Tab'
        super(Tabs_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Tabs_Type


class Tab_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, IX=None, Position=None, Alignment=None, Leader=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.IX = _cast(int, IX)
        self.IX_nsprefix_ = None
        self.Position = Position
        self.Position_nsprefix_ = None
        self.Alignment = Alignment
        self.Alignment_nsprefix_ = None
        self.Leader = Leader
        self.Leader_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Tab_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Tab_Type.subclass:
            return Tab_Type.subclass(*args_, **kwargs_)
        else:
            return Tab_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Position(self):
        return self.Position
    def set_Position(self, Position):
        self.Position = Position
    def get_Alignment(self):
        return self.Alignment
    def set_Alignment(self, Alignment):
        self.Alignment = Alignment
    def get_Leader(self):
        return self.Leader
    def set_Leader(self, Leader):
        self.Leader = Leader
    def get_IX(self):
        return self.IX
    def set_IX(self, IX):
        self.IX = IX
    def hasContent_(self):
        if (
            self.Position is not None or
            self.Alignment is not None or
            self.Leader is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Tab_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Tab_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Tab_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Tab_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Tab_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Tab_Type'):
        if self.IX is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            outfile.write(' IX="%s"' % self.gds_format_integer(self.IX, input_name='IX'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Tab_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Position is not None:
            namespaceprefix_ = self.Position_nsprefix_ + ':' if (UseCapturedNS_ and self.Position_nsprefix_) else ''
            self.Position.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Position', pretty_print=pretty_print)
        if self.Alignment is not None:
            namespaceprefix_ = self.Alignment_nsprefix_ + ':' if (UseCapturedNS_ and self.Alignment_nsprefix_) else ''
            self.Alignment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Alignment', pretty_print=pretty_print)
        if self.Leader is not None:
            namespaceprefix_ = self.Leader_nsprefix_ + ':' if (UseCapturedNS_ and self.Leader_nsprefix_) else ''
            self.Leader.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Leader', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IX', node)
        if value is not None and 'IX' not in already_processed:
            already_processed.add('IX')
            self.IX = self.gds_parse_integer(value, node, 'IX')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Position':
            obj_ = Position_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Position = obj_
            obj_.original_tagname_ = 'Position'
        elif nodeName_ == 'Alignment':
            obj_ = Alignment_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Alignment = obj_
            obj_.original_tagname_ = 'Alignment'
        elif nodeName_ == 'Leader':
            obj_ = Leader_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Leader = obj_
            obj_.original_tagname_ = 'Leader'
# end class Tab_Type


class Position_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Position_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Position_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Position_Type.subclass:
            return Position_Type.subclass(*args_, **kwargs_)
        else:
            return Position_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Position_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Position_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Position_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Position_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Position_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Position_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Position_Type'):
        super(Position_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Position_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Position_Type', fromsubclass_=False, pretty_print=True):
        super(Position_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Position_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Position_Type


class Alignment_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Alignment_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Alignment_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Alignment_Type.subclass:
            return Alignment_Type.subclass(*args_, **kwargs_)
        else:
            return Alignment_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Alignment_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Alignment_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Alignment_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Alignment_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Alignment_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Alignment_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Alignment_Type'):
        super(Alignment_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Alignment_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Alignment_Type', fromsubclass_=False, pretty_print=True):
        super(Alignment_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Alignment_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Alignment_Type


class Leader_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Leader_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Leader_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Leader_Type.subclass:
            return Leader_Type.subclass(*args_, **kwargs_)
        else:
            return Leader_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Leader_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Leader_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Leader_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Leader_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Leader_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Leader_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Leader_Type'):
        super(Leader_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Leader_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Leader_Type', fromsubclass_=False, pretty_print=True):
        super(Leader_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Leader_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Leader_Type


class Scratch_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, X=None, Y=None, A=None, B=None, C=None, D=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Scratch_Type, self).__init__(IX, Del,  **kwargs_)
        self.X = X
        self.X_nsprefix_ = None
        self.Y = Y
        self.Y_nsprefix_ = None
        self.A = A
        self.A_nsprefix_ = None
        self.B = B
        self.B_nsprefix_ = None
        self.C = C
        self.C_nsprefix_ = None
        self.D = D
        self.D_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Scratch_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Scratch_Type.subclass:
            return Scratch_Type.subclass(*args_, **kwargs_)
        else:
            return Scratch_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def get_A(self):
        return self.A
    def set_A(self, A):
        self.A = A
    def get_B(self):
        return self.B
    def set_B(self, B):
        self.B = B
    def get_C(self):
        return self.C
    def set_C(self, C):
        self.C = C
    def get_D(self):
        return self.D
    def set_D(self, D):
        self.D = D
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None or
            self.A is not None or
            self.B is not None or
            self.C is not None or
            self.D is not None or
            super(Scratch_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Scratch_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Scratch_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Scratch_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Scratch_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Scratch_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Scratch_Type'):
        super(Scratch_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Scratch_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Scratch_Type', fromsubclass_=False, pretty_print=True):
        super(Scratch_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            self.X.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        if self.Y is not None:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            self.Y.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
        if self.A is not None:
            namespaceprefix_ = self.A_nsprefix_ + ':' if (UseCapturedNS_ and self.A_nsprefix_) else ''
            self.A.export(outfile, level, namespaceprefix_, namespacedef_='', name_='A', pretty_print=pretty_print)
        if self.B is not None:
            namespaceprefix_ = self.B_nsprefix_ + ':' if (UseCapturedNS_ and self.B_nsprefix_) else ''
            self.B.export(outfile, level, namespaceprefix_, namespacedef_='', name_='B', pretty_print=pretty_print)
        if self.C is not None:
            namespaceprefix_ = self.C_nsprefix_ + ':' if (UseCapturedNS_ and self.C_nsprefix_) else ''
            self.C.export(outfile, level, namespaceprefix_, namespacedef_='', name_='C', pretty_print=pretty_print)
        if self.D is not None:
            namespaceprefix_ = self.D_nsprefix_ + ':' if (UseCapturedNS_ and self.D_nsprefix_) else ''
            self.D.export(outfile, level, namespaceprefix_, namespacedef_='', name_='D', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Scratch_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X = obj_
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y = obj_
            obj_.original_tagname_ = 'Y'
        elif nodeName_ == 'A':
            obj_ = A_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.A = obj_
            obj_.original_tagname_ = 'A'
        elif nodeName_ == 'B':
            obj_ = B_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.B = obj_
            obj_.original_tagname_ = 'B'
        elif nodeName_ == 'C':
            obj_ = C_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.C = obj_
            obj_.original_tagname_ = 'C'
        elif nodeName_ == 'D':
            obj_ = D_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.D = obj_
            obj_.original_tagname_ = 'D'
        super(Scratch_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Scratch_Type


class Connection_Type(NamedIndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NamedIndexedRow_Type
    def __init__(self, Name=None, NameU=None, Del=None, ID=None, IX=None, X=None, Y=None, DirX=None, DirY=None, Type=None, AutoGen=None, Prompt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Connection_Type, self).__init__(Name, NameU, Del, ID, IX,  **kwargs_)
        if X is None:
            self.X = []
        else:
            self.X = X
        self.X_nsprefix_ = None
        if Y is None:
            self.Y = []
        else:
            self.Y = Y
        self.Y_nsprefix_ = None
        if DirX is None:
            self.DirX = []
        else:
            self.DirX = DirX
        self.DirX_nsprefix_ = None
        if DirY is None:
            self.DirY = []
        else:
            self.DirY = DirY
        self.DirY_nsprefix_ = None
        if Type is None:
            self.Type = []
        else:
            self.Type = Type
        self.Type_nsprefix_ = None
        if AutoGen is None:
            self.AutoGen = []
        else:
            self.AutoGen = AutoGen
        self.AutoGen_nsprefix_ = None
        if Prompt is None:
            self.Prompt = []
        else:
            self.Prompt = Prompt
        self.Prompt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Connection_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Connection_Type.subclass:
            return Connection_Type.subclass(*args_, **kwargs_)
        else:
            return Connection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def add_X(self, value):
        self.X.append(value)
    def insert_X_at(self, index, value):
        self.X.insert(index, value)
    def replace_X_at(self, index, value):
        self.X[index] = value
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def add_Y(self, value):
        self.Y.append(value)
    def insert_Y_at(self, index, value):
        self.Y.insert(index, value)
    def replace_Y_at(self, index, value):
        self.Y[index] = value
    def get_DirX(self):
        return self.DirX
    def set_DirX(self, DirX):
        self.DirX = DirX
    def add_DirX(self, value):
        self.DirX.append(value)
    def insert_DirX_at(self, index, value):
        self.DirX.insert(index, value)
    def replace_DirX_at(self, index, value):
        self.DirX[index] = value
    def get_DirY(self):
        return self.DirY
    def set_DirY(self, DirY):
        self.DirY = DirY
    def add_DirY(self, value):
        self.DirY.append(value)
    def insert_DirY_at(self, index, value):
        self.DirY.insert(index, value)
    def replace_DirY_at(self, index, value):
        self.DirY[index] = value
    def get_Type(self):
        return self.Type
    def set_Type(self, Type):
        self.Type = Type
    def add_Type(self, value):
        self.Type.append(value)
    def insert_Type_at(self, index, value):
        self.Type.insert(index, value)
    def replace_Type_at(self, index, value):
        self.Type[index] = value
    def get_AutoGen(self):
        return self.AutoGen
    def set_AutoGen(self, AutoGen):
        self.AutoGen = AutoGen
    def add_AutoGen(self, value):
        self.AutoGen.append(value)
    def insert_AutoGen_at(self, index, value):
        self.AutoGen.insert(index, value)
    def replace_AutoGen_at(self, index, value):
        self.AutoGen[index] = value
    def get_Prompt(self):
        return self.Prompt
    def set_Prompt(self, Prompt):
        self.Prompt = Prompt
    def add_Prompt(self, value):
        self.Prompt.append(value)
    def insert_Prompt_at(self, index, value):
        self.Prompt.insert(index, value)
    def replace_Prompt_at(self, index, value):
        self.Prompt[index] = value
    def hasContent_(self):
        if (
            self.X or
            self.Y or
            self.DirX or
            self.DirY or
            self.Type or
            self.AutoGen or
            self.Prompt or
            super(Connection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Connection_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Connection_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Connection_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Connection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Connection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Connection_Type'):
        super(Connection_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Connection_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Connection_Type', fromsubclass_=False, pretty_print=True):
        super(Connection_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for X_ in self.X:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            X_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        for Y_ in self.Y:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            Y_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
        for DirX_ in self.DirX:
            namespaceprefix_ = self.DirX_nsprefix_ + ':' if (UseCapturedNS_ and self.DirX_nsprefix_) else ''
            DirX_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DirX', pretty_print=pretty_print)
        for DirY_ in self.DirY:
            namespaceprefix_ = self.DirY_nsprefix_ + ':' if (UseCapturedNS_ and self.DirY_nsprefix_) else ''
            DirY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DirY', pretty_print=pretty_print)
        for Type_ in self.Type:
            namespaceprefix_ = self.Type_nsprefix_ + ':' if (UseCapturedNS_ and self.Type_nsprefix_) else ''
            Type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Type', pretty_print=pretty_print)
        for AutoGen_ in self.AutoGen:
            namespaceprefix_ = self.AutoGen_nsprefix_ + ':' if (UseCapturedNS_ and self.AutoGen_nsprefix_) else ''
            AutoGen_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AutoGen', pretty_print=pretty_print)
        for Prompt_ in self.Prompt:
            namespaceprefix_ = self.Prompt_nsprefix_ + ':' if (UseCapturedNS_ and self.Prompt_nsprefix_) else ''
            Prompt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Prompt', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Connection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X.append(obj_)
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y.append(obj_)
            obj_.original_tagname_ = 'Y'
        elif nodeName_ == 'DirX':
            obj_ = DirX_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DirX.append(obj_)
            obj_.original_tagname_ = 'DirX'
        elif nodeName_ == 'DirY':
            obj_ = DirY_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DirY.append(obj_)
            obj_.original_tagname_ = 'DirY'
        elif nodeName_ == 'Type':
            obj_ = Type_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Type.append(obj_)
            obj_.original_tagname_ = 'Type'
        elif nodeName_ == 'AutoGen':
            obj_ = AutoGen_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AutoGen.append(obj_)
            obj_.original_tagname_ = 'AutoGen'
        elif nodeName_ == 'Prompt':
            obj_ = Prompt_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Prompt.append(obj_)
            obj_.original_tagname_ = 'Prompt'
        super(Connection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Connection_Type


class DirX_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DirX_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DirX_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DirX_Type.subclass:
            return DirX_Type.subclass(*args_, **kwargs_)
        else:
            return DirX_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DirX_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DirX_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DirX_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DirX_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DirX_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DirX_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DirX_Type'):
        super(DirX_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DirX_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DirX_Type', fromsubclass_=False, pretty_print=True):
        super(DirX_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DirX_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DirX_Type


class DirY_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DirY_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DirY_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DirY_Type.subclass:
            return DirY_Type.subclass(*args_, **kwargs_)
        else:
            return DirY_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(DirY_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DirY_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DirY_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DirY_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DirY_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DirY_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DirY_Type'):
        super(DirY_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DirY_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DirY_Type', fromsubclass_=False, pretty_print=True):
        super(DirY_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DirY_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DirY_Type


class Type_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Type_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Type_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Type_Type.subclass:
            return Type_Type.subclass(*args_, **kwargs_)
        else:
            return Type_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Type_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Type_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Type_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Type_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Type_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Type_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Type_Type'):
        super(Type_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Type_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Type_Type', fromsubclass_=False, pretty_print=True):
        super(Type_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Type_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Type_Type


class AutoGen_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AutoGen_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AutoGen_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AutoGen_Type.subclass:
            return AutoGen_Type.subclass(*args_, **kwargs_)
        else:
            return AutoGen_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(AutoGen_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AutoGen_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AutoGen_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AutoGen_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AutoGen_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AutoGen_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AutoGen_Type'):
        super(AutoGen_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AutoGen_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AutoGen_Type', fromsubclass_=False, pretty_print=True):
        super(AutoGen_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AutoGen_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AutoGen_Type


class Prompt_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Prompt_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Prompt_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Prompt_Type.subclass:
            return Prompt_Type.subclass(*args_, **kwargs_)
        else:
            return Prompt_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Prompt_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Prompt_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Prompt_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Prompt_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Prompt_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Prompt_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Prompt_Type'):
        super(Prompt_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Prompt_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Prompt_Type', fromsubclass_=False, pretty_print=True):
        super(Prompt_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Prompt_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Prompt_Type


class ConnectionABCD_Type(NamedIndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NamedIndexedRow_Type
    def __init__(self, Name=None, NameU=None, Del=None, ID=None, IX=None, X=None, Y=None, A=None, B=None, C=None, D=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ConnectionABCD_Type, self).__init__(Name, NameU, Del, ID, IX,  **kwargs_)
        if X is None:
            self.X = []
        else:
            self.X = X
        self.X_nsprefix_ = None
        if Y is None:
            self.Y = []
        else:
            self.Y = Y
        self.Y_nsprefix_ = None
        if A is None:
            self.A = []
        else:
            self.A = A
        self.A_nsprefix_ = None
        if B is None:
            self.B = []
        else:
            self.B = B
        self.B_nsprefix_ = None
        if C is None:
            self.C = []
        else:
            self.C = C
        self.C_nsprefix_ = None
        if D is None:
            self.D = []
        else:
            self.D = D
        self.D_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConnectionABCD_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConnectionABCD_Type.subclass:
            return ConnectionABCD_Type.subclass(*args_, **kwargs_)
        else:
            return ConnectionABCD_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def add_X(self, value):
        self.X.append(value)
    def insert_X_at(self, index, value):
        self.X.insert(index, value)
    def replace_X_at(self, index, value):
        self.X[index] = value
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def add_Y(self, value):
        self.Y.append(value)
    def insert_Y_at(self, index, value):
        self.Y.insert(index, value)
    def replace_Y_at(self, index, value):
        self.Y[index] = value
    def get_A(self):
        return self.A
    def set_A(self, A):
        self.A = A
    def add_A(self, value):
        self.A.append(value)
    def insert_A_at(self, index, value):
        self.A.insert(index, value)
    def replace_A_at(self, index, value):
        self.A[index] = value
    def get_B(self):
        return self.B
    def set_B(self, B):
        self.B = B
    def add_B(self, value):
        self.B.append(value)
    def insert_B_at(self, index, value):
        self.B.insert(index, value)
    def replace_B_at(self, index, value):
        self.B[index] = value
    def get_C(self):
        return self.C
    def set_C(self, C):
        self.C = C
    def add_C(self, value):
        self.C.append(value)
    def insert_C_at(self, index, value):
        self.C.insert(index, value)
    def replace_C_at(self, index, value):
        self.C[index] = value
    def get_D(self):
        return self.D
    def set_D(self, D):
        self.D = D
    def add_D(self, value):
        self.D.append(value)
    def insert_D_at(self, index, value):
        self.D.insert(index, value)
    def replace_D_at(self, index, value):
        self.D[index] = value
    def hasContent_(self):
        if (
            self.X or
            self.Y or
            self.A or
            self.B or
            self.C or
            self.D or
            super(ConnectionABCD_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='ConnectionABCD_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConnectionABCD_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConnectionABCD_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConnectionABCD_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConnectionABCD_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConnectionABCD_Type'):
        super(ConnectionABCD_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConnectionABCD_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='ConnectionABCD_Type', fromsubclass_=False, pretty_print=True):
        super(ConnectionABCD_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for X_ in self.X:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            X_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        for Y_ in self.Y:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            Y_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
        for A_ in self.A:
            namespaceprefix_ = self.A_nsprefix_ + ':' if (UseCapturedNS_ and self.A_nsprefix_) else ''
            A_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='A', pretty_print=pretty_print)
        for B_ in self.B:
            namespaceprefix_ = self.B_nsprefix_ + ':' if (UseCapturedNS_ and self.B_nsprefix_) else ''
            B_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='B', pretty_print=pretty_print)
        for C_ in self.C:
            namespaceprefix_ = self.C_nsprefix_ + ':' if (UseCapturedNS_ and self.C_nsprefix_) else ''
            C_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='C', pretty_print=pretty_print)
        for D_ in self.D:
            namespaceprefix_ = self.D_nsprefix_ + ':' if (UseCapturedNS_ and self.D_nsprefix_) else ''
            D_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='D', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConnectionABCD_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X.append(obj_)
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y.append(obj_)
            obj_.original_tagname_ = 'Y'
        elif nodeName_ == 'A':
            obj_ = A_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.A.append(obj_)
            obj_.original_tagname_ = 'A'
        elif nodeName_ == 'B':
            obj_ = B_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.B.append(obj_)
            obj_.original_tagname_ = 'B'
        elif nodeName_ == 'C':
            obj_ = C_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.C.append(obj_)
            obj_.original_tagname_ = 'C'
        elif nodeName_ == 'D':
            obj_ = D_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.D.append(obj_)
            obj_.original_tagname_ = 'D'
        super(ConnectionABCD_Type, self).buildChildren(child_, node, nodeName_, True)
# end class ConnectionABCD_Type


class Field_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, Value=None, EditMode=None, Format=None, Type=None, UICat=None, UICod=None, UIFmt=None, Calendar=None, ObjectKind=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Field_Type, self).__init__(IX, Del,  **kwargs_)
        self.Value = Value
        self.Value_nsprefix_ = None
        self.EditMode = EditMode
        self.EditMode_nsprefix_ = None
        self.Format = Format
        self.Format_nsprefix_ = None
        self.Type = Type
        self.Type_nsprefix_ = None
        self.UICat = UICat
        self.UICat_nsprefix_ = None
        self.UICod = UICod
        self.UICod_nsprefix_ = None
        self.UIFmt = UIFmt
        self.UIFmt_nsprefix_ = None
        self.Calendar = Calendar
        self.Calendar_nsprefix_ = None
        self.ObjectKind = ObjectKind
        self.ObjectKind_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Field_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Field_Type.subclass:
            return Field_Type.subclass(*args_, **kwargs_)
        else:
            return Field_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Value(self):
        return self.Value
    def set_Value(self, Value):
        self.Value = Value
    def get_EditMode(self):
        return self.EditMode
    def set_EditMode(self, EditMode):
        self.EditMode = EditMode
    def get_Format(self):
        return self.Format
    def set_Format(self, Format):
        self.Format = Format
    def get_Type(self):
        return self.Type
    def set_Type(self, Type):
        self.Type = Type
    def get_UICat(self):
        return self.UICat
    def set_UICat(self, UICat):
        self.UICat = UICat
    def get_UICod(self):
        return self.UICod
    def set_UICod(self, UICod):
        self.UICod = UICod
    def get_UIFmt(self):
        return self.UIFmt
    def set_UIFmt(self, UIFmt):
        self.UIFmt = UIFmt
    def get_Calendar(self):
        return self.Calendar
    def set_Calendar(self, Calendar):
        self.Calendar = Calendar
    def get_ObjectKind(self):
        return self.ObjectKind
    def set_ObjectKind(self, ObjectKind):
        self.ObjectKind = ObjectKind
    def hasContent_(self):
        if (
            self.Value is not None or
            self.EditMode is not None or
            self.Format is not None or
            self.Type is not None or
            self.UICat is not None or
            self.UICod is not None or
            self.UIFmt is not None or
            self.Calendar is not None or
            self.ObjectKind is not None or
            super(Field_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Field_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Field_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Field_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Field_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Field_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Field_Type'):
        super(Field_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Field_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Field_Type', fromsubclass_=False, pretty_print=True):
        super(Field_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            namespaceprefix_ = self.Value_nsprefix_ + ':' if (UseCapturedNS_ and self.Value_nsprefix_) else ''
            self.Value.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Value', pretty_print=pretty_print)
        if self.EditMode is not None:
            namespaceprefix_ = self.EditMode_nsprefix_ + ':' if (UseCapturedNS_ and self.EditMode_nsprefix_) else ''
            self.EditMode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EditMode', pretty_print=pretty_print)
        if self.Format is not None:
            namespaceprefix_ = self.Format_nsprefix_ + ':' if (UseCapturedNS_ and self.Format_nsprefix_) else ''
            self.Format.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Format', pretty_print=pretty_print)
        if self.Type is not None:
            namespaceprefix_ = self.Type_nsprefix_ + ':' if (UseCapturedNS_ and self.Type_nsprefix_) else ''
            self.Type.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Type', pretty_print=pretty_print)
        if self.UICat is not None:
            namespaceprefix_ = self.UICat_nsprefix_ + ':' if (UseCapturedNS_ and self.UICat_nsprefix_) else ''
            self.UICat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UICat', pretty_print=pretty_print)
        if self.UICod is not None:
            namespaceprefix_ = self.UICod_nsprefix_ + ':' if (UseCapturedNS_ and self.UICod_nsprefix_) else ''
            self.UICod.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UICod', pretty_print=pretty_print)
        if self.UIFmt is not None:
            namespaceprefix_ = self.UIFmt_nsprefix_ + ':' if (UseCapturedNS_ and self.UIFmt_nsprefix_) else ''
            self.UIFmt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UIFmt', pretty_print=pretty_print)
        if self.Calendar is not None:
            namespaceprefix_ = self.Calendar_nsprefix_ + ':' if (UseCapturedNS_ and self.Calendar_nsprefix_) else ''
            self.Calendar.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Calendar', pretty_print=pretty_print)
        if self.ObjectKind is not None:
            namespaceprefix_ = self.ObjectKind_nsprefix_ + ':' if (UseCapturedNS_ and self.ObjectKind_nsprefix_) else ''
            self.ObjectKind.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ObjectKind', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Field_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Value':
            obj_ = Value_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Value = obj_
            obj_.original_tagname_ = 'Value'
        elif nodeName_ == 'EditMode':
            obj_ = EditMode_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EditMode = obj_
            obj_.original_tagname_ = 'EditMode'
        elif nodeName_ == 'Format':
            obj_ = Format_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Format = obj_
            obj_.original_tagname_ = 'Format'
        elif nodeName_ == 'Type':
            obj_ = Type_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Type = obj_
            obj_.original_tagname_ = 'Type'
        elif nodeName_ == 'UICat':
            obj_ = UICat_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UICat = obj_
            obj_.original_tagname_ = 'UICat'
        elif nodeName_ == 'UICod':
            obj_ = UICod_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UICod = obj_
            obj_.original_tagname_ = 'UICod'
        elif nodeName_ == 'UIFmt':
            obj_ = UIFmt_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UIFmt = obj_
            obj_.original_tagname_ = 'UIFmt'
        elif nodeName_ == 'Calendar':
            obj_ = Calendar_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Calendar = obj_
            obj_.original_tagname_ = 'Calendar'
        elif nodeName_ == 'ObjectKind':
            obj_ = ObjectKind_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObjectKind = obj_
            obj_.original_tagname_ = 'ObjectKind'
        super(Field_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Field_Type


class Value_Type(ExtendableCell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ExtendableCell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, SolutionXML=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Value_Type, self).__init__(Unit, F, Err, V, SolutionXML, valueOf_, mixedclass_, content_,  **kwargs_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Value_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Value_Type.subclass:
            return Value_Type.subclass(*args_, **kwargs_)
        else:
            return Value_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_ or
            super(Value_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Value_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Value_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Value_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Value_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Value_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Value_Type'):
        super(Value_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Value_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Value_Type', fromsubclass_=False, pretty_print=True):
        super(Value_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Value_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(Value_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Value_Type


class EditMode_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EditMode_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EditMode_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EditMode_Type.subclass:
            return EditMode_Type.subclass(*args_, **kwargs_)
        else:
            return EditMode_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(EditMode_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EditMode_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EditMode_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EditMode_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EditMode_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EditMode_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EditMode_Type'):
        super(EditMode_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EditMode_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EditMode_Type', fromsubclass_=False, pretty_print=True):
        super(EditMode_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EditMode_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EditMode_Type


class Format_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Format_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Format_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Format_Type.subclass:
            return Format_Type.subclass(*args_, **kwargs_)
        else:
            return Format_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Format_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Format_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Format_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Format_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Format_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Format_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Format_Type'):
        super(Format_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Format_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Format_Type', fromsubclass_=False, pretty_print=True):
        super(Format_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Format_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Format_Type


class UICat_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(UICat_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UICat_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UICat_Type.subclass:
            return UICat_Type.subclass(*args_, **kwargs_)
        else:
            return UICat_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(UICat_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UICat_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UICat_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UICat_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UICat_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UICat_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UICat_Type'):
        super(UICat_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UICat_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UICat_Type', fromsubclass_=False, pretty_print=True):
        super(UICat_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UICat_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class UICat_Type


class UICod_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(UICod_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UICod_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UICod_Type.subclass:
            return UICod_Type.subclass(*args_, **kwargs_)
        else:
            return UICod_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(UICod_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UICod_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UICod_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UICod_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UICod_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UICod_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UICod_Type'):
        super(UICod_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UICod_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UICod_Type', fromsubclass_=False, pretty_print=True):
        super(UICod_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UICod_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class UICod_Type


class UIFmt_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(UIFmt_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UIFmt_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UIFmt_Type.subclass:
            return UIFmt_Type.subclass(*args_, **kwargs_)
        else:
            return UIFmt_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(UIFmt_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UIFmt_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UIFmt_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UIFmt_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UIFmt_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UIFmt_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UIFmt_Type'):
        super(UIFmt_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UIFmt_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UIFmt_Type', fromsubclass_=False, pretty_print=True):
        super(UIFmt_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UIFmt_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class UIFmt_Type


class ObjectKind_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ObjectKind_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObjectKind_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObjectKind_Type.subclass:
            return ObjectKind_Type.subclass(*args_, **kwargs_)
        else:
            return ObjectKind_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ObjectKind_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObjectKind_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObjectKind_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ObjectKind_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObjectKind_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObjectKind_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObjectKind_Type'):
        super(ObjectKind_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObjectKind_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObjectKind_Type', fromsubclass_=False, pretty_print=True):
        super(ObjectKind_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ObjectKind_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ObjectKind_Type


class Control_Type(NamedIndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NamedIndexedRow_Type
    def __init__(self, Name=None, NameU=None, Del=None, ID=None, IX=None, X=None, Y=None, XDyn=None, YDyn=None, XCon=None, YCon=None, CanGlue=None, Prompt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Control_Type, self).__init__(Name, NameU, Del, ID, IX,  **kwargs_)
        if X is None:
            self.X = []
        else:
            self.X = X
        self.X_nsprefix_ = None
        if Y is None:
            self.Y = []
        else:
            self.Y = Y
        self.Y_nsprefix_ = None
        if XDyn is None:
            self.XDyn = []
        else:
            self.XDyn = XDyn
        self.XDyn_nsprefix_ = None
        if YDyn is None:
            self.YDyn = []
        else:
            self.YDyn = YDyn
        self.YDyn_nsprefix_ = None
        if XCon is None:
            self.XCon = []
        else:
            self.XCon = XCon
        self.XCon_nsprefix_ = None
        if YCon is None:
            self.YCon = []
        else:
            self.YCon = YCon
        self.YCon_nsprefix_ = None
        if CanGlue is None:
            self.CanGlue = []
        else:
            self.CanGlue = CanGlue
        self.CanGlue_nsprefix_ = None
        if Prompt is None:
            self.Prompt = []
        else:
            self.Prompt = Prompt
        self.Prompt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Control_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Control_Type.subclass:
            return Control_Type.subclass(*args_, **kwargs_)
        else:
            return Control_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def add_X(self, value):
        self.X.append(value)
    def insert_X_at(self, index, value):
        self.X.insert(index, value)
    def replace_X_at(self, index, value):
        self.X[index] = value
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def add_Y(self, value):
        self.Y.append(value)
    def insert_Y_at(self, index, value):
        self.Y.insert(index, value)
    def replace_Y_at(self, index, value):
        self.Y[index] = value
    def get_XDyn(self):
        return self.XDyn
    def set_XDyn(self, XDyn):
        self.XDyn = XDyn
    def add_XDyn(self, value):
        self.XDyn.append(value)
    def insert_XDyn_at(self, index, value):
        self.XDyn.insert(index, value)
    def replace_XDyn_at(self, index, value):
        self.XDyn[index] = value
    def get_YDyn(self):
        return self.YDyn
    def set_YDyn(self, YDyn):
        self.YDyn = YDyn
    def add_YDyn(self, value):
        self.YDyn.append(value)
    def insert_YDyn_at(self, index, value):
        self.YDyn.insert(index, value)
    def replace_YDyn_at(self, index, value):
        self.YDyn[index] = value
    def get_XCon(self):
        return self.XCon
    def set_XCon(self, XCon):
        self.XCon = XCon
    def add_XCon(self, value):
        self.XCon.append(value)
    def insert_XCon_at(self, index, value):
        self.XCon.insert(index, value)
    def replace_XCon_at(self, index, value):
        self.XCon[index] = value
    def get_YCon(self):
        return self.YCon
    def set_YCon(self, YCon):
        self.YCon = YCon
    def add_YCon(self, value):
        self.YCon.append(value)
    def insert_YCon_at(self, index, value):
        self.YCon.insert(index, value)
    def replace_YCon_at(self, index, value):
        self.YCon[index] = value
    def get_CanGlue(self):
        return self.CanGlue
    def set_CanGlue(self, CanGlue):
        self.CanGlue = CanGlue
    def add_CanGlue(self, value):
        self.CanGlue.append(value)
    def insert_CanGlue_at(self, index, value):
        self.CanGlue.insert(index, value)
    def replace_CanGlue_at(self, index, value):
        self.CanGlue[index] = value
    def get_Prompt(self):
        return self.Prompt
    def set_Prompt(self, Prompt):
        self.Prompt = Prompt
    def add_Prompt(self, value):
        self.Prompt.append(value)
    def insert_Prompt_at(self, index, value):
        self.Prompt.insert(index, value)
    def replace_Prompt_at(self, index, value):
        self.Prompt[index] = value
    def hasContent_(self):
        if (
            self.X or
            self.Y or
            self.XDyn or
            self.YDyn or
            self.XCon or
            self.YCon or
            self.CanGlue or
            self.Prompt or
            super(Control_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Control_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Control_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Control_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Control_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Control_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Control_Type'):
        super(Control_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Control_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Control_Type', fromsubclass_=False, pretty_print=True):
        super(Control_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for X_ in self.X:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            X_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        for Y_ in self.Y:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            Y_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
        for XDyn_ in self.XDyn:
            namespaceprefix_ = self.XDyn_nsprefix_ + ':' if (UseCapturedNS_ and self.XDyn_nsprefix_) else ''
            XDyn_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XDyn', pretty_print=pretty_print)
        for YDyn_ in self.YDyn:
            namespaceprefix_ = self.YDyn_nsprefix_ + ':' if (UseCapturedNS_ and self.YDyn_nsprefix_) else ''
            YDyn_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='YDyn', pretty_print=pretty_print)
        for XCon_ in self.XCon:
            namespaceprefix_ = self.XCon_nsprefix_ + ':' if (UseCapturedNS_ and self.XCon_nsprefix_) else ''
            XCon_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XCon', pretty_print=pretty_print)
        for YCon_ in self.YCon:
            namespaceprefix_ = self.YCon_nsprefix_ + ':' if (UseCapturedNS_ and self.YCon_nsprefix_) else ''
            YCon_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='YCon', pretty_print=pretty_print)
        for CanGlue_ in self.CanGlue:
            namespaceprefix_ = self.CanGlue_nsprefix_ + ':' if (UseCapturedNS_ and self.CanGlue_nsprefix_) else ''
            CanGlue_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CanGlue', pretty_print=pretty_print)
        for Prompt_ in self.Prompt:
            namespaceprefix_ = self.Prompt_nsprefix_ + ':' if (UseCapturedNS_ and self.Prompt_nsprefix_) else ''
            Prompt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Prompt', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Control_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X.append(obj_)
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y.append(obj_)
            obj_.original_tagname_ = 'Y'
        elif nodeName_ == 'XDyn':
            obj_ = XDyn_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XDyn.append(obj_)
            obj_.original_tagname_ = 'XDyn'
        elif nodeName_ == 'YDyn':
            obj_ = YDyn_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.YDyn.append(obj_)
            obj_.original_tagname_ = 'YDyn'
        elif nodeName_ == 'XCon':
            obj_ = XCon_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XCon.append(obj_)
            obj_.original_tagname_ = 'XCon'
        elif nodeName_ == 'YCon':
            obj_ = YCon_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.YCon.append(obj_)
            obj_.original_tagname_ = 'YCon'
        elif nodeName_ == 'CanGlue':
            obj_ = CanGlue_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CanGlue.append(obj_)
            obj_.original_tagname_ = 'CanGlue'
        elif nodeName_ == 'Prompt':
            obj_ = Prompt_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Prompt.append(obj_)
            obj_.original_tagname_ = 'Prompt'
        super(Control_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Control_Type


class XDyn_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(XDyn_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XDyn_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XDyn_Type.subclass:
            return XDyn_Type.subclass(*args_, **kwargs_)
        else:
            return XDyn_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(XDyn_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XDyn_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XDyn_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'XDyn_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XDyn_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XDyn_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XDyn_Type'):
        super(XDyn_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XDyn_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XDyn_Type', fromsubclass_=False, pretty_print=True):
        super(XDyn_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(XDyn_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class XDyn_Type


class YDyn_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(YDyn_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, YDyn_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if YDyn_Type.subclass:
            return YDyn_Type.subclass(*args_, **kwargs_)
        else:
            return YDyn_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(YDyn_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YDyn_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('YDyn_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'YDyn_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YDyn_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='YDyn_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='YDyn_Type'):
        super(YDyn_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YDyn_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YDyn_Type', fromsubclass_=False, pretty_print=True):
        super(YDyn_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(YDyn_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class YDyn_Type


class XCon_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(XCon_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XCon_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XCon_Type.subclass:
            return XCon_Type.subclass(*args_, **kwargs_)
        else:
            return XCon_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(XCon_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XCon_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XCon_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'XCon_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XCon_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XCon_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XCon_Type'):
        super(XCon_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XCon_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XCon_Type', fromsubclass_=False, pretty_print=True):
        super(XCon_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(XCon_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class XCon_Type


class YCon_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(YCon_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, YCon_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if YCon_Type.subclass:
            return YCon_Type.subclass(*args_, **kwargs_)
        else:
            return YCon_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(YCon_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YCon_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('YCon_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'YCon_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YCon_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='YCon_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='YCon_Type'):
        super(YCon_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YCon_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YCon_Type', fromsubclass_=False, pretty_print=True):
        super(YCon_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(YCon_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class YCon_Type


class CanGlue_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CanGlue_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CanGlue_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CanGlue_Type.subclass:
            return CanGlue_Type.subclass(*args_, **kwargs_)
        else:
            return CanGlue_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(CanGlue_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CanGlue_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CanGlue_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CanGlue_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CanGlue_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CanGlue_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CanGlue_Type'):
        super(CanGlue_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CanGlue_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CanGlue_Type', fromsubclass_=False, pretty_print=True):
        super(CanGlue_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CanGlue_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CanGlue_Type


class Geom_Type(GeomSection_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = GeomSection_Type
    def __init__(self, IX=None, Del=None, NoFill=None, NoLine=None, NoShow=None, NoSnap=None, MoveTo=None, LineTo=None, ArcTo=None, InfiniteLine=None, Ellipse=None, EllipticalArcTo=None, SplineStart=None, SplineKnot=None, PolylineTo=None, NURBSTo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Geom_Type, self).__init__(IX, Del,  **kwargs_)
        if NoFill is None:
            self.NoFill = []
        else:
            self.NoFill = NoFill
        self.NoFill_nsprefix_ = None
        if NoLine is None:
            self.NoLine = []
        else:
            self.NoLine = NoLine
        self.NoLine_nsprefix_ = None
        if NoShow is None:
            self.NoShow = []
        else:
            self.NoShow = NoShow
        self.NoShow_nsprefix_ = None
        if NoSnap is None:
            self.NoSnap = []
        else:
            self.NoSnap = NoSnap
        self.NoSnap_nsprefix_ = None
        if MoveTo is None:
            self.MoveTo = []
        else:
            self.MoveTo = MoveTo
        self.MoveTo_nsprefix_ = None
        if LineTo is None:
            self.LineTo = []
        else:
            self.LineTo = LineTo
        self.LineTo_nsprefix_ = None
        if ArcTo is None:
            self.ArcTo = []
        else:
            self.ArcTo = ArcTo
        self.ArcTo_nsprefix_ = None
        if InfiniteLine is None:
            self.InfiniteLine = []
        else:
            self.InfiniteLine = InfiniteLine
        self.InfiniteLine_nsprefix_ = None
        if Ellipse is None:
            self.Ellipse = []
        else:
            self.Ellipse = Ellipse
        self.Ellipse_nsprefix_ = None
        if EllipticalArcTo is None:
            self.EllipticalArcTo = []
        else:
            self.EllipticalArcTo = EllipticalArcTo
        self.EllipticalArcTo_nsprefix_ = None
        if SplineStart is None:
            self.SplineStart = []
        else:
            self.SplineStart = SplineStart
        self.SplineStart_nsprefix_ = None
        if SplineKnot is None:
            self.SplineKnot = []
        else:
            self.SplineKnot = SplineKnot
        self.SplineKnot_nsprefix_ = None
        if PolylineTo is None:
            self.PolylineTo = []
        else:
            self.PolylineTo = PolylineTo
        self.PolylineTo_nsprefix_ = None
        if NURBSTo is None:
            self.NURBSTo = []
        else:
            self.NURBSTo = NURBSTo
        self.NURBSTo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Geom_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Geom_Type.subclass:
            return Geom_Type.subclass(*args_, **kwargs_)
        else:
            return Geom_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NoFill(self):
        return self.NoFill
    def set_NoFill(self, NoFill):
        self.NoFill = NoFill
    def add_NoFill(self, value):
        self.NoFill.append(value)
    def insert_NoFill_at(self, index, value):
        self.NoFill.insert(index, value)
    def replace_NoFill_at(self, index, value):
        self.NoFill[index] = value
    def get_NoLine(self):
        return self.NoLine
    def set_NoLine(self, NoLine):
        self.NoLine = NoLine
    def add_NoLine(self, value):
        self.NoLine.append(value)
    def insert_NoLine_at(self, index, value):
        self.NoLine.insert(index, value)
    def replace_NoLine_at(self, index, value):
        self.NoLine[index] = value
    def get_NoShow(self):
        return self.NoShow
    def set_NoShow(self, NoShow):
        self.NoShow = NoShow
    def add_NoShow(self, value):
        self.NoShow.append(value)
    def insert_NoShow_at(self, index, value):
        self.NoShow.insert(index, value)
    def replace_NoShow_at(self, index, value):
        self.NoShow[index] = value
    def get_NoSnap(self):
        return self.NoSnap
    def set_NoSnap(self, NoSnap):
        self.NoSnap = NoSnap
    def add_NoSnap(self, value):
        self.NoSnap.append(value)
    def insert_NoSnap_at(self, index, value):
        self.NoSnap.insert(index, value)
    def replace_NoSnap_at(self, index, value):
        self.NoSnap[index] = value
    def get_MoveTo(self):
        return self.MoveTo
    def set_MoveTo(self, MoveTo):
        self.MoveTo = MoveTo
    def add_MoveTo(self, value):
        self.MoveTo.append(value)
    def insert_MoveTo_at(self, index, value):
        self.MoveTo.insert(index, value)
    def replace_MoveTo_at(self, index, value):
        self.MoveTo[index] = value
    def get_LineTo(self):
        return self.LineTo
    def set_LineTo(self, LineTo):
        self.LineTo = LineTo
    def add_LineTo(self, value):
        self.LineTo.append(value)
    def insert_LineTo_at(self, index, value):
        self.LineTo.insert(index, value)
    def replace_LineTo_at(self, index, value):
        self.LineTo[index] = value
    def get_ArcTo(self):
        return self.ArcTo
    def set_ArcTo(self, ArcTo):
        self.ArcTo = ArcTo
    def add_ArcTo(self, value):
        self.ArcTo.append(value)
    def insert_ArcTo_at(self, index, value):
        self.ArcTo.insert(index, value)
    def replace_ArcTo_at(self, index, value):
        self.ArcTo[index] = value
    def get_InfiniteLine(self):
        return self.InfiniteLine
    def set_InfiniteLine(self, InfiniteLine):
        self.InfiniteLine = InfiniteLine
    def add_InfiniteLine(self, value):
        self.InfiniteLine.append(value)
    def insert_InfiniteLine_at(self, index, value):
        self.InfiniteLine.insert(index, value)
    def replace_InfiniteLine_at(self, index, value):
        self.InfiniteLine[index] = value
    def get_Ellipse(self):
        return self.Ellipse
    def set_Ellipse(self, Ellipse):
        self.Ellipse = Ellipse
    def add_Ellipse(self, value):
        self.Ellipse.append(value)
    def insert_Ellipse_at(self, index, value):
        self.Ellipse.insert(index, value)
    def replace_Ellipse_at(self, index, value):
        self.Ellipse[index] = value
    def get_EllipticalArcTo(self):
        return self.EllipticalArcTo
    def set_EllipticalArcTo(self, EllipticalArcTo):
        self.EllipticalArcTo = EllipticalArcTo
    def add_EllipticalArcTo(self, value):
        self.EllipticalArcTo.append(value)
    def insert_EllipticalArcTo_at(self, index, value):
        self.EllipticalArcTo.insert(index, value)
    def replace_EllipticalArcTo_at(self, index, value):
        self.EllipticalArcTo[index] = value
    def get_SplineStart(self):
        return self.SplineStart
    def set_SplineStart(self, SplineStart):
        self.SplineStart = SplineStart
    def add_SplineStart(self, value):
        self.SplineStart.append(value)
    def insert_SplineStart_at(self, index, value):
        self.SplineStart.insert(index, value)
    def replace_SplineStart_at(self, index, value):
        self.SplineStart[index] = value
    def get_SplineKnot(self):
        return self.SplineKnot
    def set_SplineKnot(self, SplineKnot):
        self.SplineKnot = SplineKnot
    def add_SplineKnot(self, value):
        self.SplineKnot.append(value)
    def insert_SplineKnot_at(self, index, value):
        self.SplineKnot.insert(index, value)
    def replace_SplineKnot_at(self, index, value):
        self.SplineKnot[index] = value
    def get_PolylineTo(self):
        return self.PolylineTo
    def set_PolylineTo(self, PolylineTo):
        self.PolylineTo = PolylineTo
    def add_PolylineTo(self, value):
        self.PolylineTo.append(value)
    def insert_PolylineTo_at(self, index, value):
        self.PolylineTo.insert(index, value)
    def replace_PolylineTo_at(self, index, value):
        self.PolylineTo[index] = value
    def get_NURBSTo(self):
        return self.NURBSTo
    def set_NURBSTo(self, NURBSTo):
        self.NURBSTo = NURBSTo
    def add_NURBSTo(self, value):
        self.NURBSTo.append(value)
    def insert_NURBSTo_at(self, index, value):
        self.NURBSTo.insert(index, value)
    def replace_NURBSTo_at(self, index, value):
        self.NURBSTo[index] = value
    def hasContent_(self):
        if (
            self.NoFill or
            self.NoLine or
            self.NoShow or
            self.NoSnap or
            self.MoveTo or
            self.LineTo or
            self.ArcTo or
            self.InfiniteLine or
            self.Ellipse or
            self.EllipticalArcTo or
            self.SplineStart or
            self.SplineKnot or
            self.PolylineTo or
            self.NURBSTo or
            super(Geom_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Geom_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Geom_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Geom_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Geom_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Geom_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Geom_Type'):
        super(Geom_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Geom_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Geom_Type', fromsubclass_=False, pretty_print=True):
        super(Geom_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NoFill_ in self.NoFill:
            namespaceprefix_ = self.NoFill_nsprefix_ + ':' if (UseCapturedNS_ and self.NoFill_nsprefix_) else ''
            NoFill_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NoFill', pretty_print=pretty_print)
        for NoLine_ in self.NoLine:
            namespaceprefix_ = self.NoLine_nsprefix_ + ':' if (UseCapturedNS_ and self.NoLine_nsprefix_) else ''
            NoLine_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NoLine', pretty_print=pretty_print)
        for NoShow_ in self.NoShow:
            namespaceprefix_ = self.NoShow_nsprefix_ + ':' if (UseCapturedNS_ and self.NoShow_nsprefix_) else ''
            NoShow_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NoShow', pretty_print=pretty_print)
        for NoSnap_ in self.NoSnap:
            namespaceprefix_ = self.NoSnap_nsprefix_ + ':' if (UseCapturedNS_ and self.NoSnap_nsprefix_) else ''
            NoSnap_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NoSnap', pretty_print=pretty_print)
        for MoveTo_ in self.MoveTo:
            namespaceprefix_ = self.MoveTo_nsprefix_ + ':' if (UseCapturedNS_ and self.MoveTo_nsprefix_) else ''
            MoveTo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MoveTo', pretty_print=pretty_print)
        for LineTo_ in self.LineTo:
            namespaceprefix_ = self.LineTo_nsprefix_ + ':' if (UseCapturedNS_ and self.LineTo_nsprefix_) else ''
            LineTo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LineTo', pretty_print=pretty_print)
        for ArcTo_ in self.ArcTo:
            namespaceprefix_ = self.ArcTo_nsprefix_ + ':' if (UseCapturedNS_ and self.ArcTo_nsprefix_) else ''
            ArcTo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ArcTo', pretty_print=pretty_print)
        for InfiniteLine_ in self.InfiniteLine:
            namespaceprefix_ = self.InfiniteLine_nsprefix_ + ':' if (UseCapturedNS_ and self.InfiniteLine_nsprefix_) else ''
            InfiniteLine_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InfiniteLine', pretty_print=pretty_print)
        for Ellipse_ in self.Ellipse:
            namespaceprefix_ = self.Ellipse_nsprefix_ + ':' if (UseCapturedNS_ and self.Ellipse_nsprefix_) else ''
            Ellipse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Ellipse', pretty_print=pretty_print)
        for EllipticalArcTo_ in self.EllipticalArcTo:
            namespaceprefix_ = self.EllipticalArcTo_nsprefix_ + ':' if (UseCapturedNS_ and self.EllipticalArcTo_nsprefix_) else ''
            EllipticalArcTo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EllipticalArcTo', pretty_print=pretty_print)
        for SplineStart_ in self.SplineStart:
            namespaceprefix_ = self.SplineStart_nsprefix_ + ':' if (UseCapturedNS_ and self.SplineStart_nsprefix_) else ''
            SplineStart_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SplineStart', pretty_print=pretty_print)
        for SplineKnot_ in self.SplineKnot:
            namespaceprefix_ = self.SplineKnot_nsprefix_ + ':' if (UseCapturedNS_ and self.SplineKnot_nsprefix_) else ''
            SplineKnot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SplineKnot', pretty_print=pretty_print)
        for PolylineTo_ in self.PolylineTo:
            namespaceprefix_ = self.PolylineTo_nsprefix_ + ':' if (UseCapturedNS_ and self.PolylineTo_nsprefix_) else ''
            PolylineTo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PolylineTo', pretty_print=pretty_print)
        for NURBSTo_ in self.NURBSTo:
            namespaceprefix_ = self.NURBSTo_nsprefix_ + ':' if (UseCapturedNS_ and self.NURBSTo_nsprefix_) else ''
            NURBSTo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NURBSTo', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Geom_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NoFill':
            obj_ = NoFill_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NoFill.append(obj_)
            obj_.original_tagname_ = 'NoFill'
        elif nodeName_ == 'NoLine':
            obj_ = NoLine_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NoLine.append(obj_)
            obj_.original_tagname_ = 'NoLine'
        elif nodeName_ == 'NoShow':
            obj_ = NoShow_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NoShow.append(obj_)
            obj_.original_tagname_ = 'NoShow'
        elif nodeName_ == 'NoSnap':
            obj_ = NoSnap_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NoSnap.append(obj_)
            obj_.original_tagname_ = 'NoSnap'
        elif nodeName_ == 'MoveTo':
            obj_ = MoveTo_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MoveTo.append(obj_)
            obj_.original_tagname_ = 'MoveTo'
        elif nodeName_ == 'LineTo':
            obj_ = LineTo_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LineTo.append(obj_)
            obj_.original_tagname_ = 'LineTo'
        elif nodeName_ == 'ArcTo':
            obj_ = ArcTo_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ArcTo.append(obj_)
            obj_.original_tagname_ = 'ArcTo'
        elif nodeName_ == 'InfiniteLine':
            obj_ = InfiniteLine_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InfiniteLine.append(obj_)
            obj_.original_tagname_ = 'InfiniteLine'
        elif nodeName_ == 'Ellipse':
            obj_ = Ellipse_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Ellipse.append(obj_)
            obj_.original_tagname_ = 'Ellipse'
        elif nodeName_ == 'EllipticalArcTo':
            obj_ = EllipticalArcTo_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EllipticalArcTo.append(obj_)
            obj_.original_tagname_ = 'EllipticalArcTo'
        elif nodeName_ == 'SplineStart':
            obj_ = SplineStart_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SplineStart.append(obj_)
            obj_.original_tagname_ = 'SplineStart'
        elif nodeName_ == 'SplineKnot':
            obj_ = SplineKnot_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SplineKnot.append(obj_)
            obj_.original_tagname_ = 'SplineKnot'
        elif nodeName_ == 'PolylineTo':
            obj_ = PolylineTo_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PolylineTo.append(obj_)
            obj_.original_tagname_ = 'PolylineTo'
        elif nodeName_ == 'NURBSTo':
            obj_ = NURBSTo_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NURBSTo.append(obj_)
            obj_.original_tagname_ = 'NURBSTo'
        super(Geom_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Geom_Type


class NoFill_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NoFill_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoFill_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoFill_Type.subclass:
            return NoFill_Type.subclass(*args_, **kwargs_)
        else:
            return NoFill_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(NoFill_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoFill_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NoFill_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NoFill_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoFill_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NoFill_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NoFill_Type'):
        super(NoFill_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoFill_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoFill_Type', fromsubclass_=False, pretty_print=True):
        super(NoFill_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NoFill_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NoFill_Type


class NoLine_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NoLine_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoLine_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoLine_Type.subclass:
            return NoLine_Type.subclass(*args_, **kwargs_)
        else:
            return NoLine_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(NoLine_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoLine_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NoLine_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NoLine_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoLine_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NoLine_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NoLine_Type'):
        super(NoLine_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoLine_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoLine_Type', fromsubclass_=False, pretty_print=True):
        super(NoLine_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NoLine_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NoLine_Type


class NoShow_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NoShow_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoShow_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoShow_Type.subclass:
            return NoShow_Type.subclass(*args_, **kwargs_)
        else:
            return NoShow_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(NoShow_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoShow_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NoShow_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NoShow_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoShow_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NoShow_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NoShow_Type'):
        super(NoShow_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoShow_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoShow_Type', fromsubclass_=False, pretty_print=True):
        super(NoShow_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NoShow_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NoShow_Type


class NoSnap_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NoSnap_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoSnap_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoSnap_Type.subclass:
            return NoSnap_Type.subclass(*args_, **kwargs_)
        else:
            return NoSnap_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(NoSnap_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoSnap_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NoSnap_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NoSnap_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoSnap_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NoSnap_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NoSnap_Type'):
        super(NoSnap_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NoSnap_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NoSnap_Type', fromsubclass_=False, pretty_print=True):
        super(NoSnap_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NoSnap_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NoSnap_Type


class MoveTo_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, X=None, Y=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MoveTo_Type, self).__init__(IX, Del,  **kwargs_)
        self.X = X
        self.X_nsprefix_ = None
        self.Y = Y
        self.Y_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MoveTo_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MoveTo_Type.subclass:
            return MoveTo_Type.subclass(*args_, **kwargs_)
        else:
            return MoveTo_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None or
            super(MoveTo_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='MoveTo_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MoveTo_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MoveTo_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MoveTo_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MoveTo_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MoveTo_Type'):
        super(MoveTo_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MoveTo_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='MoveTo_Type', fromsubclass_=False, pretty_print=True):
        super(MoveTo_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            self.X.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        if self.Y is not None:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            self.Y.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MoveTo_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X = obj_
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y = obj_
            obj_.original_tagname_ = 'Y'
        super(MoveTo_Type, self).buildChildren(child_, node, nodeName_, True)
# end class MoveTo_Type


class LineTo_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, X=None, Y=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LineTo_Type, self).__init__(IX, Del,  **kwargs_)
        self.X = X
        self.X_nsprefix_ = None
        self.Y = Y
        self.Y_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LineTo_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LineTo_Type.subclass:
            return LineTo_Type.subclass(*args_, **kwargs_)
        else:
            return LineTo_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None or
            super(LineTo_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='LineTo_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LineTo_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LineTo_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineTo_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LineTo_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LineTo_Type'):
        super(LineTo_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LineTo_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='LineTo_Type', fromsubclass_=False, pretty_print=True):
        super(LineTo_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            self.X.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        if self.Y is not None:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            self.Y.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LineTo_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X = obj_
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y = obj_
            obj_.original_tagname_ = 'Y'
        super(LineTo_Type, self).buildChildren(child_, node, nodeName_, True)
# end class LineTo_Type


class ArcTo_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, X=None, Y=None, A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ArcTo_Type, self).__init__(IX, Del,  **kwargs_)
        self.X = X
        self.X_nsprefix_ = None
        self.Y = Y
        self.Y_nsprefix_ = None
        self.A = A
        self.A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArcTo_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArcTo_Type.subclass:
            return ArcTo_Type.subclass(*args_, **kwargs_)
        else:
            return ArcTo_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def get_A(self):
        return self.A
    def set_A(self, A):
        self.A = A
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None or
            self.A is not None or
            super(ArcTo_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='ArcTo_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArcTo_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArcTo_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArcTo_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ArcTo_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArcTo_Type'):
        super(ArcTo_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArcTo_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='ArcTo_Type', fromsubclass_=False, pretty_print=True):
        super(ArcTo_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            self.X.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        if self.Y is not None:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            self.Y.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
        if self.A is not None:
            namespaceprefix_ = self.A_nsprefix_ + ':' if (UseCapturedNS_ and self.A_nsprefix_) else ''
            self.A.export(outfile, level, namespaceprefix_, namespacedef_='', name_='A', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ArcTo_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X = obj_
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y = obj_
            obj_.original_tagname_ = 'Y'
        elif nodeName_ == 'A':
            obj_ = A_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.A = obj_
            obj_.original_tagname_ = 'A'
        super(ArcTo_Type, self).buildChildren(child_, node, nodeName_, True)
# end class ArcTo_Type


class InfiniteLine_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, X=None, Y=None, A=None, B=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(InfiniteLine_Type, self).__init__(IX, Del,  **kwargs_)
        self.X = X
        self.X_nsprefix_ = None
        self.Y = Y
        self.Y_nsprefix_ = None
        self.A = A
        self.A_nsprefix_ = None
        self.B = B
        self.B_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InfiniteLine_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InfiniteLine_Type.subclass:
            return InfiniteLine_Type.subclass(*args_, **kwargs_)
        else:
            return InfiniteLine_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def get_A(self):
        return self.A
    def set_A(self, A):
        self.A = A
    def get_B(self):
        return self.B
    def set_B(self, B):
        self.B = B
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None or
            self.A is not None or
            self.B is not None or
            super(InfiniteLine_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='InfiniteLine_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InfiniteLine_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InfiniteLine_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InfiniteLine_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InfiniteLine_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InfiniteLine_Type'):
        super(InfiniteLine_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InfiniteLine_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='InfiniteLine_Type', fromsubclass_=False, pretty_print=True):
        super(InfiniteLine_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            self.X.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        if self.Y is not None:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            self.Y.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
        if self.A is not None:
            namespaceprefix_ = self.A_nsprefix_ + ':' if (UseCapturedNS_ and self.A_nsprefix_) else ''
            self.A.export(outfile, level, namespaceprefix_, namespacedef_='', name_='A', pretty_print=pretty_print)
        if self.B is not None:
            namespaceprefix_ = self.B_nsprefix_ + ':' if (UseCapturedNS_ and self.B_nsprefix_) else ''
            self.B.export(outfile, level, namespaceprefix_, namespacedef_='', name_='B', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InfiniteLine_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X = obj_
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y = obj_
            obj_.original_tagname_ = 'Y'
        elif nodeName_ == 'A':
            obj_ = A_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.A = obj_
            obj_.original_tagname_ = 'A'
        elif nodeName_ == 'B':
            obj_ = B_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.B = obj_
            obj_.original_tagname_ = 'B'
        super(InfiniteLine_Type, self).buildChildren(child_, node, nodeName_, True)
# end class InfiniteLine_Type


class Ellipse_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, X=None, Y=None, A=None, B=None, C=None, D=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Ellipse_Type, self).__init__(IX, Del,  **kwargs_)
        self.X = X
        self.X_nsprefix_ = None
        self.Y = Y
        self.Y_nsprefix_ = None
        self.A = A
        self.A_nsprefix_ = None
        self.B = B
        self.B_nsprefix_ = None
        self.C = C
        self.C_nsprefix_ = None
        self.D = D
        self.D_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Ellipse_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Ellipse_Type.subclass:
            return Ellipse_Type.subclass(*args_, **kwargs_)
        else:
            return Ellipse_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def get_A(self):
        return self.A
    def set_A(self, A):
        self.A = A
    def get_B(self):
        return self.B
    def set_B(self, B):
        self.B = B
    def get_C(self):
        return self.C
    def set_C(self, C):
        self.C = C
    def get_D(self):
        return self.D
    def set_D(self, D):
        self.D = D
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None or
            self.A is not None or
            self.B is not None or
            self.C is not None or
            self.D is not None or
            super(Ellipse_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Ellipse_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Ellipse_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Ellipse_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Ellipse_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Ellipse_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Ellipse_Type'):
        super(Ellipse_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Ellipse_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Ellipse_Type', fromsubclass_=False, pretty_print=True):
        super(Ellipse_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            self.X.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        if self.Y is not None:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            self.Y.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
        if self.A is not None:
            namespaceprefix_ = self.A_nsprefix_ + ':' if (UseCapturedNS_ and self.A_nsprefix_) else ''
            self.A.export(outfile, level, namespaceprefix_, namespacedef_='', name_='A', pretty_print=pretty_print)
        if self.B is not None:
            namespaceprefix_ = self.B_nsprefix_ + ':' if (UseCapturedNS_ and self.B_nsprefix_) else ''
            self.B.export(outfile, level, namespaceprefix_, namespacedef_='', name_='B', pretty_print=pretty_print)
        if self.C is not None:
            namespaceprefix_ = self.C_nsprefix_ + ':' if (UseCapturedNS_ and self.C_nsprefix_) else ''
            self.C.export(outfile, level, namespaceprefix_, namespacedef_='', name_='C', pretty_print=pretty_print)
        if self.D is not None:
            namespaceprefix_ = self.D_nsprefix_ + ':' if (UseCapturedNS_ and self.D_nsprefix_) else ''
            self.D.export(outfile, level, namespaceprefix_, namespacedef_='', name_='D', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Ellipse_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X = obj_
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y = obj_
            obj_.original_tagname_ = 'Y'
        elif nodeName_ == 'A':
            obj_ = A_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.A = obj_
            obj_.original_tagname_ = 'A'
        elif nodeName_ == 'B':
            obj_ = B_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.B = obj_
            obj_.original_tagname_ = 'B'
        elif nodeName_ == 'C':
            obj_ = C_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.C = obj_
            obj_.original_tagname_ = 'C'
        elif nodeName_ == 'D':
            obj_ = D_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.D = obj_
            obj_.original_tagname_ = 'D'
        super(Ellipse_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Ellipse_Type


class EllipticalArcTo_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, X=None, Y=None, A=None, B=None, C=None, D=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EllipticalArcTo_Type, self).__init__(IX, Del,  **kwargs_)
        self.X = X
        self.X_nsprefix_ = None
        self.Y = Y
        self.Y_nsprefix_ = None
        self.A = A
        self.A_nsprefix_ = None
        self.B = B
        self.B_nsprefix_ = None
        self.C = C
        self.C_nsprefix_ = None
        self.D = D
        self.D_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EllipticalArcTo_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EllipticalArcTo_Type.subclass:
            return EllipticalArcTo_Type.subclass(*args_, **kwargs_)
        else:
            return EllipticalArcTo_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def get_A(self):
        return self.A
    def set_A(self, A):
        self.A = A
    def get_B(self):
        return self.B
    def set_B(self, B):
        self.B = B
    def get_C(self):
        return self.C
    def set_C(self, C):
        self.C = C
    def get_D(self):
        return self.D
    def set_D(self, D):
        self.D = D
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None or
            self.A is not None or
            self.B is not None or
            self.C is not None or
            self.D is not None or
            super(EllipticalArcTo_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='EllipticalArcTo_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EllipticalArcTo_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EllipticalArcTo_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EllipticalArcTo_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EllipticalArcTo_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EllipticalArcTo_Type'):
        super(EllipticalArcTo_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EllipticalArcTo_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='EllipticalArcTo_Type', fromsubclass_=False, pretty_print=True):
        super(EllipticalArcTo_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            self.X.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        if self.Y is not None:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            self.Y.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
        if self.A is not None:
            namespaceprefix_ = self.A_nsprefix_ + ':' if (UseCapturedNS_ and self.A_nsprefix_) else ''
            self.A.export(outfile, level, namespaceprefix_, namespacedef_='', name_='A', pretty_print=pretty_print)
        if self.B is not None:
            namespaceprefix_ = self.B_nsprefix_ + ':' if (UseCapturedNS_ and self.B_nsprefix_) else ''
            self.B.export(outfile, level, namespaceprefix_, namespacedef_='', name_='B', pretty_print=pretty_print)
        if self.C is not None:
            namespaceprefix_ = self.C_nsprefix_ + ':' if (UseCapturedNS_ and self.C_nsprefix_) else ''
            self.C.export(outfile, level, namespaceprefix_, namespacedef_='', name_='C', pretty_print=pretty_print)
        if self.D is not None:
            namespaceprefix_ = self.D_nsprefix_ + ':' if (UseCapturedNS_ and self.D_nsprefix_) else ''
            self.D.export(outfile, level, namespaceprefix_, namespacedef_='', name_='D', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EllipticalArcTo_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X = obj_
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y = obj_
            obj_.original_tagname_ = 'Y'
        elif nodeName_ == 'A':
            obj_ = A_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.A = obj_
            obj_.original_tagname_ = 'A'
        elif nodeName_ == 'B':
            obj_ = B_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.B = obj_
            obj_.original_tagname_ = 'B'
        elif nodeName_ == 'C':
            obj_ = C_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.C = obj_
            obj_.original_tagname_ = 'C'
        elif nodeName_ == 'D':
            obj_ = D_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.D = obj_
            obj_.original_tagname_ = 'D'
        super(EllipticalArcTo_Type, self).buildChildren(child_, node, nodeName_, True)
# end class EllipticalArcTo_Type


class SplineStart_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, X=None, Y=None, A=None, B=None, C=None, D=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SplineStart_Type, self).__init__(IX, Del,  **kwargs_)
        self.X = X
        self.X_nsprefix_ = None
        self.Y = Y
        self.Y_nsprefix_ = None
        self.A = A
        self.A_nsprefix_ = None
        self.B = B
        self.B_nsprefix_ = None
        self.C = C
        self.C_nsprefix_ = None
        self.D = D
        self.D_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SplineStart_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SplineStart_Type.subclass:
            return SplineStart_Type.subclass(*args_, **kwargs_)
        else:
            return SplineStart_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def get_A(self):
        return self.A
    def set_A(self, A):
        self.A = A
    def get_B(self):
        return self.B
    def set_B(self, B):
        self.B = B
    def get_C(self):
        return self.C
    def set_C(self, C):
        self.C = C
    def get_D(self):
        return self.D
    def set_D(self, D):
        self.D = D
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None or
            self.A is not None or
            self.B is not None or
            self.C is not None or
            self.D is not None or
            super(SplineStart_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='SplineStart_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SplineStart_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SplineStart_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SplineStart_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SplineStart_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SplineStart_Type'):
        super(SplineStart_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SplineStart_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='SplineStart_Type', fromsubclass_=False, pretty_print=True):
        super(SplineStart_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            self.X.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        if self.Y is not None:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            self.Y.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
        if self.A is not None:
            namespaceprefix_ = self.A_nsprefix_ + ':' if (UseCapturedNS_ and self.A_nsprefix_) else ''
            self.A.export(outfile, level, namespaceprefix_, namespacedef_='', name_='A', pretty_print=pretty_print)
        if self.B is not None:
            namespaceprefix_ = self.B_nsprefix_ + ':' if (UseCapturedNS_ and self.B_nsprefix_) else ''
            self.B.export(outfile, level, namespaceprefix_, namespacedef_='', name_='B', pretty_print=pretty_print)
        if self.C is not None:
            namespaceprefix_ = self.C_nsprefix_ + ':' if (UseCapturedNS_ and self.C_nsprefix_) else ''
            self.C.export(outfile, level, namespaceprefix_, namespacedef_='', name_='C', pretty_print=pretty_print)
        if self.D is not None:
            namespaceprefix_ = self.D_nsprefix_ + ':' if (UseCapturedNS_ and self.D_nsprefix_) else ''
            self.D.export(outfile, level, namespaceprefix_, namespacedef_='', name_='D', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SplineStart_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X = obj_
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y = obj_
            obj_.original_tagname_ = 'Y'
        elif nodeName_ == 'A':
            obj_ = A_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.A = obj_
            obj_.original_tagname_ = 'A'
        elif nodeName_ == 'B':
            obj_ = B_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.B = obj_
            obj_.original_tagname_ = 'B'
        elif nodeName_ == 'C':
            obj_ = C_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.C = obj_
            obj_.original_tagname_ = 'C'
        elif nodeName_ == 'D':
            obj_ = D_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.D = obj_
            obj_.original_tagname_ = 'D'
        super(SplineStart_Type, self).buildChildren(child_, node, nodeName_, True)
# end class SplineStart_Type


class SplineKnot_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, X=None, Y=None, A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SplineKnot_Type, self).__init__(IX, Del,  **kwargs_)
        self.X = X
        self.X_nsprefix_ = None
        self.Y = Y
        self.Y_nsprefix_ = None
        self.A = A
        self.A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SplineKnot_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SplineKnot_Type.subclass:
            return SplineKnot_Type.subclass(*args_, **kwargs_)
        else:
            return SplineKnot_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def get_A(self):
        return self.A
    def set_A(self, A):
        self.A = A
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None or
            self.A is not None or
            super(SplineKnot_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='SplineKnot_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SplineKnot_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SplineKnot_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SplineKnot_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SplineKnot_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SplineKnot_Type'):
        super(SplineKnot_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SplineKnot_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='SplineKnot_Type', fromsubclass_=False, pretty_print=True):
        super(SplineKnot_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            self.X.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        if self.Y is not None:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            self.Y.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
        if self.A is not None:
            namespaceprefix_ = self.A_nsprefix_ + ':' if (UseCapturedNS_ and self.A_nsprefix_) else ''
            self.A.export(outfile, level, namespaceprefix_, namespacedef_='', name_='A', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SplineKnot_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X = obj_
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y = obj_
            obj_.original_tagname_ = 'Y'
        elif nodeName_ == 'A':
            obj_ = A_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.A = obj_
            obj_.original_tagname_ = 'A'
        super(SplineKnot_Type, self).buildChildren(child_, node, nodeName_, True)
# end class SplineKnot_Type


class PolylineTo_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, X=None, Y=None, A=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PolylineTo_Type, self).__init__(IX, Del,  **kwargs_)
        self.X = X
        self.X_nsprefix_ = None
        self.Y = Y
        self.Y_nsprefix_ = None
        self.A = A
        self.A_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PolylineTo_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PolylineTo_Type.subclass:
            return PolylineTo_Type.subclass(*args_, **kwargs_)
        else:
            return PolylineTo_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def get_A(self):
        return self.A
    def set_A(self, A):
        self.A = A
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None or
            self.A is not None or
            super(PolylineTo_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='PolylineTo_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PolylineTo_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PolylineTo_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PolylineTo_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PolylineTo_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PolylineTo_Type'):
        super(PolylineTo_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PolylineTo_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='PolylineTo_Type', fromsubclass_=False, pretty_print=True):
        super(PolylineTo_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            self.X.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        if self.Y is not None:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            self.Y.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
        if self.A is not None:
            namespaceprefix_ = self.A_nsprefix_ + ':' if (UseCapturedNS_ and self.A_nsprefix_) else ''
            self.A.export(outfile, level, namespaceprefix_, namespacedef_='', name_='A', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PolylineTo_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X = obj_
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y = obj_
            obj_.original_tagname_ = 'Y'
        elif nodeName_ == 'A':
            obj_ = A_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.A = obj_
            obj_.original_tagname_ = 'A'
        super(PolylineTo_Type, self).buildChildren(child_, node, nodeName_, True)
# end class PolylineTo_Type


class NURBSTo_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, X=None, Y=None, A=None, B=None, C=None, D=None, E=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NURBSTo_Type, self).__init__(IX, Del,  **kwargs_)
        self.X = X
        self.X_nsprefix_ = None
        self.Y = Y
        self.Y_nsprefix_ = None
        self.A = A
        self.A_nsprefix_ = None
        self.B = B
        self.B_nsprefix_ = None
        self.C = C
        self.C_nsprefix_ = None
        self.D = D
        self.D_nsprefix_ = None
        self.E = E
        self.E_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NURBSTo_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NURBSTo_Type.subclass:
            return NURBSTo_Type.subclass(*args_, **kwargs_)
        else:
            return NURBSTo_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def get_A(self):
        return self.A
    def set_A(self, A):
        self.A = A
    def get_B(self):
        return self.B
    def set_B(self, B):
        self.B = B
    def get_C(self):
        return self.C
    def set_C(self, C):
        self.C = C
    def get_D(self):
        return self.D
    def set_D(self, D):
        self.D = D
    def get_E(self):
        return self.E
    def set_E(self, E):
        self.E = E
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None or
            self.A is not None or
            self.B is not None or
            self.C is not None or
            self.D is not None or
            self.E is not None or
            super(NURBSTo_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='NURBSTo_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NURBSTo_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NURBSTo_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NURBSTo_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NURBSTo_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NURBSTo_Type'):
        super(NURBSTo_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NURBSTo_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='NURBSTo_Type', fromsubclass_=False, pretty_print=True):
        super(NURBSTo_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            self.X.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        if self.Y is not None:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            self.Y.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
        if self.A is not None:
            namespaceprefix_ = self.A_nsprefix_ + ':' if (UseCapturedNS_ and self.A_nsprefix_) else ''
            self.A.export(outfile, level, namespaceprefix_, namespacedef_='', name_='A', pretty_print=pretty_print)
        if self.B is not None:
            namespaceprefix_ = self.B_nsprefix_ + ':' if (UseCapturedNS_ and self.B_nsprefix_) else ''
            self.B.export(outfile, level, namespaceprefix_, namespacedef_='', name_='B', pretty_print=pretty_print)
        if self.C is not None:
            namespaceprefix_ = self.C_nsprefix_ + ':' if (UseCapturedNS_ and self.C_nsprefix_) else ''
            self.C.export(outfile, level, namespaceprefix_, namespacedef_='', name_='C', pretty_print=pretty_print)
        if self.D is not None:
            namespaceprefix_ = self.D_nsprefix_ + ':' if (UseCapturedNS_ and self.D_nsprefix_) else ''
            self.D.export(outfile, level, namespaceprefix_, namespacedef_='', name_='D', pretty_print=pretty_print)
        if self.E is not None:
            namespaceprefix_ = self.E_nsprefix_ + ':' if (UseCapturedNS_ and self.E_nsprefix_) else ''
            self.E.export(outfile, level, namespaceprefix_, namespacedef_='', name_='E', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NURBSTo_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X = obj_
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y = obj_
            obj_.original_tagname_ = 'Y'
        elif nodeName_ == 'A':
            obj_ = A_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.A = obj_
            obj_.original_tagname_ = 'A'
        elif nodeName_ == 'B':
            obj_ = B_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.B = obj_
            obj_.original_tagname_ = 'B'
        elif nodeName_ == 'C':
            obj_ = C_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.C = obj_
            obj_.original_tagname_ = 'C'
        elif nodeName_ == 'D':
            obj_ = D_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.D = obj_
            obj_.original_tagname_ = 'D'
        elif nodeName_ == 'E':
            obj_ = E_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.E = obj_
            obj_.original_tagname_ = 'E'
        super(NURBSTo_Type, self).buildChildren(child_, node, nodeName_, True)
# end class NURBSTo_Type


class Act_Type(NamedIndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NamedIndexedRow_Type
    def __init__(self, Name=None, NameU=None, Del=None, ID=None, IX=None, Menu=None, Action=None, Checked=None, Disabled=None, ReadOnly=None, Invisible=None, BeginGroup=None, TagName=None, ButtonFace=None, SortKey=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Act_Type, self).__init__(Name, NameU, Del, ID, IX,  **kwargs_)
        if Menu is None:
            self.Menu = []
        else:
            self.Menu = Menu
        self.Menu_nsprefix_ = None
        if Action is None:
            self.Action = []
        else:
            self.Action = Action
        self.Action_nsprefix_ = None
        if Checked is None:
            self.Checked = []
        else:
            self.Checked = Checked
        self.Checked_nsprefix_ = None
        if Disabled is None:
            self.Disabled = []
        else:
            self.Disabled = Disabled
        self.Disabled_nsprefix_ = None
        if ReadOnly is None:
            self.ReadOnly = []
        else:
            self.ReadOnly = ReadOnly
        self.ReadOnly_nsprefix_ = None
        if Invisible is None:
            self.Invisible = []
        else:
            self.Invisible = Invisible
        self.Invisible_nsprefix_ = None
        if BeginGroup is None:
            self.BeginGroup = []
        else:
            self.BeginGroup = BeginGroup
        self.BeginGroup_nsprefix_ = None
        if TagName is None:
            self.TagName = []
        else:
            self.TagName = TagName
        self.TagName_nsprefix_ = None
        if ButtonFace is None:
            self.ButtonFace = []
        else:
            self.ButtonFace = ButtonFace
        self.ButtonFace_nsprefix_ = None
        if SortKey is None:
            self.SortKey = []
        else:
            self.SortKey = SortKey
        self.SortKey_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Act_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Act_Type.subclass:
            return Act_Type.subclass(*args_, **kwargs_)
        else:
            return Act_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Menu(self):
        return self.Menu
    def set_Menu(self, Menu):
        self.Menu = Menu
    def add_Menu(self, value):
        self.Menu.append(value)
    def insert_Menu_at(self, index, value):
        self.Menu.insert(index, value)
    def replace_Menu_at(self, index, value):
        self.Menu[index] = value
    def get_Action(self):
        return self.Action
    def set_Action(self, Action):
        self.Action = Action
    def add_Action(self, value):
        self.Action.append(value)
    def insert_Action_at(self, index, value):
        self.Action.insert(index, value)
    def replace_Action_at(self, index, value):
        self.Action[index] = value
    def get_Checked(self):
        return self.Checked
    def set_Checked(self, Checked):
        self.Checked = Checked
    def add_Checked(self, value):
        self.Checked.append(value)
    def insert_Checked_at(self, index, value):
        self.Checked.insert(index, value)
    def replace_Checked_at(self, index, value):
        self.Checked[index] = value
    def get_Disabled(self):
        return self.Disabled
    def set_Disabled(self, Disabled):
        self.Disabled = Disabled
    def add_Disabled(self, value):
        self.Disabled.append(value)
    def insert_Disabled_at(self, index, value):
        self.Disabled.insert(index, value)
    def replace_Disabled_at(self, index, value):
        self.Disabled[index] = value
    def get_ReadOnly(self):
        return self.ReadOnly
    def set_ReadOnly(self, ReadOnly):
        self.ReadOnly = ReadOnly
    def add_ReadOnly(self, value):
        self.ReadOnly.append(value)
    def insert_ReadOnly_at(self, index, value):
        self.ReadOnly.insert(index, value)
    def replace_ReadOnly_at(self, index, value):
        self.ReadOnly[index] = value
    def get_Invisible(self):
        return self.Invisible
    def set_Invisible(self, Invisible):
        self.Invisible = Invisible
    def add_Invisible(self, value):
        self.Invisible.append(value)
    def insert_Invisible_at(self, index, value):
        self.Invisible.insert(index, value)
    def replace_Invisible_at(self, index, value):
        self.Invisible[index] = value
    def get_BeginGroup(self):
        return self.BeginGroup
    def set_BeginGroup(self, BeginGroup):
        self.BeginGroup = BeginGroup
    def add_BeginGroup(self, value):
        self.BeginGroup.append(value)
    def insert_BeginGroup_at(self, index, value):
        self.BeginGroup.insert(index, value)
    def replace_BeginGroup_at(self, index, value):
        self.BeginGroup[index] = value
    def get_TagName(self):
        return self.TagName
    def set_TagName(self, TagName):
        self.TagName = TagName
    def add_TagName(self, value):
        self.TagName.append(value)
    def insert_TagName_at(self, index, value):
        self.TagName.insert(index, value)
    def replace_TagName_at(self, index, value):
        self.TagName[index] = value
    def get_ButtonFace(self):
        return self.ButtonFace
    def set_ButtonFace(self, ButtonFace):
        self.ButtonFace = ButtonFace
    def add_ButtonFace(self, value):
        self.ButtonFace.append(value)
    def insert_ButtonFace_at(self, index, value):
        self.ButtonFace.insert(index, value)
    def replace_ButtonFace_at(self, index, value):
        self.ButtonFace[index] = value
    def get_SortKey(self):
        return self.SortKey
    def set_SortKey(self, SortKey):
        self.SortKey = SortKey
    def add_SortKey(self, value):
        self.SortKey.append(value)
    def insert_SortKey_at(self, index, value):
        self.SortKey.insert(index, value)
    def replace_SortKey_at(self, index, value):
        self.SortKey[index] = value
    def hasContent_(self):
        if (
            self.Menu or
            self.Action or
            self.Checked or
            self.Disabled or
            self.ReadOnly or
            self.Invisible or
            self.BeginGroup or
            self.TagName or
            self.ButtonFace or
            self.SortKey or
            super(Act_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Act_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Act_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Act_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Act_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Act_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Act_Type'):
        super(Act_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Act_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Act_Type', fromsubclass_=False, pretty_print=True):
        super(Act_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Menu_ in self.Menu:
            namespaceprefix_ = self.Menu_nsprefix_ + ':' if (UseCapturedNS_ and self.Menu_nsprefix_) else ''
            Menu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Menu', pretty_print=pretty_print)
        for Action_ in self.Action:
            namespaceprefix_ = self.Action_nsprefix_ + ':' if (UseCapturedNS_ and self.Action_nsprefix_) else ''
            Action_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Action', pretty_print=pretty_print)
        for Checked_ in self.Checked:
            namespaceprefix_ = self.Checked_nsprefix_ + ':' if (UseCapturedNS_ and self.Checked_nsprefix_) else ''
            Checked_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Checked', pretty_print=pretty_print)
        for Disabled_ in self.Disabled:
            namespaceprefix_ = self.Disabled_nsprefix_ + ':' if (UseCapturedNS_ and self.Disabled_nsprefix_) else ''
            Disabled_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Disabled', pretty_print=pretty_print)
        for ReadOnly_ in self.ReadOnly:
            namespaceprefix_ = self.ReadOnly_nsprefix_ + ':' if (UseCapturedNS_ and self.ReadOnly_nsprefix_) else ''
            ReadOnly_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReadOnly', pretty_print=pretty_print)
        for Invisible_ in self.Invisible:
            namespaceprefix_ = self.Invisible_nsprefix_ + ':' if (UseCapturedNS_ and self.Invisible_nsprefix_) else ''
            Invisible_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Invisible', pretty_print=pretty_print)
        for BeginGroup_ in self.BeginGroup:
            namespaceprefix_ = self.BeginGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.BeginGroup_nsprefix_) else ''
            BeginGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BeginGroup', pretty_print=pretty_print)
        for TagName_ in self.TagName:
            namespaceprefix_ = self.TagName_nsprefix_ + ':' if (UseCapturedNS_ and self.TagName_nsprefix_) else ''
            TagName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TagName', pretty_print=pretty_print)
        for ButtonFace_ in self.ButtonFace:
            namespaceprefix_ = self.ButtonFace_nsprefix_ + ':' if (UseCapturedNS_ and self.ButtonFace_nsprefix_) else ''
            ButtonFace_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ButtonFace', pretty_print=pretty_print)
        for SortKey_ in self.SortKey:
            namespaceprefix_ = self.SortKey_nsprefix_ + ':' if (UseCapturedNS_ and self.SortKey_nsprefix_) else ''
            SortKey_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SortKey', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Act_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Menu':
            obj_ = Menu_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Menu.append(obj_)
            obj_.original_tagname_ = 'Menu'
        elif nodeName_ == 'Action':
            obj_ = Action_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Action.append(obj_)
            obj_.original_tagname_ = 'Action'
        elif nodeName_ == 'Checked':
            obj_ = Checked_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Checked.append(obj_)
            obj_.original_tagname_ = 'Checked'
        elif nodeName_ == 'Disabled':
            obj_ = Disabled_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Disabled.append(obj_)
            obj_.original_tagname_ = 'Disabled'
        elif nodeName_ == 'ReadOnly':
            obj_ = ReadOnly_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReadOnly.append(obj_)
            obj_.original_tagname_ = 'ReadOnly'
        elif nodeName_ == 'Invisible':
            obj_ = Invisible_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Invisible.append(obj_)
            obj_.original_tagname_ = 'Invisible'
        elif nodeName_ == 'BeginGroup':
            obj_ = BeginGroup_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BeginGroup.append(obj_)
            obj_.original_tagname_ = 'BeginGroup'
        elif nodeName_ == 'TagName':
            obj_ = TagName_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TagName.append(obj_)
            obj_.original_tagname_ = 'TagName'
        elif nodeName_ == 'ButtonFace':
            obj_ = ButtonFace_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ButtonFace.append(obj_)
            obj_.original_tagname_ = 'ButtonFace'
        elif nodeName_ == 'SortKey':
            obj_ = SortKey_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SortKey.append(obj_)
            obj_.original_tagname_ = 'SortKey'
        super(Act_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Act_Type


class Menu_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Menu_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Menu_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Menu_Type.subclass:
            return Menu_Type.subclass(*args_, **kwargs_)
        else:
            return Menu_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Menu_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Menu_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Menu_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Menu_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Menu_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Menu_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Menu_Type'):
        super(Menu_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Menu_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Menu_Type', fromsubclass_=False, pretty_print=True):
        super(Menu_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Menu_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Menu_Type


class Action_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Action_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Action_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Action_Type.subclass:
            return Action_Type.subclass(*args_, **kwargs_)
        else:
            return Action_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Action_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Action_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Action_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Action_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Action_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Action_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Action_Type'):
        super(Action_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Action_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Action_Type', fromsubclass_=False, pretty_print=True):
        super(Action_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Action_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Action_Type


class Checked_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Checked_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Checked_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Checked_Type.subclass:
            return Checked_Type.subclass(*args_, **kwargs_)
        else:
            return Checked_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Checked_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Checked_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Checked_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Checked_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Checked_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Checked_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Checked_Type'):
        super(Checked_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Checked_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Checked_Type', fromsubclass_=False, pretty_print=True):
        super(Checked_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Checked_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Checked_Type


class Disabled_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Disabled_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Disabled_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Disabled_Type.subclass:
            return Disabled_Type.subclass(*args_, **kwargs_)
        else:
            return Disabled_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Disabled_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Disabled_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Disabled_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Disabled_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Disabled_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Disabled_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Disabled_Type'):
        super(Disabled_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Disabled_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Disabled_Type', fromsubclass_=False, pretty_print=True):
        super(Disabled_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Disabled_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Disabled_Type


class ReadOnly_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ReadOnly_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReadOnly_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReadOnly_Type.subclass:
            return ReadOnly_Type.subclass(*args_, **kwargs_)
        else:
            return ReadOnly_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ReadOnly_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReadOnly_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReadOnly_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReadOnly_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadOnly_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReadOnly_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReadOnly_Type'):
        super(ReadOnly_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadOnly_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReadOnly_Type', fromsubclass_=False, pretty_print=True):
        super(ReadOnly_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReadOnly_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ReadOnly_Type


class BeginGroup_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BeginGroup_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BeginGroup_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BeginGroup_Type.subclass:
            return BeginGroup_Type.subclass(*args_, **kwargs_)
        else:
            return BeginGroup_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(BeginGroup_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BeginGroup_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BeginGroup_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BeginGroup_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BeginGroup_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BeginGroup_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BeginGroup_Type'):
        super(BeginGroup_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BeginGroup_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BeginGroup_Type', fromsubclass_=False, pretty_print=True):
        super(BeginGroup_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BeginGroup_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BeginGroup_Type


class TagName_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TagName_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TagName_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TagName_Type.subclass:
            return TagName_Type.subclass(*args_, **kwargs_)
        else:
            return TagName_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(TagName_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TagName_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TagName_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TagName_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TagName_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TagName_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TagName_Type'):
        super(TagName_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TagName_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TagName_Type', fromsubclass_=False, pretty_print=True):
        super(TagName_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TagName_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TagName_Type


class ButtonFace_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ButtonFace_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ButtonFace_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ButtonFace_Type.subclass:
            return ButtonFace_Type.subclass(*args_, **kwargs_)
        else:
            return ButtonFace_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ButtonFace_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ButtonFace_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ButtonFace_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ButtonFace_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ButtonFace_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ButtonFace_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ButtonFace_Type'):
        super(ButtonFace_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ButtonFace_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ButtonFace_Type', fromsubclass_=False, pretty_print=True):
        super(ButtonFace_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ButtonFace_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ButtonFace_Type


class Layer_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, Name=None, Color=None, Status=None, Visible=None, Print=None, Active=None, Lock=None, Snap=None, Glue=None, NameUniv=None, ColorTrans=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Layer_Type, self).__init__(IX, Del,  **kwargs_)
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Color = Color
        self.Color_nsprefix_ = None
        self.Status = Status
        self.Status_nsprefix_ = None
        self.Visible = Visible
        self.Visible_nsprefix_ = None
        self.Print = Print
        self.Print_nsprefix_ = None
        self.Active = Active
        self.Active_nsprefix_ = None
        self.Lock = Lock
        self.Lock_nsprefix_ = None
        self.Snap = Snap
        self.Snap_nsprefix_ = None
        self.Glue = Glue
        self.Glue_nsprefix_ = None
        self.NameUniv = NameUniv
        self.NameUniv_nsprefix_ = None
        self.ColorTrans = ColorTrans
        self.ColorTrans_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Layer_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Layer_Type.subclass:
            return Layer_Type.subclass(*args_, **kwargs_)
        else:
            return Layer_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_Color(self):
        return self.Color
    def set_Color(self, Color):
        self.Color = Color
    def get_Status(self):
        return self.Status
    def set_Status(self, Status):
        self.Status = Status
    def get_Visible(self):
        return self.Visible
    def set_Visible(self, Visible):
        self.Visible = Visible
    def get_Print(self):
        return self.Print
    def set_Print(self, Print):
        self.Print = Print
    def get_Active(self):
        return self.Active
    def set_Active(self, Active):
        self.Active = Active
    def get_Lock(self):
        return self.Lock
    def set_Lock(self, Lock):
        self.Lock = Lock
    def get_Snap(self):
        return self.Snap
    def set_Snap(self, Snap):
        self.Snap = Snap
    def get_Glue(self):
        return self.Glue
    def set_Glue(self, Glue):
        self.Glue = Glue
    def get_NameUniv(self):
        return self.NameUniv
    def set_NameUniv(self, NameUniv):
        self.NameUniv = NameUniv
    def get_ColorTrans(self):
        return self.ColorTrans
    def set_ColorTrans(self, ColorTrans):
        self.ColorTrans = ColorTrans
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Color is not None or
            self.Status is not None or
            self.Visible is not None or
            self.Print is not None or
            self.Active is not None or
            self.Lock is not None or
            self.Snap is not None or
            self.Glue is not None or
            self.NameUniv is not None or
            self.ColorTrans is not None or
            super(Layer_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Layer_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Layer_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Layer_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Layer_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Layer_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Layer_Type'):
        super(Layer_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Layer_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Layer_Type', fromsubclass_=False, pretty_print=True):
        super(Layer_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            self.Name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        if self.Color is not None:
            namespaceprefix_ = self.Color_nsprefix_ + ':' if (UseCapturedNS_ and self.Color_nsprefix_) else ''
            self.Color.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Color', pretty_print=pretty_print)
        if self.Status is not None:
            namespaceprefix_ = self.Status_nsprefix_ + ':' if (UseCapturedNS_ and self.Status_nsprefix_) else ''
            self.Status.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Status', pretty_print=pretty_print)
        if self.Visible is not None:
            namespaceprefix_ = self.Visible_nsprefix_ + ':' if (UseCapturedNS_ and self.Visible_nsprefix_) else ''
            self.Visible.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Visible', pretty_print=pretty_print)
        if self.Print is not None:
            namespaceprefix_ = self.Print_nsprefix_ + ':' if (UseCapturedNS_ and self.Print_nsprefix_) else ''
            self.Print.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Print', pretty_print=pretty_print)
        if self.Active is not None:
            namespaceprefix_ = self.Active_nsprefix_ + ':' if (UseCapturedNS_ and self.Active_nsprefix_) else ''
            self.Active.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Active', pretty_print=pretty_print)
        if self.Lock is not None:
            namespaceprefix_ = self.Lock_nsprefix_ + ':' if (UseCapturedNS_ and self.Lock_nsprefix_) else ''
            self.Lock.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Lock', pretty_print=pretty_print)
        if self.Snap is not None:
            namespaceprefix_ = self.Snap_nsprefix_ + ':' if (UseCapturedNS_ and self.Snap_nsprefix_) else ''
            self.Snap.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Snap', pretty_print=pretty_print)
        if self.Glue is not None:
            namespaceprefix_ = self.Glue_nsprefix_ + ':' if (UseCapturedNS_ and self.Glue_nsprefix_) else ''
            self.Glue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Glue', pretty_print=pretty_print)
        if self.NameUniv is not None:
            namespaceprefix_ = self.NameUniv_nsprefix_ + ':' if (UseCapturedNS_ and self.NameUniv_nsprefix_) else ''
            self.NameUniv.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NameUniv', pretty_print=pretty_print)
        if self.ColorTrans is not None:
            namespaceprefix_ = self.ColorTrans_nsprefix_ + ':' if (UseCapturedNS_ and self.ColorTrans_nsprefix_) else ''
            self.ColorTrans.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ColorTrans', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Layer_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Name':
            obj_ = Name_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Color':
            obj_ = Color_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Color = obj_
            obj_.original_tagname_ = 'Color'
        elif nodeName_ == 'Status':
            obj_ = Status_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Status = obj_
            obj_.original_tagname_ = 'Status'
        elif nodeName_ == 'Visible':
            obj_ = Visible_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Visible = obj_
            obj_.original_tagname_ = 'Visible'
        elif nodeName_ == 'Print':
            obj_ = Print_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Print = obj_
            obj_.original_tagname_ = 'Print'
        elif nodeName_ == 'Active':
            obj_ = Active_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Active = obj_
            obj_.original_tagname_ = 'Active'
        elif nodeName_ == 'Lock':
            obj_ = Lock_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Lock = obj_
            obj_.original_tagname_ = 'Lock'
        elif nodeName_ == 'Snap':
            obj_ = Snap_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Snap = obj_
            obj_.original_tagname_ = 'Snap'
        elif nodeName_ == 'Glue':
            obj_ = Glue_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Glue = obj_
            obj_.original_tagname_ = 'Glue'
        elif nodeName_ == 'NameUniv':
            obj_ = NameUniv_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NameUniv = obj_
            obj_.original_tagname_ = 'NameUniv'
        elif nodeName_ == 'ColorTrans':
            obj_ = ColorTrans_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ColorTrans = obj_
            obj_.original_tagname_ = 'ColorTrans'
        super(Layer_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Layer_Type


class Name_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Name_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Name_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Name_Type.subclass:
            return Name_Type.subclass(*args_, **kwargs_)
        else:
            return Name_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Name_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Name_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Name_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Name_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Name_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Name_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Name_Type'):
        super(Name_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Name_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Name_Type', fromsubclass_=False, pretty_print=True):
        super(Name_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Name_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Name_Type


class Status_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Status_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Status_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Status_Type.subclass:
            return Status_Type.subclass(*args_, **kwargs_)
        else:
            return Status_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Status_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Status_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Status_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Status_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Status_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Status_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Status_Type'):
        super(Status_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Status_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Status_Type', fromsubclass_=False, pretty_print=True):
        super(Status_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Status_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Status_Type


class Visible_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Visible_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Visible_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Visible_Type.subclass:
            return Visible_Type.subclass(*args_, **kwargs_)
        else:
            return Visible_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Visible_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Visible_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Visible_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Visible_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Visible_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Visible_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Visible_Type'):
        super(Visible_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Visible_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Visible_Type', fromsubclass_=False, pretty_print=True):
        super(Visible_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Visible_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Visible_Type


class Print_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Print_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Print_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Print_Type.subclass:
            return Print_Type.subclass(*args_, **kwargs_)
        else:
            return Print_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Print_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Print_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Print_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Print_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Print_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Print_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Print_Type'):
        super(Print_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Print_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Print_Type', fromsubclass_=False, pretty_print=True):
        super(Print_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Print_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Print_Type


class Active_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Active_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Active_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Active_Type.subclass:
            return Active_Type.subclass(*args_, **kwargs_)
        else:
            return Active_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Active_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Active_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Active_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Active_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Active_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Active_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Active_Type'):
        super(Active_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Active_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Active_Type', fromsubclass_=False, pretty_print=True):
        super(Active_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Active_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Active_Type


class Lock_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Lock_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Lock_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Lock_Type.subclass:
            return Lock_Type.subclass(*args_, **kwargs_)
        else:
            return Lock_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Lock_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Lock_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Lock_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Lock_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Lock_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Lock_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Lock_Type'):
        super(Lock_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Lock_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Lock_Type', fromsubclass_=False, pretty_print=True):
        super(Lock_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Lock_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Lock_Type


class Snap_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Snap_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Snap_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Snap_Type.subclass:
            return Snap_Type.subclass(*args_, **kwargs_)
        else:
            return Snap_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Snap_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Snap_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Snap_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Snap_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Snap_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Snap_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Snap_Type'):
        super(Snap_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Snap_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Snap_Type', fromsubclass_=False, pretty_print=True):
        super(Snap_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Snap_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Snap_Type


class Glue_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Glue_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Glue_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Glue_Type.subclass:
            return Glue_Type.subclass(*args_, **kwargs_)
        else:
            return Glue_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Glue_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Glue_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Glue_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Glue_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Glue_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Glue_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Glue_Type'):
        super(Glue_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Glue_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Glue_Type', fromsubclass_=False, pretty_print=True):
        super(Glue_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Glue_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Glue_Type


class NameUniv_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NameUniv_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameUniv_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameUniv_Type.subclass:
            return NameUniv_Type.subclass(*args_, **kwargs_)
        else:
            return NameUniv_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(NameUniv_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NameUniv_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NameUniv_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NameUniv_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NameUniv_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NameUniv_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NameUniv_Type'):
        super(NameUniv_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NameUniv_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NameUniv_Type', fromsubclass_=False, pretty_print=True):
        super(NameUniv_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NameUniv_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NameUniv_Type


class User_Type(NamedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NamedRow_Type
    def __init__(self, Name=None, NameU=None, Del=None, ID=None, Value=None, Prompt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(User_Type, self).__init__(Name, NameU, Del, ID,  **kwargs_)
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        self.Value_nsprefix_ = None
        if Prompt is None:
            self.Prompt = []
        else:
            self.Prompt = Prompt
        self.Prompt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, User_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if User_Type.subclass:
            return User_Type.subclass(*args_, **kwargs_)
        else:
            return User_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Value(self):
        return self.Value
    def set_Value(self, Value):
        self.Value = Value
    def add_Value(self, value):
        self.Value.append(value)
    def insert_Value_at(self, index, value):
        self.Value.insert(index, value)
    def replace_Value_at(self, index, value):
        self.Value[index] = value
    def get_Prompt(self):
        return self.Prompt
    def set_Prompt(self, Prompt):
        self.Prompt = Prompt
    def add_Prompt(self, value):
        self.Prompt.append(value)
    def insert_Prompt_at(self, index, value):
        self.Prompt.insert(index, value)
    def replace_Prompt_at(self, index, value):
        self.Prompt[index] = value
    def hasContent_(self):
        if (
            self.Value or
            self.Prompt or
            super(User_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='User_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('User_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'User_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='User_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='User_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='User_Type'):
        super(User_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='User_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='User_Type', fromsubclass_=False, pretty_print=True):
        super(User_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Value_ in self.Value:
            namespaceprefix_ = self.Value_nsprefix_ + ':' if (UseCapturedNS_ and self.Value_nsprefix_) else ''
            Value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Value', pretty_print=pretty_print)
        for Prompt_ in self.Prompt:
            namespaceprefix_ = self.Prompt_nsprefix_ + ':' if (UseCapturedNS_ and self.Prompt_nsprefix_) else ''
            Prompt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Prompt', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(User_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Value':
            obj_ = Value_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
        elif nodeName_ == 'Prompt':
            obj_ = Prompt_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Prompt.append(obj_)
            obj_.original_tagname_ = 'Prompt'
        super(User_Type, self).buildChildren(child_, node, nodeName_, True)
# end class User_Type


class Prop_Type(NamedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NamedRow_Type
    def __init__(self, Name=None, NameU=None, Del=None, ID=None, Value=None, Prompt=None, Label=None, Format=None, SortKey=None, Type=None, Invisible=None, Verify=None, LangID=None, Calendar=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Prop_Type, self).__init__(Name, NameU, Del, ID,  **kwargs_)
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        self.Value_nsprefix_ = None
        if Prompt is None:
            self.Prompt = []
        else:
            self.Prompt = Prompt
        self.Prompt_nsprefix_ = None
        if Label is None:
            self.Label = []
        else:
            self.Label = Label
        self.Label_nsprefix_ = None
        if Format is None:
            self.Format = []
        else:
            self.Format = Format
        self.Format_nsprefix_ = None
        if SortKey is None:
            self.SortKey = []
        else:
            self.SortKey = SortKey
        self.SortKey_nsprefix_ = None
        if Type is None:
            self.Type = []
        else:
            self.Type = Type
        self.Type_nsprefix_ = None
        if Invisible is None:
            self.Invisible = []
        else:
            self.Invisible = Invisible
        self.Invisible_nsprefix_ = None
        if Verify is None:
            self.Verify = []
        else:
            self.Verify = Verify
        self.Verify_nsprefix_ = None
        if LangID is None:
            self.LangID = []
        else:
            self.LangID = LangID
        self.LangID_nsprefix_ = None
        if Calendar is None:
            self.Calendar = []
        else:
            self.Calendar = Calendar
        self.Calendar_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Prop_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Prop_Type.subclass:
            return Prop_Type.subclass(*args_, **kwargs_)
        else:
            return Prop_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Value(self):
        return self.Value
    def set_Value(self, Value):
        self.Value = Value
    def add_Value(self, value):
        self.Value.append(value)
    def insert_Value_at(self, index, value):
        self.Value.insert(index, value)
    def replace_Value_at(self, index, value):
        self.Value[index] = value
    def get_Prompt(self):
        return self.Prompt
    def set_Prompt(self, Prompt):
        self.Prompt = Prompt
    def add_Prompt(self, value):
        self.Prompt.append(value)
    def insert_Prompt_at(self, index, value):
        self.Prompt.insert(index, value)
    def replace_Prompt_at(self, index, value):
        self.Prompt[index] = value
    def get_Label(self):
        return self.Label
    def set_Label(self, Label):
        self.Label = Label
    def add_Label(self, value):
        self.Label.append(value)
    def insert_Label_at(self, index, value):
        self.Label.insert(index, value)
    def replace_Label_at(self, index, value):
        self.Label[index] = value
    def get_Format(self):
        return self.Format
    def set_Format(self, Format):
        self.Format = Format
    def add_Format(self, value):
        self.Format.append(value)
    def insert_Format_at(self, index, value):
        self.Format.insert(index, value)
    def replace_Format_at(self, index, value):
        self.Format[index] = value
    def get_SortKey(self):
        return self.SortKey
    def set_SortKey(self, SortKey):
        self.SortKey = SortKey
    def add_SortKey(self, value):
        self.SortKey.append(value)
    def insert_SortKey_at(self, index, value):
        self.SortKey.insert(index, value)
    def replace_SortKey_at(self, index, value):
        self.SortKey[index] = value
    def get_Type(self):
        return self.Type
    def set_Type(self, Type):
        self.Type = Type
    def add_Type(self, value):
        self.Type.append(value)
    def insert_Type_at(self, index, value):
        self.Type.insert(index, value)
    def replace_Type_at(self, index, value):
        self.Type[index] = value
    def get_Invisible(self):
        return self.Invisible
    def set_Invisible(self, Invisible):
        self.Invisible = Invisible
    def add_Invisible(self, value):
        self.Invisible.append(value)
    def insert_Invisible_at(self, index, value):
        self.Invisible.insert(index, value)
    def replace_Invisible_at(self, index, value):
        self.Invisible[index] = value
    def get_Verify(self):
        return self.Verify
    def set_Verify(self, Verify):
        self.Verify = Verify
    def add_Verify(self, value):
        self.Verify.append(value)
    def insert_Verify_at(self, index, value):
        self.Verify.insert(index, value)
    def replace_Verify_at(self, index, value):
        self.Verify[index] = value
    def get_LangID(self):
        return self.LangID
    def set_LangID(self, LangID):
        self.LangID = LangID
    def add_LangID(self, value):
        self.LangID.append(value)
    def insert_LangID_at(self, index, value):
        self.LangID.insert(index, value)
    def replace_LangID_at(self, index, value):
        self.LangID[index] = value
    def get_Calendar(self):
        return self.Calendar
    def set_Calendar(self, Calendar):
        self.Calendar = Calendar
    def add_Calendar(self, value):
        self.Calendar.append(value)
    def insert_Calendar_at(self, index, value):
        self.Calendar.insert(index, value)
    def replace_Calendar_at(self, index, value):
        self.Calendar[index] = value
    def hasContent_(self):
        if (
            self.Value or
            self.Prompt or
            self.Label or
            self.Format or
            self.SortKey or
            self.Type or
            self.Invisible or
            self.Verify or
            self.LangID or
            self.Calendar or
            super(Prop_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Prop_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Prop_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Prop_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Prop_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Prop_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Prop_Type'):
        super(Prop_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Prop_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Prop_Type', fromsubclass_=False, pretty_print=True):
        super(Prop_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Value_ in self.Value:
            namespaceprefix_ = self.Value_nsprefix_ + ':' if (UseCapturedNS_ and self.Value_nsprefix_) else ''
            Value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Value', pretty_print=pretty_print)
        for Prompt_ in self.Prompt:
            namespaceprefix_ = self.Prompt_nsprefix_ + ':' if (UseCapturedNS_ and self.Prompt_nsprefix_) else ''
            Prompt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Prompt', pretty_print=pretty_print)
        for Label_ in self.Label:
            namespaceprefix_ = self.Label_nsprefix_ + ':' if (UseCapturedNS_ and self.Label_nsprefix_) else ''
            Label_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Label', pretty_print=pretty_print)
        for Format_ in self.Format:
            namespaceprefix_ = self.Format_nsprefix_ + ':' if (UseCapturedNS_ and self.Format_nsprefix_) else ''
            Format_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Format', pretty_print=pretty_print)
        for SortKey_ in self.SortKey:
            namespaceprefix_ = self.SortKey_nsprefix_ + ':' if (UseCapturedNS_ and self.SortKey_nsprefix_) else ''
            SortKey_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SortKey', pretty_print=pretty_print)
        for Type_ in self.Type:
            namespaceprefix_ = self.Type_nsprefix_ + ':' if (UseCapturedNS_ and self.Type_nsprefix_) else ''
            Type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Type', pretty_print=pretty_print)
        for Invisible_ in self.Invisible:
            namespaceprefix_ = self.Invisible_nsprefix_ + ':' if (UseCapturedNS_ and self.Invisible_nsprefix_) else ''
            Invisible_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Invisible', pretty_print=pretty_print)
        for Verify_ in self.Verify:
            namespaceprefix_ = self.Verify_nsprefix_ + ':' if (UseCapturedNS_ and self.Verify_nsprefix_) else ''
            Verify_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Verify', pretty_print=pretty_print)
        for LangID_ in self.LangID:
            namespaceprefix_ = self.LangID_nsprefix_ + ':' if (UseCapturedNS_ and self.LangID_nsprefix_) else ''
            LangID_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LangID', pretty_print=pretty_print)
        for Calendar_ in self.Calendar:
            namespaceprefix_ = self.Calendar_nsprefix_ + ':' if (UseCapturedNS_ and self.Calendar_nsprefix_) else ''
            Calendar_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Calendar', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Prop_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Value':
            obj_ = Value_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
        elif nodeName_ == 'Prompt':
            obj_ = Prompt_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Prompt.append(obj_)
            obj_.original_tagname_ = 'Prompt'
        elif nodeName_ == 'Label':
            obj_ = Label_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Label.append(obj_)
            obj_.original_tagname_ = 'Label'
        elif nodeName_ == 'Format':
            obj_ = Format_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Format.append(obj_)
            obj_.original_tagname_ = 'Format'
        elif nodeName_ == 'SortKey':
            obj_ = SortKey_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SortKey.append(obj_)
            obj_.original_tagname_ = 'SortKey'
        elif nodeName_ == 'Type':
            obj_ = Type_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Type.append(obj_)
            obj_.original_tagname_ = 'Type'
        elif nodeName_ == 'Invisible':
            obj_ = Invisible_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Invisible.append(obj_)
            obj_.original_tagname_ = 'Invisible'
        elif nodeName_ == 'Verify':
            obj_ = Verify_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Verify.append(obj_)
            obj_.original_tagname_ = 'Verify'
        elif nodeName_ == 'LangID':
            obj_ = LangID_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LangID.append(obj_)
            obj_.original_tagname_ = 'LangID'
        elif nodeName_ == 'Calendar':
            obj_ = Calendar_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Calendar.append(obj_)
            obj_.original_tagname_ = 'Calendar'
        super(Prop_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Prop_Type


class Label_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Label_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Label_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Label_Type.subclass:
            return Label_Type.subclass(*args_, **kwargs_)
        else:
            return Label_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Label_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Label_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Label_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Label_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Label_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Label_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Label_Type'):
        super(Label_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Label_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Label_Type', fromsubclass_=False, pretty_print=True):
        super(Label_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Label_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Label_Type


class Verify_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Verify_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Verify_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Verify_Type.subclass:
            return Verify_Type.subclass(*args_, **kwargs_)
        else:
            return Verify_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Verify_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Verify_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Verify_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Verify_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Verify_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Verify_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Verify_Type'):
        super(Verify_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Verify_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Verify_Type', fromsubclass_=False, pretty_print=True):
        super(Verify_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Verify_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Verify_Type


class Hyperlink_Type(NamedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NamedRow_Type
    def __init__(self, Name=None, NameU=None, Del=None, ID=None, Description=None, Address=None, SubAddress=None, ExtraInfo=None, Frame=None, NewWindow=None, Default=None, Invisible=None, SortKey=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Hyperlink_Type, self).__init__(Name, NameU, Del, ID,  **kwargs_)
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.Description_nsprefix_ = None
        if Address is None:
            self.Address = []
        else:
            self.Address = Address
        self.Address_nsprefix_ = None
        if SubAddress is None:
            self.SubAddress = []
        else:
            self.SubAddress = SubAddress
        self.SubAddress_nsprefix_ = None
        if ExtraInfo is None:
            self.ExtraInfo = []
        else:
            self.ExtraInfo = ExtraInfo
        self.ExtraInfo_nsprefix_ = None
        if Frame is None:
            self.Frame = []
        else:
            self.Frame = Frame
        self.Frame_nsprefix_ = None
        if NewWindow is None:
            self.NewWindow = []
        else:
            self.NewWindow = NewWindow
        self.NewWindow_nsprefix_ = None
        if Default is None:
            self.Default = []
        else:
            self.Default = Default
        self.Default_nsprefix_ = None
        if Invisible is None:
            self.Invisible = []
        else:
            self.Invisible = Invisible
        self.Invisible_nsprefix_ = None
        if SortKey is None:
            self.SortKey = []
        else:
            self.SortKey = SortKey
        self.SortKey_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Hyperlink_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Hyperlink_Type.subclass:
            return Hyperlink_Type.subclass(*args_, **kwargs_)
        else:
            return Hyperlink_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Description(self):
        return self.Description
    def set_Description(self, Description):
        self.Description = Description
    def add_Description(self, value):
        self.Description.append(value)
    def insert_Description_at(self, index, value):
        self.Description.insert(index, value)
    def replace_Description_at(self, index, value):
        self.Description[index] = value
    def get_Address(self):
        return self.Address
    def set_Address(self, Address):
        self.Address = Address
    def add_Address(self, value):
        self.Address.append(value)
    def insert_Address_at(self, index, value):
        self.Address.insert(index, value)
    def replace_Address_at(self, index, value):
        self.Address[index] = value
    def get_SubAddress(self):
        return self.SubAddress
    def set_SubAddress(self, SubAddress):
        self.SubAddress = SubAddress
    def add_SubAddress(self, value):
        self.SubAddress.append(value)
    def insert_SubAddress_at(self, index, value):
        self.SubAddress.insert(index, value)
    def replace_SubAddress_at(self, index, value):
        self.SubAddress[index] = value
    def get_ExtraInfo(self):
        return self.ExtraInfo
    def set_ExtraInfo(self, ExtraInfo):
        self.ExtraInfo = ExtraInfo
    def add_ExtraInfo(self, value):
        self.ExtraInfo.append(value)
    def insert_ExtraInfo_at(self, index, value):
        self.ExtraInfo.insert(index, value)
    def replace_ExtraInfo_at(self, index, value):
        self.ExtraInfo[index] = value
    def get_Frame(self):
        return self.Frame
    def set_Frame(self, Frame):
        self.Frame = Frame
    def add_Frame(self, value):
        self.Frame.append(value)
    def insert_Frame_at(self, index, value):
        self.Frame.insert(index, value)
    def replace_Frame_at(self, index, value):
        self.Frame[index] = value
    def get_NewWindow(self):
        return self.NewWindow
    def set_NewWindow(self, NewWindow):
        self.NewWindow = NewWindow
    def add_NewWindow(self, value):
        self.NewWindow.append(value)
    def insert_NewWindow_at(self, index, value):
        self.NewWindow.insert(index, value)
    def replace_NewWindow_at(self, index, value):
        self.NewWindow[index] = value
    def get_Default(self):
        return self.Default
    def set_Default(self, Default):
        self.Default = Default
    def add_Default(self, value):
        self.Default.append(value)
    def insert_Default_at(self, index, value):
        self.Default.insert(index, value)
    def replace_Default_at(self, index, value):
        self.Default[index] = value
    def get_Invisible(self):
        return self.Invisible
    def set_Invisible(self, Invisible):
        self.Invisible = Invisible
    def add_Invisible(self, value):
        self.Invisible.append(value)
    def insert_Invisible_at(self, index, value):
        self.Invisible.insert(index, value)
    def replace_Invisible_at(self, index, value):
        self.Invisible[index] = value
    def get_SortKey(self):
        return self.SortKey
    def set_SortKey(self, SortKey):
        self.SortKey = SortKey
    def add_SortKey(self, value):
        self.SortKey.append(value)
    def insert_SortKey_at(self, index, value):
        self.SortKey.insert(index, value)
    def replace_SortKey_at(self, index, value):
        self.SortKey[index] = value
    def hasContent_(self):
        if (
            self.Description or
            self.Address or
            self.SubAddress or
            self.ExtraInfo or
            self.Frame or
            self.NewWindow or
            self.Default or
            self.Invisible or
            self.SortKey or
            super(Hyperlink_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Hyperlink_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Hyperlink_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Hyperlink_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Hyperlink_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Hyperlink_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Hyperlink_Type'):
        super(Hyperlink_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Hyperlink_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Hyperlink_Type', fromsubclass_=False, pretty_print=True):
        super(Hyperlink_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Description_ in self.Description:
            namespaceprefix_ = self.Description_nsprefix_ + ':' if (UseCapturedNS_ and self.Description_nsprefix_) else ''
            Description_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Description', pretty_print=pretty_print)
        for Address_ in self.Address:
            namespaceprefix_ = self.Address_nsprefix_ + ':' if (UseCapturedNS_ and self.Address_nsprefix_) else ''
            Address_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Address', pretty_print=pretty_print)
        for SubAddress_ in self.SubAddress:
            namespaceprefix_ = self.SubAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.SubAddress_nsprefix_) else ''
            SubAddress_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SubAddress', pretty_print=pretty_print)
        for ExtraInfo_ in self.ExtraInfo:
            namespaceprefix_ = self.ExtraInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.ExtraInfo_nsprefix_) else ''
            ExtraInfo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ExtraInfo', pretty_print=pretty_print)
        for Frame_ in self.Frame:
            namespaceprefix_ = self.Frame_nsprefix_ + ':' if (UseCapturedNS_ and self.Frame_nsprefix_) else ''
            Frame_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Frame', pretty_print=pretty_print)
        for NewWindow_ in self.NewWindow:
            namespaceprefix_ = self.NewWindow_nsprefix_ + ':' if (UseCapturedNS_ and self.NewWindow_nsprefix_) else ''
            NewWindow_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NewWindow', pretty_print=pretty_print)
        for Default_ in self.Default:
            namespaceprefix_ = self.Default_nsprefix_ + ':' if (UseCapturedNS_ and self.Default_nsprefix_) else ''
            Default_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Default', pretty_print=pretty_print)
        for Invisible_ in self.Invisible:
            namespaceprefix_ = self.Invisible_nsprefix_ + ':' if (UseCapturedNS_ and self.Invisible_nsprefix_) else ''
            Invisible_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Invisible', pretty_print=pretty_print)
        for SortKey_ in self.SortKey:
            namespaceprefix_ = self.SortKey_nsprefix_ + ':' if (UseCapturedNS_ and self.SortKey_nsprefix_) else ''
            SortKey_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SortKey', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Hyperlink_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Description':
            obj_ = Description_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Address':
            obj_ = Address_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Address.append(obj_)
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'SubAddress':
            obj_ = SubAddress_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SubAddress.append(obj_)
            obj_.original_tagname_ = 'SubAddress'
        elif nodeName_ == 'ExtraInfo':
            obj_ = ExtraInfo_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ExtraInfo.append(obj_)
            obj_.original_tagname_ = 'ExtraInfo'
        elif nodeName_ == 'Frame':
            obj_ = Frame_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Frame.append(obj_)
            obj_.original_tagname_ = 'Frame'
        elif nodeName_ == 'NewWindow':
            obj_ = NewWindow_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NewWindow.append(obj_)
            obj_.original_tagname_ = 'NewWindow'
        elif nodeName_ == 'Default':
            obj_ = Default_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Default.append(obj_)
            obj_.original_tagname_ = 'Default'
        elif nodeName_ == 'Invisible':
            obj_ = Invisible_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Invisible.append(obj_)
            obj_.original_tagname_ = 'Invisible'
        elif nodeName_ == 'SortKey':
            obj_ = SortKey_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SortKey.append(obj_)
            obj_.original_tagname_ = 'SortKey'
        super(Hyperlink_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Hyperlink_Type


class Reviewer_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, Name=None, Initials=None, Color=None, ReviewerID=None, CurrentIndex=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Reviewer_Type, self).__init__(IX, Del,  **kwargs_)
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Initials = Initials
        self.Initials_nsprefix_ = None
        self.Color = Color
        self.Color_nsprefix_ = None
        self.ReviewerID = ReviewerID
        self.ReviewerID_nsprefix_ = None
        self.CurrentIndex = CurrentIndex
        self.CurrentIndex_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Reviewer_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Reviewer_Type.subclass:
            return Reviewer_Type.subclass(*args_, **kwargs_)
        else:
            return Reviewer_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_Initials(self):
        return self.Initials
    def set_Initials(self, Initials):
        self.Initials = Initials
    def get_Color(self):
        return self.Color
    def set_Color(self, Color):
        self.Color = Color
    def get_ReviewerID(self):
        return self.ReviewerID
    def set_ReviewerID(self, ReviewerID):
        self.ReviewerID = ReviewerID
    def get_CurrentIndex(self):
        return self.CurrentIndex
    def set_CurrentIndex(self, CurrentIndex):
        self.CurrentIndex = CurrentIndex
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Initials is not None or
            self.Color is not None or
            self.ReviewerID is not None or
            self.CurrentIndex is not None or
            super(Reviewer_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Reviewer_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Reviewer_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Reviewer_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Reviewer_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Reviewer_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Reviewer_Type'):
        super(Reviewer_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Reviewer_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Reviewer_Type', fromsubclass_=False, pretty_print=True):
        super(Reviewer_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            self.Name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        if self.Initials is not None:
            namespaceprefix_ = self.Initials_nsprefix_ + ':' if (UseCapturedNS_ and self.Initials_nsprefix_) else ''
            self.Initials.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Initials', pretty_print=pretty_print)
        if self.Color is not None:
            namespaceprefix_ = self.Color_nsprefix_ + ':' if (UseCapturedNS_ and self.Color_nsprefix_) else ''
            self.Color.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Color', pretty_print=pretty_print)
        if self.ReviewerID is not None:
            namespaceprefix_ = self.ReviewerID_nsprefix_ + ':' if (UseCapturedNS_ and self.ReviewerID_nsprefix_) else ''
            self.ReviewerID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReviewerID', pretty_print=pretty_print)
        if self.CurrentIndex is not None:
            namespaceprefix_ = self.CurrentIndex_nsprefix_ + ':' if (UseCapturedNS_ and self.CurrentIndex_nsprefix_) else ''
            self.CurrentIndex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CurrentIndex', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Reviewer_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Name':
            obj_ = Name_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Initials':
            obj_ = Initials_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Initials = obj_
            obj_.original_tagname_ = 'Initials'
        elif nodeName_ == 'Color':
            obj_ = Color_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Color = obj_
            obj_.original_tagname_ = 'Color'
        elif nodeName_ == 'ReviewerID':
            obj_ = ReviewerID_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReviewerID = obj_
            obj_.original_tagname_ = 'ReviewerID'
        elif nodeName_ == 'CurrentIndex':
            obj_ = CurrentIndex_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CurrentIndex = obj_
            obj_.original_tagname_ = 'CurrentIndex'
        super(Reviewer_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Reviewer_Type


class Initials_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Initials_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Initials_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Initials_Type.subclass:
            return Initials_Type.subclass(*args_, **kwargs_)
        else:
            return Initials_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Initials_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Initials_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Initials_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Initials_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Initials_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Initials_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Initials_Type'):
        super(Initials_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Initials_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Initials_Type', fromsubclass_=False, pretty_print=True):
        super(Initials_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Initials_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Initials_Type


class ReviewerID_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ReviewerID_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReviewerID_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReviewerID_Type.subclass:
            return ReviewerID_Type.subclass(*args_, **kwargs_)
        else:
            return ReviewerID_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(ReviewerID_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReviewerID_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReviewerID_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReviewerID_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReviewerID_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReviewerID_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReviewerID_Type'):
        super(ReviewerID_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReviewerID_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReviewerID_Type', fromsubclass_=False, pretty_print=True):
        super(ReviewerID_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReviewerID_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ReviewerID_Type


class CurrentIndex_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CurrentIndex_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CurrentIndex_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CurrentIndex_Type.subclass:
            return CurrentIndex_Type.subclass(*args_, **kwargs_)
        else:
            return CurrentIndex_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(CurrentIndex_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CurrentIndex_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CurrentIndex_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CurrentIndex_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CurrentIndex_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CurrentIndex_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CurrentIndex_Type'):
        super(CurrentIndex_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CurrentIndex_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CurrentIndex_Type', fromsubclass_=False, pretty_print=True):
        super(CurrentIndex_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CurrentIndex_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CurrentIndex_Type


class Annotation_Type(IndexedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IndexedRow_Type
    def __init__(self, IX=None, Del=None, X=None, Y=None, ReviewerID=None, MarkerIndex=None, Date=None, Comment=None, LangID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Annotation_Type, self).__init__(IX, Del,  **kwargs_)
        self.X = X
        self.X_nsprefix_ = None
        self.Y = Y
        self.Y_nsprefix_ = None
        self.ReviewerID = ReviewerID
        self.ReviewerID_nsprefix_ = None
        self.MarkerIndex = MarkerIndex
        self.MarkerIndex_nsprefix_ = None
        self.Date = Date
        self.Date_nsprefix_ = None
        self.Comment = Comment
        self.Comment_nsprefix_ = None
        self.LangID = LangID
        self.LangID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Annotation_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Annotation_Type.subclass:
            return Annotation_Type.subclass(*args_, **kwargs_)
        else:
            return Annotation_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def get_ReviewerID(self):
        return self.ReviewerID
    def set_ReviewerID(self, ReviewerID):
        self.ReviewerID = ReviewerID
    def get_MarkerIndex(self):
        return self.MarkerIndex
    def set_MarkerIndex(self, MarkerIndex):
        self.MarkerIndex = MarkerIndex
    def get_Date(self):
        return self.Date
    def set_Date(self, Date):
        self.Date = Date
    def get_Comment(self):
        return self.Comment
    def set_Comment(self, Comment):
        self.Comment = Comment
    def get_LangID(self):
        return self.LangID
    def set_LangID(self, LangID):
        self.LangID = LangID
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None or
            self.ReviewerID is not None or
            self.MarkerIndex is not None or
            self.Date is not None or
            self.Comment is not None or
            self.LangID is not None or
            super(Annotation_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Annotation_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Annotation_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Annotation_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Annotation_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Annotation_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Annotation_Type'):
        super(Annotation_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Annotation_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='Annotation_Type', fromsubclass_=False, pretty_print=True):
        super(Annotation_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            self.X.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        if self.Y is not None:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            self.Y.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
        if self.ReviewerID is not None:
            namespaceprefix_ = self.ReviewerID_nsprefix_ + ':' if (UseCapturedNS_ and self.ReviewerID_nsprefix_) else ''
            self.ReviewerID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReviewerID', pretty_print=pretty_print)
        if self.MarkerIndex is not None:
            namespaceprefix_ = self.MarkerIndex_nsprefix_ + ':' if (UseCapturedNS_ and self.MarkerIndex_nsprefix_) else ''
            self.MarkerIndex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MarkerIndex', pretty_print=pretty_print)
        if self.Date is not None:
            namespaceprefix_ = self.Date_nsprefix_ + ':' if (UseCapturedNS_ and self.Date_nsprefix_) else ''
            self.Date.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Date', pretty_print=pretty_print)
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            self.Comment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment', pretty_print=pretty_print)
        if self.LangID is not None:
            namespaceprefix_ = self.LangID_nsprefix_ + ':' if (UseCapturedNS_ and self.LangID_nsprefix_) else ''
            self.LangID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LangID', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Annotation_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X = obj_
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y = obj_
            obj_.original_tagname_ = 'Y'
        elif nodeName_ == 'ReviewerID':
            obj_ = ReviewerID_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReviewerID = obj_
            obj_.original_tagname_ = 'ReviewerID'
        elif nodeName_ == 'MarkerIndex':
            obj_ = MarkerIndex_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MarkerIndex = obj_
            obj_.original_tagname_ = 'MarkerIndex'
        elif nodeName_ == 'Date':
            obj_ = Date_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Date = obj_
            obj_.original_tagname_ = 'Date'
        elif nodeName_ == 'Comment':
            obj_ = Comment_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'LangID':
            obj_ = LangID_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LangID = obj_
            obj_.original_tagname_ = 'LangID'
        super(Annotation_Type, self).buildChildren(child_, node, nodeName_, True)
# end class Annotation_Type


class MarkerIndex_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MarkerIndex_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MarkerIndex_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MarkerIndex_Type.subclass:
            return MarkerIndex_Type.subclass(*args_, **kwargs_)
        else:
            return MarkerIndex_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(MarkerIndex_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MarkerIndex_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MarkerIndex_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MarkerIndex_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MarkerIndex_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MarkerIndex_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MarkerIndex_Type'):
        super(MarkerIndex_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MarkerIndex_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MarkerIndex_Type', fromsubclass_=False, pretty_print=True):
        super(MarkerIndex_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MarkerIndex_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class MarkerIndex_Type


class Date_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(Date_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Date_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Date_Type.subclass:
            return Date_Type.subclass(*args_, **kwargs_)
        else:
            return Date_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Date_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Date_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Date_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Date_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Date_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Date_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Date_Type'):
        super(Date_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Date_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Date_Type', fromsubclass_=False, pretty_print=True):
        super(Date_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Date_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Date_Type


class SmartTagDef_Type(NamedRow_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NamedRow_Type
    def __init__(self, Name=None, NameU=None, Del=None, ID=None, X=None, Y=None, TagName=None, XJustify=None, YJustify=None, DisplayMode=None, ButtonFace=None, Disabled=None, Description=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SmartTagDef_Type, self).__init__(Name, NameU, Del, ID,  **kwargs_)
        if X is None:
            self.X = []
        else:
            self.X = X
        self.X_nsprefix_ = None
        if Y is None:
            self.Y = []
        else:
            self.Y = Y
        self.Y_nsprefix_ = None
        if TagName is None:
            self.TagName = []
        else:
            self.TagName = TagName
        self.TagName_nsprefix_ = None
        if XJustify is None:
            self.XJustify = []
        else:
            self.XJustify = XJustify
        self.XJustify_nsprefix_ = None
        if YJustify is None:
            self.YJustify = []
        else:
            self.YJustify = YJustify
        self.YJustify_nsprefix_ = None
        if DisplayMode is None:
            self.DisplayMode = []
        else:
            self.DisplayMode = DisplayMode
        self.DisplayMode_nsprefix_ = None
        if ButtonFace is None:
            self.ButtonFace = []
        else:
            self.ButtonFace = ButtonFace
        self.ButtonFace_nsprefix_ = None
        if Disabled is None:
            self.Disabled = []
        else:
            self.Disabled = Disabled
        self.Disabled_nsprefix_ = None
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.Description_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SmartTagDef_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SmartTagDef_Type.subclass:
            return SmartTagDef_Type.subclass(*args_, **kwargs_)
        else:
            return SmartTagDef_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X(self):
        return self.X
    def set_X(self, X):
        self.X = X
    def add_X(self, value):
        self.X.append(value)
    def insert_X_at(self, index, value):
        self.X.insert(index, value)
    def replace_X_at(self, index, value):
        self.X[index] = value
    def get_Y(self):
        return self.Y
    def set_Y(self, Y):
        self.Y = Y
    def add_Y(self, value):
        self.Y.append(value)
    def insert_Y_at(self, index, value):
        self.Y.insert(index, value)
    def replace_Y_at(self, index, value):
        self.Y[index] = value
    def get_TagName(self):
        return self.TagName
    def set_TagName(self, TagName):
        self.TagName = TagName
    def add_TagName(self, value):
        self.TagName.append(value)
    def insert_TagName_at(self, index, value):
        self.TagName.insert(index, value)
    def replace_TagName_at(self, index, value):
        self.TagName[index] = value
    def get_XJustify(self):
        return self.XJustify
    def set_XJustify(self, XJustify):
        self.XJustify = XJustify
    def add_XJustify(self, value):
        self.XJustify.append(value)
    def insert_XJustify_at(self, index, value):
        self.XJustify.insert(index, value)
    def replace_XJustify_at(self, index, value):
        self.XJustify[index] = value
    def get_YJustify(self):
        return self.YJustify
    def set_YJustify(self, YJustify):
        self.YJustify = YJustify
    def add_YJustify(self, value):
        self.YJustify.append(value)
    def insert_YJustify_at(self, index, value):
        self.YJustify.insert(index, value)
    def replace_YJustify_at(self, index, value):
        self.YJustify[index] = value
    def get_DisplayMode(self):
        return self.DisplayMode
    def set_DisplayMode(self, DisplayMode):
        self.DisplayMode = DisplayMode
    def add_DisplayMode(self, value):
        self.DisplayMode.append(value)
    def insert_DisplayMode_at(self, index, value):
        self.DisplayMode.insert(index, value)
    def replace_DisplayMode_at(self, index, value):
        self.DisplayMode[index] = value
    def get_ButtonFace(self):
        return self.ButtonFace
    def set_ButtonFace(self, ButtonFace):
        self.ButtonFace = ButtonFace
    def add_ButtonFace(self, value):
        self.ButtonFace.append(value)
    def insert_ButtonFace_at(self, index, value):
        self.ButtonFace.insert(index, value)
    def replace_ButtonFace_at(self, index, value):
        self.ButtonFace[index] = value
    def get_Disabled(self):
        return self.Disabled
    def set_Disabled(self, Disabled):
        self.Disabled = Disabled
    def add_Disabled(self, value):
        self.Disabled.append(value)
    def insert_Disabled_at(self, index, value):
        self.Disabled.insert(index, value)
    def replace_Disabled_at(self, index, value):
        self.Disabled[index] = value
    def get_Description(self):
        return self.Description
    def set_Description(self, Description):
        self.Description = Description
    def add_Description(self, value):
        self.Description.append(value)
    def insert_Description_at(self, index, value):
        self.Description.insert(index, value)
    def replace_Description_at(self, index, value):
        self.Description[index] = value
    def hasContent_(self):
        if (
            self.X or
            self.Y or
            self.TagName or
            self.XJustify or
            self.YJustify or
            self.DisplayMode or
            self.ButtonFace or
            self.Disabled or
            self.Description or
            super(SmartTagDef_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='SmartTagDef_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SmartTagDef_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SmartTagDef_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SmartTagDef_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SmartTagDef_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SmartTagDef_Type'):
        super(SmartTagDef_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SmartTagDef_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='SmartTagDef_Type', fromsubclass_=False, pretty_print=True):
        super(SmartTagDef_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for X_ in self.X:
            namespaceprefix_ = self.X_nsprefix_ + ':' if (UseCapturedNS_ and self.X_nsprefix_) else ''
            X_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X', pretty_print=pretty_print)
        for Y_ in self.Y:
            namespaceprefix_ = self.Y_nsprefix_ + ':' if (UseCapturedNS_ and self.Y_nsprefix_) else ''
            Y_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Y', pretty_print=pretty_print)
        for TagName_ in self.TagName:
            namespaceprefix_ = self.TagName_nsprefix_ + ':' if (UseCapturedNS_ and self.TagName_nsprefix_) else ''
            TagName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TagName', pretty_print=pretty_print)
        for XJustify_ in self.XJustify:
            namespaceprefix_ = self.XJustify_nsprefix_ + ':' if (UseCapturedNS_ and self.XJustify_nsprefix_) else ''
            XJustify_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XJustify', pretty_print=pretty_print)
        for YJustify_ in self.YJustify:
            namespaceprefix_ = self.YJustify_nsprefix_ + ':' if (UseCapturedNS_ and self.YJustify_nsprefix_) else ''
            YJustify_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='YJustify', pretty_print=pretty_print)
        for DisplayMode_ in self.DisplayMode:
            namespaceprefix_ = self.DisplayMode_nsprefix_ + ':' if (UseCapturedNS_ and self.DisplayMode_nsprefix_) else ''
            DisplayMode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DisplayMode', pretty_print=pretty_print)
        for ButtonFace_ in self.ButtonFace:
            namespaceprefix_ = self.ButtonFace_nsprefix_ + ':' if (UseCapturedNS_ and self.ButtonFace_nsprefix_) else ''
            ButtonFace_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ButtonFace', pretty_print=pretty_print)
        for Disabled_ in self.Disabled:
            namespaceprefix_ = self.Disabled_nsprefix_ + ':' if (UseCapturedNS_ and self.Disabled_nsprefix_) else ''
            Disabled_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Disabled', pretty_print=pretty_print)
        for Description_ in self.Description:
            namespaceprefix_ = self.Description_nsprefix_ + ':' if (UseCapturedNS_ and self.Description_nsprefix_) else ''
            Description_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Description', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SmartTagDef_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X':
            obj_ = X_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X.append(obj_)
            obj_.original_tagname_ = 'X'
        elif nodeName_ == 'Y':
            obj_ = Y_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Y.append(obj_)
            obj_.original_tagname_ = 'Y'
        elif nodeName_ == 'TagName':
            obj_ = TagName_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TagName.append(obj_)
            obj_.original_tagname_ = 'TagName'
        elif nodeName_ == 'XJustify':
            obj_ = XJustify_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XJustify.append(obj_)
            obj_.original_tagname_ = 'XJustify'
        elif nodeName_ == 'YJustify':
            obj_ = YJustify_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.YJustify.append(obj_)
            obj_.original_tagname_ = 'YJustify'
        elif nodeName_ == 'DisplayMode':
            obj_ = DisplayMode_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DisplayMode.append(obj_)
            obj_.original_tagname_ = 'DisplayMode'
        elif nodeName_ == 'ButtonFace':
            obj_ = ButtonFace_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ButtonFace.append(obj_)
            obj_.original_tagname_ = 'ButtonFace'
        elif nodeName_ == 'Disabled':
            obj_ = Disabled_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Disabled.append(obj_)
            obj_.original_tagname_ = 'Disabled'
        elif nodeName_ == 'Description':
            obj_ = Description_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        super(SmartTagDef_Type, self).buildChildren(child_, node, nodeName_, True)
# end class SmartTagDef_Type


class XJustify_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(XJustify_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XJustify_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XJustify_Type.subclass:
            return XJustify_Type.subclass(*args_, **kwargs_)
        else:
            return XJustify_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(XJustify_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XJustify_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XJustify_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'XJustify_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XJustify_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XJustify_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XJustify_Type'):
        super(XJustify_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XJustify_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XJustify_Type', fromsubclass_=False, pretty_print=True):
        super(XJustify_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(XJustify_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class XJustify_Type


class YJustify_Type(Cell_Type):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Cell_Type
    def __init__(self, Unit=None, F=None, Err=None, V=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(YJustify_Type, self).__init__(Unit, F, Err, V, valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, YJustify_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if YJustify_Type.subclass:
            return YJustify_Type.subclass(*args_, **kwargs_)
        else:
            return YJustify_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(YJustify_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YJustify_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('YJustify_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'YJustify_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YJustify_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='YJustify_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='YJustify_Type'):
        super(YJustify_Type, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YJustify_Type')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='YJustify_Type', fromsubclass_=False, pretty_print=True):
        super(YJustify_Type, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(YJustify_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class YJustify_Type


class DataConnections_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NextID=None, DataConnection=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NextID = _cast(int, NextID)
        self.NextID_nsprefix_ = None
        if DataConnection is None:
            self.DataConnection = []
        else:
            self.DataConnection = DataConnection
        self.DataConnection_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataConnections_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataConnections_Type.subclass:
            return DataConnections_Type.subclass(*args_, **kwargs_)
        else:
            return DataConnections_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DataConnection(self):
        return self.DataConnection
    def set_DataConnection(self, DataConnection):
        self.DataConnection = DataConnection
    def add_DataConnection(self, value):
        self.DataConnection.append(value)
    def insert_DataConnection_at(self, index, value):
        self.DataConnection.insert(index, value)
    def replace_DataConnection_at(self, index, value):
        self.DataConnection[index] = value
    def get_NextID(self):
        return self.NextID
    def set_NextID(self, NextID):
        self.NextID = NextID
    def hasContent_(self):
        if (
            self.DataConnection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='DataConnections_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataConnections_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DataConnections_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataConnections_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataConnections_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataConnections_Type'):
        if self.NextID is not None and 'NextID' not in already_processed:
            already_processed.add('NextID')
            outfile.write(' NextID="%s"' % self.gds_format_integer(self.NextID, input_name='NextID'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='DataConnections_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DataConnection_ in self.DataConnection:
            namespaceprefix_ = self.DataConnection_nsprefix_ + ':' if (UseCapturedNS_ and self.DataConnection_nsprefix_) else ''
            DataConnection_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DataConnection', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NextID', node)
        if value is not None and 'NextID' not in already_processed:
            already_processed.add('NextID')
            self.NextID = self.gds_parse_integer(value, node, 'NextID')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DataConnection':
            obj_ = DataConnection_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataConnection.append(obj_)
            obj_.original_tagname_ = 'DataConnection'
# end class DataConnections_Type


class DataConnection_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, FileName=None, ConnectionString=None, Command=None, FriendlyName=None, Timeout=None, AlwaysUseConnectionFile=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(int, ID)
        self.ID_nsprefix_ = None
        self.FileName = _cast(None, FileName)
        self.FileName_nsprefix_ = None
        self.ConnectionString = _cast(None, ConnectionString)
        self.ConnectionString_nsprefix_ = None
        self.Command = _cast(None, Command)
        self.Command_nsprefix_ = None
        self.FriendlyName = _cast(None, FriendlyName)
        self.FriendlyName_nsprefix_ = None
        self.Timeout = _cast(int, Timeout)
        self.Timeout_nsprefix_ = None
        self.AlwaysUseConnectionFile = _cast(int, AlwaysUseConnectionFile)
        self.AlwaysUseConnectionFile_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataConnection_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataConnection_Type.subclass:
            return DataConnection_Type.subclass(*args_, **kwargs_)
        else:
            return DataConnection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_FileName(self):
        return self.FileName
    def set_FileName(self, FileName):
        self.FileName = FileName
    def get_ConnectionString(self):
        return self.ConnectionString
    def set_ConnectionString(self, ConnectionString):
        self.ConnectionString = ConnectionString
    def get_Command(self):
        return self.Command
    def set_Command(self, Command):
        self.Command = Command
    def get_FriendlyName(self):
        return self.FriendlyName
    def set_FriendlyName(self, FriendlyName):
        self.FriendlyName = FriendlyName
    def get_Timeout(self):
        return self.Timeout
    def set_Timeout(self, Timeout):
        self.Timeout = Timeout
    def get_AlwaysUseConnectionFile(self):
        return self.AlwaysUseConnectionFile
    def set_AlwaysUseConnectionFile(self, AlwaysUseConnectionFile):
        self.AlwaysUseConnectionFile = AlwaysUseConnectionFile
    def validate_ISOBoolean(self, value):
        # Validate type ISOBoolean, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [0, 1]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ISOBoolean' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DataConnection_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataConnection_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DataConnection_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataConnection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataConnection_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataConnection_Type'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.FileName is not None and 'FileName' not in already_processed:
            already_processed.add('FileName')
            outfile.write(' FileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.FileName), input_name='FileName')), ))
        if self.ConnectionString is not None and 'ConnectionString' not in already_processed:
            already_processed.add('ConnectionString')
            outfile.write(' ConnectionString=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ConnectionString), input_name='ConnectionString')), ))
        if self.Command is not None and 'Command' not in already_processed:
            already_processed.add('Command')
            outfile.write(' Command=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Command), input_name='Command')), ))
        if self.FriendlyName is not None and 'FriendlyName' not in already_processed:
            already_processed.add('FriendlyName')
            outfile.write(' FriendlyName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.FriendlyName), input_name='FriendlyName')), ))
        if self.Timeout is not None and 'Timeout' not in already_processed:
            already_processed.add('Timeout')
            outfile.write(' Timeout="%s"' % self.gds_format_integer(self.Timeout, input_name='Timeout'))
        if self.AlwaysUseConnectionFile is not None and 'AlwaysUseConnectionFile' not in already_processed:
            already_processed.add('AlwaysUseConnectionFile')
            outfile.write(' AlwaysUseConnectionFile="%s"' % self.gds_format_integer(self.AlwaysUseConnectionFile, input_name='AlwaysUseConnectionFile'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DataConnection_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = self.gds_parse_integer(value, node, 'ID')
        value = find_attr_value_('FileName', node)
        if value is not None and 'FileName' not in already_processed:
            already_processed.add('FileName')
            self.FileName = value
        value = find_attr_value_('ConnectionString', node)
        if value is not None and 'ConnectionString' not in already_processed:
            already_processed.add('ConnectionString')
            self.ConnectionString = value
        value = find_attr_value_('Command', node)
        if value is not None and 'Command' not in already_processed:
            already_processed.add('Command')
            self.Command = value
        value = find_attr_value_('FriendlyName', node)
        if value is not None and 'FriendlyName' not in already_processed:
            already_processed.add('FriendlyName')
            self.FriendlyName = value
        value = find_attr_value_('Timeout', node)
        if value is not None and 'Timeout' not in already_processed:
            already_processed.add('Timeout')
            self.Timeout = self.gds_parse_integer(value, node, 'Timeout')
        value = find_attr_value_('AlwaysUseConnectionFile', node)
        if value is not None and 'AlwaysUseConnectionFile' not in already_processed:
            already_processed.add('AlwaysUseConnectionFile')
            self.AlwaysUseConnectionFile = self.gds_parse_integer(value, node, 'AlwaysUseConnectionFile')
            self.validate_ISOBoolean(self.AlwaysUseConnectionFile)    # validate type ISOBoolean
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DataConnection_Type


class DataRecordSets_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NextID=None, ActiveRecordsetID=None, DataWindowOrder=None, DataRecordSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NextID = _cast(int, NextID)
        self.NextID_nsprefix_ = None
        self.ActiveRecordsetID = _cast(int, ActiveRecordsetID)
        self.ActiveRecordsetID_nsprefix_ = None
        self.DataWindowOrder = _cast(None, DataWindowOrder)
        self.DataWindowOrder_nsprefix_ = None
        if DataRecordSet is None:
            self.DataRecordSet = []
        else:
            self.DataRecordSet = DataRecordSet
        self.DataRecordSet_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataRecordSets_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataRecordSets_Type.subclass:
            return DataRecordSets_Type.subclass(*args_, **kwargs_)
        else:
            return DataRecordSets_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DataRecordSet(self):
        return self.DataRecordSet
    def set_DataRecordSet(self, DataRecordSet):
        self.DataRecordSet = DataRecordSet
    def add_DataRecordSet(self, value):
        self.DataRecordSet.append(value)
    def insert_DataRecordSet_at(self, index, value):
        self.DataRecordSet.insert(index, value)
    def replace_DataRecordSet_at(self, index, value):
        self.DataRecordSet[index] = value
    def get_NextID(self):
        return self.NextID
    def set_NextID(self, NextID):
        self.NextID = NextID
    def get_ActiveRecordsetID(self):
        return self.ActiveRecordsetID
    def set_ActiveRecordsetID(self, ActiveRecordsetID):
        self.ActiveRecordsetID = ActiveRecordsetID
    def get_DataWindowOrder(self):
        return self.DataWindowOrder
    def set_DataWindowOrder(self, DataWindowOrder):
        self.DataWindowOrder = DataWindowOrder
    def hasContent_(self):
        if (
            self.DataRecordSet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='DataRecordSets_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataRecordSets_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DataRecordSets_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataRecordSets_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataRecordSets_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataRecordSets_Type'):
        if self.NextID is not None and 'NextID' not in already_processed:
            already_processed.add('NextID')
            outfile.write(' NextID="%s"' % self.gds_format_integer(self.NextID, input_name='NextID'))
        if self.ActiveRecordsetID is not None and 'ActiveRecordsetID' not in already_processed:
            already_processed.add('ActiveRecordsetID')
            outfile.write(' ActiveRecordsetID="%s"' % self.gds_format_integer(self.ActiveRecordsetID, input_name='ActiveRecordsetID'))
        if self.DataWindowOrder is not None and 'DataWindowOrder' not in already_processed:
            already_processed.add('DataWindowOrder')
            outfile.write(' DataWindowOrder=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DataWindowOrder), input_name='DataWindowOrder')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='DataRecordSets_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DataRecordSet_ in self.DataRecordSet:
            namespaceprefix_ = self.DataRecordSet_nsprefix_ + ':' if (UseCapturedNS_ and self.DataRecordSet_nsprefix_) else ''
            DataRecordSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DataRecordSet', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NextID', node)
        if value is not None and 'NextID' not in already_processed:
            already_processed.add('NextID')
            self.NextID = self.gds_parse_integer(value, node, 'NextID')
        value = find_attr_value_('ActiveRecordsetID', node)
        if value is not None and 'ActiveRecordsetID' not in already_processed:
            already_processed.add('ActiveRecordsetID')
            self.ActiveRecordsetID = self.gds_parse_integer(value, node, 'ActiveRecordsetID')
        value = find_attr_value_('DataWindowOrder', node)
        if value is not None and 'DataWindowOrder' not in already_processed:
            already_processed.add('DataWindowOrder')
            self.DataWindowOrder = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DataRecordSet':
            obj_ = DataRecordSet_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataRecordSet.append(obj_)
            obj_.original_tagname_ = 'DataRecordSet'
# end class DataRecordSets_Type


class DataRecordSet_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ID=None, ConnectionID=None, Command=None, Options=None, TimeRefreshed=None, NextRowID=None, Name=None, RowOrder=None, RefreshOverwriteAll=None, RefreshNoReconciliationUI=None, RefreshInterval=None, ReplaceLinks=None, Checksum=None, ADOData=None, DataColumns=None, PrimaryKey=None, RowMap=None, RefreshConflict=None, AutoLinkComparison=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = _cast(int, ID)
        self.ID_nsprefix_ = None
        self.ConnectionID = _cast(int, ConnectionID)
        self.ConnectionID_nsprefix_ = None
        self.Command = _cast(None, Command)
        self.Command_nsprefix_ = None
        self.Options = _cast(int, Options)
        self.Options_nsprefix_ = None
        if isinstance(TimeRefreshed, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(TimeRefreshed, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = TimeRefreshed
        self.TimeRefreshed = initvalue_
        self.NextRowID = _cast(int, NextRowID)
        self.NextRowID_nsprefix_ = None
        self.Name = _cast(None, Name)
        self.Name_nsprefix_ = None
        self.RowOrder = _cast(int, RowOrder)
        self.RowOrder_nsprefix_ = None
        self.RefreshOverwriteAll = _cast(int, RefreshOverwriteAll)
        self.RefreshOverwriteAll_nsprefix_ = None
        self.RefreshNoReconciliationUI = _cast(int, RefreshNoReconciliationUI)
        self.RefreshNoReconciliationUI_nsprefix_ = None
        self.RefreshInterval = _cast(int, RefreshInterval)
        self.RefreshInterval_nsprefix_ = None
        self.ReplaceLinks = _cast(int, ReplaceLinks)
        self.ReplaceLinks_nsprefix_ = None
        self.Checksum = _cast(int, Checksum)
        self.Checksum_nsprefix_ = None
        self.ADOData = ADOData
        self.ADOData_nsprefix_ = None
        self.DataColumns = DataColumns
        self.DataColumns_nsprefix_ = None
        if PrimaryKey is None:
            self.PrimaryKey = []
        else:
            self.PrimaryKey = PrimaryKey
        self.PrimaryKey_nsprefix_ = None
        if RowMap is None:
            self.RowMap = []
        else:
            self.RowMap = RowMap
        self.RowMap_nsprefix_ = None
        if RefreshConflict is None:
            self.RefreshConflict = []
        else:
            self.RefreshConflict = RefreshConflict
        self.RefreshConflict_nsprefix_ = None
        if AutoLinkComparison is None:
            self.AutoLinkComparison = []
        else:
            self.AutoLinkComparison = AutoLinkComparison
        self.AutoLinkComparison_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataRecordSet_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataRecordSet_Type.subclass:
            return DataRecordSet_Type.subclass(*args_, **kwargs_)
        else:
            return DataRecordSet_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ADOData(self):
        return self.ADOData
    def set_ADOData(self, ADOData):
        self.ADOData = ADOData
    def get_DataColumns(self):
        return self.DataColumns
    def set_DataColumns(self, DataColumns):
        self.DataColumns = DataColumns
    def get_PrimaryKey(self):
        return self.PrimaryKey
    def set_PrimaryKey(self, PrimaryKey):
        self.PrimaryKey = PrimaryKey
    def add_PrimaryKey(self, value):
        self.PrimaryKey.append(value)
    def insert_PrimaryKey_at(self, index, value):
        self.PrimaryKey.insert(index, value)
    def replace_PrimaryKey_at(self, index, value):
        self.PrimaryKey[index] = value
    def get_RowMap(self):
        return self.RowMap
    def set_RowMap(self, RowMap):
        self.RowMap = RowMap
    def add_RowMap(self, value):
        self.RowMap.append(value)
    def insert_RowMap_at(self, index, value):
        self.RowMap.insert(index, value)
    def replace_RowMap_at(self, index, value):
        self.RowMap[index] = value
    def get_RefreshConflict(self):
        return self.RefreshConflict
    def set_RefreshConflict(self, RefreshConflict):
        self.RefreshConflict = RefreshConflict
    def add_RefreshConflict(self, value):
        self.RefreshConflict.append(value)
    def insert_RefreshConflict_at(self, index, value):
        self.RefreshConflict.insert(index, value)
    def replace_RefreshConflict_at(self, index, value):
        self.RefreshConflict[index] = value
    def get_AutoLinkComparison(self):
        return self.AutoLinkComparison
    def set_AutoLinkComparison(self, AutoLinkComparison):
        self.AutoLinkComparison = AutoLinkComparison
    def add_AutoLinkComparison(self, value):
        self.AutoLinkComparison.append(value)
    def insert_AutoLinkComparison_at(self, index, value):
        self.AutoLinkComparison.insert(index, value)
    def replace_AutoLinkComparison_at(self, index, value):
        self.AutoLinkComparison[index] = value
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_ConnectionID(self):
        return self.ConnectionID
    def set_ConnectionID(self, ConnectionID):
        self.ConnectionID = ConnectionID
    def get_Command(self):
        return self.Command
    def set_Command(self, Command):
        self.Command = Command
    def get_Options(self):
        return self.Options
    def set_Options(self, Options):
        self.Options = Options
    def get_TimeRefreshed(self):
        return self.TimeRefreshed
    def set_TimeRefreshed(self, TimeRefreshed):
        self.TimeRefreshed = TimeRefreshed
    def get_NextRowID(self):
        return self.NextRowID
    def set_NextRowID(self, NextRowID):
        self.NextRowID = NextRowID
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_RowOrder(self):
        return self.RowOrder
    def set_RowOrder(self, RowOrder):
        self.RowOrder = RowOrder
    def get_RefreshOverwriteAll(self):
        return self.RefreshOverwriteAll
    def set_RefreshOverwriteAll(self, RefreshOverwriteAll):
        self.RefreshOverwriteAll = RefreshOverwriteAll
    def get_RefreshNoReconciliationUI(self):
        return self.RefreshNoReconciliationUI
    def set_RefreshNoReconciliationUI(self, RefreshNoReconciliationUI):
        self.RefreshNoReconciliationUI = RefreshNoReconciliationUI
    def get_RefreshInterval(self):
        return self.RefreshInterval
    def set_RefreshInterval(self, RefreshInterval):
        self.RefreshInterval = RefreshInterval
    def get_ReplaceLinks(self):
        return self.ReplaceLinks
    def set_ReplaceLinks(self, ReplaceLinks):
        self.ReplaceLinks = ReplaceLinks
    def get_Checksum(self):
        return self.Checksum
    def set_Checksum(self, Checksum):
        self.Checksum = Checksum
    def validate_ISOBoolean(self, value):
        # Validate type ISOBoolean, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [0, 1]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ISOBoolean' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.ADOData is not None or
            self.DataColumns is not None or
            self.PrimaryKey or
            self.RowMap or
            self.RefreshConflict or
            self.AutoLinkComparison
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='DataRecordSet_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataRecordSet_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DataRecordSet_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataRecordSet_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataRecordSet_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataRecordSet_Type'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.ConnectionID is not None and 'ConnectionID' not in already_processed:
            already_processed.add('ConnectionID')
            outfile.write(' ConnectionID="%s"' % self.gds_format_integer(self.ConnectionID, input_name='ConnectionID'))
        if self.Command is not None and 'Command' not in already_processed:
            already_processed.add('Command')
            outfile.write(' Command=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Command), input_name='Command')), ))
        if self.Options is not None and 'Options' not in already_processed:
            already_processed.add('Options')
            outfile.write(' Options="%s"' % self.gds_format_integer(self.Options, input_name='Options'))
        if self.TimeRefreshed is not None and 'TimeRefreshed' not in already_processed:
            already_processed.add('TimeRefreshed')
            outfile.write(' TimeRefreshed="%s"' % self.gds_format_datetime(self.TimeRefreshed, input_name='TimeRefreshed'))
        if self.NextRowID is not None and 'NextRowID' not in already_processed:
            already_processed.add('NextRowID')
            outfile.write(' NextRowID="%s"' % self.gds_format_integer(self.NextRowID, input_name='NextRowID'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Name), input_name='Name')), ))
        if self.RowOrder is not None and 'RowOrder' not in already_processed:
            already_processed.add('RowOrder')
            outfile.write(' RowOrder="%s"' % self.gds_format_integer(self.RowOrder, input_name='RowOrder'))
        if self.RefreshOverwriteAll is not None and 'RefreshOverwriteAll' not in already_processed:
            already_processed.add('RefreshOverwriteAll')
            outfile.write(' RefreshOverwriteAll="%s"' % self.gds_format_integer(self.RefreshOverwriteAll, input_name='RefreshOverwriteAll'))
        if self.RefreshNoReconciliationUI is not None and 'RefreshNoReconciliationUI' not in already_processed:
            already_processed.add('RefreshNoReconciliationUI')
            outfile.write(' RefreshNoReconciliationUI="%s"' % self.gds_format_integer(self.RefreshNoReconciliationUI, input_name='RefreshNoReconciliationUI'))
        if self.RefreshInterval is not None and 'RefreshInterval' not in already_processed:
            already_processed.add('RefreshInterval')
            outfile.write(' RefreshInterval="%s"' % self.gds_format_integer(self.RefreshInterval, input_name='RefreshInterval'))
        if self.ReplaceLinks is not None and 'ReplaceLinks' not in already_processed:
            already_processed.add('ReplaceLinks')
            outfile.write(' ReplaceLinks="%s"' % self.gds_format_integer(self.ReplaceLinks, input_name='ReplaceLinks'))
        if self.Checksum is not None and 'Checksum' not in already_processed:
            already_processed.add('Checksum')
            outfile.write(' Checksum="%s"' % self.gds_format_integer(self.Checksum, input_name='Checksum'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='DataRecordSet_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ADOData is not None:
            namespaceprefix_ = self.ADOData_nsprefix_ + ':' if (UseCapturedNS_ and self.ADOData_nsprefix_) else ''
            self.ADOData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ADOData', pretty_print=pretty_print)
        if self.DataColumns is not None:
            namespaceprefix_ = self.DataColumns_nsprefix_ + ':' if (UseCapturedNS_ and self.DataColumns_nsprefix_) else ''
            self.DataColumns.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DataColumns', pretty_print=pretty_print)
        for PrimaryKey_ in self.PrimaryKey:
            namespaceprefix_ = self.PrimaryKey_nsprefix_ + ':' if (UseCapturedNS_ and self.PrimaryKey_nsprefix_) else ''
            PrimaryKey_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PrimaryKey', pretty_print=pretty_print)
        for RowMap_ in self.RowMap:
            namespaceprefix_ = self.RowMap_nsprefix_ + ':' if (UseCapturedNS_ and self.RowMap_nsprefix_) else ''
            RowMap_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RowMap', pretty_print=pretty_print)
        for RefreshConflict_ in self.RefreshConflict:
            namespaceprefix_ = self.RefreshConflict_nsprefix_ + ':' if (UseCapturedNS_ and self.RefreshConflict_nsprefix_) else ''
            RefreshConflict_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RefreshConflict', pretty_print=pretty_print)
        for AutoLinkComparison_ in self.AutoLinkComparison:
            namespaceprefix_ = self.AutoLinkComparison_nsprefix_ + ':' if (UseCapturedNS_ and self.AutoLinkComparison_nsprefix_) else ''
            AutoLinkComparison_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AutoLinkComparison', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = self.gds_parse_integer(value, node, 'ID')
        value = find_attr_value_('ConnectionID', node)
        if value is not None and 'ConnectionID' not in already_processed:
            already_processed.add('ConnectionID')
            self.ConnectionID = self.gds_parse_integer(value, node, 'ConnectionID')
        value = find_attr_value_('Command', node)
        if value is not None and 'Command' not in already_processed:
            already_processed.add('Command')
            self.Command = value
        value = find_attr_value_('Options', node)
        if value is not None and 'Options' not in already_processed:
            already_processed.add('Options')
            self.Options = self.gds_parse_integer(value, node, 'Options')
        value = find_attr_value_('TimeRefreshed', node)
        if value is not None and 'TimeRefreshed' not in already_processed:
            already_processed.add('TimeRefreshed')
            try:
                self.TimeRefreshed = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (TimeRefreshed): %s' % exp)
        value = find_attr_value_('NextRowID', node)
        if value is not None and 'NextRowID' not in already_processed:
            already_processed.add('NextRowID')
            self.NextRowID = self.gds_parse_integer(value, node, 'NextRowID')
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('RowOrder', node)
        if value is not None and 'RowOrder' not in already_processed:
            already_processed.add('RowOrder')
            self.RowOrder = self.gds_parse_integer(value, node, 'RowOrder')
            self.validate_ISOBoolean(self.RowOrder)    # validate type ISOBoolean
        value = find_attr_value_('RefreshOverwriteAll', node)
        if value is not None and 'RefreshOverwriteAll' not in already_processed:
            already_processed.add('RefreshOverwriteAll')
            self.RefreshOverwriteAll = self.gds_parse_integer(value, node, 'RefreshOverwriteAll')
            self.validate_ISOBoolean(self.RefreshOverwriteAll)    # validate type ISOBoolean
        value = find_attr_value_('RefreshNoReconciliationUI', node)
        if value is not None and 'RefreshNoReconciliationUI' not in already_processed:
            already_processed.add('RefreshNoReconciliationUI')
            self.RefreshNoReconciliationUI = self.gds_parse_integer(value, node, 'RefreshNoReconciliationUI')
            self.validate_ISOBoolean(self.RefreshNoReconciliationUI)    # validate type ISOBoolean
        value = find_attr_value_('RefreshInterval', node)
        if value is not None and 'RefreshInterval' not in already_processed:
            already_processed.add('RefreshInterval')
            self.RefreshInterval = self.gds_parse_integer(value, node, 'RefreshInterval')
        value = find_attr_value_('ReplaceLinks', node)
        if value is not None and 'ReplaceLinks' not in already_processed:
            already_processed.add('ReplaceLinks')
            self.ReplaceLinks = self.gds_parse_integer(value, node, 'ReplaceLinks')
        value = find_attr_value_('Checksum', node)
        if value is not None and 'Checksum' not in already_processed:
            already_processed.add('Checksum')
            self.Checksum = self.gds_parse_integer(value, node, 'Checksum')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ADOData':
            obj_ = ADOData_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ADOData = obj_
            obj_.original_tagname_ = 'ADOData'
        elif nodeName_ == 'DataColumns':
            obj_ = DataColumns_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataColumns = obj_
            obj_.original_tagname_ = 'DataColumns'
        elif nodeName_ == 'PrimaryKey':
            obj_ = PrimaryKey_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrimaryKey.append(obj_)
            obj_.original_tagname_ = 'PrimaryKey'
        elif nodeName_ == 'RowMap':
            obj_ = RowMap_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RowMap.append(obj_)
            obj_.original_tagname_ = 'RowMap'
        elif nodeName_ == 'RefreshConflict':
            obj_ = RefreshConflict_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RefreshConflict.append(obj_)
            obj_.original_tagname_ = 'RefreshConflict'
        elif nodeName_ == 'AutoLinkComparison':
            obj_ = AutoLinkComparison_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AutoLinkComparison.append(obj_)
            obj_.original_tagname_ = 'AutoLinkComparison'
# end class DataRecordSet_Type


class ADOData_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADOData_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADOData_Type.subclass:
            return ADOData_Type.subclass(*args_, **kwargs_)
        else:
            return ADOData_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='ADOData_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ADOData_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ADOData_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ADOData_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ADOData_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ADOData_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='ADOData_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'ADOData_Type')
        self.set_anytypeobjs_(content_)
# end class ADOData_Type


class DataColumns_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SortColumn=None, SortAsc=None, DataColumn=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.SortColumn = _cast(None, SortColumn)
        self.SortColumn_nsprefix_ = None
        self.SortAsc = _cast(int, SortAsc)
        self.SortAsc_nsprefix_ = None
        if DataColumn is None:
            self.DataColumn = []
        else:
            self.DataColumn = DataColumn
        self.DataColumn_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataColumns_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataColumns_Type.subclass:
            return DataColumns_Type.subclass(*args_, **kwargs_)
        else:
            return DataColumns_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DataColumn(self):
        return self.DataColumn
    def set_DataColumn(self, DataColumn):
        self.DataColumn = DataColumn
    def add_DataColumn(self, value):
        self.DataColumn.append(value)
    def insert_DataColumn_at(self, index, value):
        self.DataColumn.insert(index, value)
    def replace_DataColumn_at(self, index, value):
        self.DataColumn[index] = value
    def get_SortColumn(self):
        return self.SortColumn
    def set_SortColumn(self, SortColumn):
        self.SortColumn = SortColumn
    def get_SortAsc(self):
        return self.SortAsc
    def set_SortAsc(self, SortAsc):
        self.SortAsc = SortAsc
    def validate_ISOBoolean(self, value):
        # Validate type ISOBoolean, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [0, 1]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ISOBoolean' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.DataColumn
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='DataColumns_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataColumns_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DataColumns_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataColumns_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataColumns_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataColumns_Type'):
        if self.SortColumn is not None and 'SortColumn' not in already_processed:
            already_processed.add('SortColumn')
            outfile.write(' SortColumn=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.SortColumn), input_name='SortColumn')), ))
        if self.SortAsc is not None and 'SortAsc' not in already_processed:
            already_processed.add('SortAsc')
            outfile.write(' SortAsc="%s"' % self.gds_format_integer(self.SortAsc, input_name='SortAsc'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/visio/2006/extension" ', name_='DataColumns_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DataColumn_ in self.DataColumn:
            namespaceprefix_ = self.DataColumn_nsprefix_ + ':' if (UseCapturedNS_ and self.DataColumn_nsprefix_) else ''
            DataColumn_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DataColumn', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SortColumn', node)
        if value is not None and 'SortColumn' not in already_processed:
            already_processed.add('SortColumn')
            self.SortColumn = value
        value = find_attr_value_('SortAsc', node)
        if value is not None and 'SortAsc' not in already_processed:
            already_processed.add('SortAsc')
            self.SortAsc = self.gds_parse_integer(value, node, 'SortAsc')
            self.validate_ISOBoolean(self.SortAsc)    # validate type ISOBoolean
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DataColumn':
            obj_ = DataColumn_Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataColumn.append(obj_)
            obj_.original_tagname_ = 'DataColumn'
# end class DataColumns_Type


class PrimaryKey_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrimaryKey_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrimaryKey_Type.subclass:
            return PrimaryKey_Type.subclass(*args_, **kwargs_)
        else:
            return PrimaryKey_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrimaryKey_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PrimaryKey_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PrimaryKey_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrimaryKey_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PrimaryKey_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PrimaryKey_Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrimaryKey_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PrimaryKey_Type


class RowMap_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, RowID=None, PageID=None, ShapeID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.RowID = _cast(int, RowID)
        self.RowID_nsprefix_ = None
        self.PageID = _cast(int, PageID)
        self.PageID_nsprefix_ = None
        self.ShapeID = _cast(int, ShapeID)
        self.ShapeID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RowMap_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RowMap_Type.subclass:
            return RowMap_Type.subclass(*args_, **kwargs_)
        else:
            return RowMap_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RowID(self):
        return self.RowID
    def set_RowID(self, RowID):
        self.RowID = RowID
    def get_PageID(self):
        return self.PageID
    def set_PageID(self, PageID):
        self.PageID = PageID
    def get_ShapeID(self):
        return self.ShapeID
    def set_ShapeID(self, ShapeID):
        self.ShapeID = ShapeID
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RowMap_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RowMap_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RowMap_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RowMap_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RowMap_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RowMap_Type'):
        if self.RowID is not None and 'RowID' not in already_processed:
            already_processed.add('RowID')
            outfile.write(' RowID="%s"' % self.gds_format_integer(self.RowID, input_name='RowID'))
        if self.PageID is not None and 'PageID' not in already_processed:
            already_processed.add('PageID')
            outfile.write(' PageID="%s"' % self.gds_format_integer(self.PageID, input_name='PageID'))
        if self.ShapeID is not None and 'ShapeID' not in already_processed:
            already_processed.add('ShapeID')
            outfile.write(' ShapeID="%s"' % self.gds_format_integer(self.ShapeID, input_name='ShapeID'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RowMap_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('RowID', node)
        if value is not None and 'RowID' not in already_processed:
            already_processed.add('RowID')
            self.RowID = self.gds_parse_integer(value, node, 'RowID')
        value = find_attr_value_('PageID', node)
        if value is not None and 'PageID' not in already_processed:
            already_processed.add('PageID')
            self.PageID = self.gds_parse_integer(value, node, 'PageID')
        value = find_attr_value_('ShapeID', node)
        if value is not None and 'ShapeID' not in already_processed:
            already_processed.add('ShapeID')
            self.ShapeID = self.gds_parse_integer(value, node, 'ShapeID')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RowMap_Type


class RefreshConflict_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, RowID=None, ShapeID=None, PageID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.RowID = _cast(int, RowID)
        self.RowID_nsprefix_ = None
        self.ShapeID = _cast(int, ShapeID)
        self.ShapeID_nsprefix_ = None
        self.PageID = _cast(int, PageID)
        self.PageID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RefreshConflict_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RefreshConflict_Type.subclass:
            return RefreshConflict_Type.subclass(*args_, **kwargs_)
        else:
            return RefreshConflict_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RowID(self):
        return self.RowID
    def set_RowID(self, RowID):
        self.RowID = RowID
    def get_ShapeID(self):
        return self.ShapeID
    def set_ShapeID(self, ShapeID):
        self.ShapeID = ShapeID
    def get_PageID(self):
        return self.PageID
    def set_PageID(self, PageID):
        self.PageID = PageID
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RefreshConflict_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RefreshConflict_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RefreshConflict_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RefreshConflict_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RefreshConflict_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RefreshConflict_Type'):
        if self.RowID is not None and 'RowID' not in already_processed:
            already_processed.add('RowID')
            outfile.write(' RowID="%s"' % self.gds_format_integer(self.RowID, input_name='RowID'))
        if self.ShapeID is not None and 'ShapeID' not in already_processed:
            already_processed.add('ShapeID')
            outfile.write(' ShapeID="%s"' % self.gds_format_integer(self.ShapeID, input_name='ShapeID'))
        if self.PageID is not None and 'PageID' not in already_processed:
            already_processed.add('PageID')
            outfile.write(' PageID="%s"' % self.gds_format_integer(self.PageID, input_name='PageID'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RefreshConflict_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('RowID', node)
        if value is not None and 'RowID' not in already_processed:
            already_processed.add('RowID')
            self.RowID = self.gds_parse_integer(value, node, 'RowID')
        value = find_attr_value_('ShapeID', node)
        if value is not None and 'ShapeID' not in already_processed:
            already_processed.add('ShapeID')
            self.ShapeID = self.gds_parse_integer(value, node, 'ShapeID')
        value = find_attr_value_('PageID', node)
        if value is not None and 'PageID' not in already_processed:
            already_processed.add('PageID')
            self.PageID = self.gds_parse_integer(value, node, 'PageID')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RefreshConflict_Type


class AutoLinkComparison_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ColumnName=None, ContextType=None, ContextTypeLabel=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ColumnName = _cast(None, ColumnName)
        self.ColumnName_nsprefix_ = None
        self.ContextType = _cast(int, ContextType)
        self.ContextType_nsprefix_ = None
        self.ContextTypeLabel = _cast(None, ContextTypeLabel)
        self.ContextTypeLabel_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AutoLinkComparison_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AutoLinkComparison_Type.subclass:
            return AutoLinkComparison_Type.subclass(*args_, **kwargs_)
        else:
            return AutoLinkComparison_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ColumnName(self):
        return self.ColumnName
    def set_ColumnName(self, ColumnName):
        self.ColumnName = ColumnName
    def get_ContextType(self):
        return self.ContextType
    def set_ContextType(self, ContextType):
        self.ContextType = ContextType
    def get_ContextTypeLabel(self):
        return self.ContextTypeLabel
    def set_ContextTypeLabel(self, ContextTypeLabel):
        self.ContextTypeLabel = ContextTypeLabel
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AutoLinkComparison_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AutoLinkComparison_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AutoLinkComparison_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AutoLinkComparison_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AutoLinkComparison_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AutoLinkComparison_Type'):
        if self.ColumnName is not None and 'ColumnName' not in already_processed:
            already_processed.add('ColumnName')
            outfile.write(' ColumnName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ColumnName), input_name='ColumnName')), ))
        if self.ContextType is not None and 'ContextType' not in already_processed:
            already_processed.add('ContextType')
            outfile.write(' ContextType="%s"' % self.gds_format_integer(self.ContextType, input_name='ContextType'))
        if self.ContextTypeLabel is not None and 'ContextTypeLabel' not in already_processed:
            already_processed.add('ContextTypeLabel')
            outfile.write(' ContextTypeLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ContextTypeLabel), input_name='ContextTypeLabel')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AutoLinkComparison_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ColumnName', node)
        if value is not None and 'ColumnName' not in already_processed:
            already_processed.add('ColumnName')
            self.ColumnName = value
        value = find_attr_value_('ContextType', node)
        if value is not None and 'ContextType' not in already_processed:
            already_processed.add('ContextType')
            self.ContextType = self.gds_parse_integer(value, node, 'ContextType')
        value = find_attr_value_('ContextTypeLabel', node)
        if value is not None and 'ContextTypeLabel' not in already_processed:
            already_processed.add('ContextTypeLabel')
            self.ContextTypeLabel = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AutoLinkComparison_Type


class DataColumn_Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ColumnNameID=None, Name=None, Label=None, OrigLabel=None, LangID=None, Calendar=None, DataType=None, UnitType=None, Currency=None, Degree=None, DisplayWidth=None, DisplayOrder=None, Mapped=None, Hyperlink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ColumnNameID = _cast(None, ColumnNameID)
        self.ColumnNameID_nsprefix_ = None
        self.Name = _cast(None, Name)
        self.Name_nsprefix_ = None
        self.Label = _cast(None, Label)
        self.Label_nsprefix_ = None
        self.OrigLabel = _cast(None, OrigLabel)
        self.OrigLabel_nsprefix_ = None
        self.LangID = _cast(int, LangID)
        self.LangID_nsprefix_ = None
        self.Calendar = _cast(int, Calendar)
        self.Calendar_nsprefix_ = None
        self.DataType = _cast(int, DataType)
        self.DataType_nsprefix_ = None
        self.UnitType = _cast(None, UnitType)
        self.UnitType_nsprefix_ = None
        self.Currency = _cast(int, Currency)
        self.Currency_nsprefix_ = None
        self.Degree = _cast(int, Degree)
        self.Degree_nsprefix_ = None
        self.DisplayWidth = _cast(int, DisplayWidth)
        self.DisplayWidth_nsprefix_ = None
        self.DisplayOrder = _cast(int, DisplayOrder)
        self.DisplayOrder_nsprefix_ = None
        self.Mapped = _cast(int, Mapped)
        self.Mapped_nsprefix_ = None
        self.Hyperlink = _cast(int, Hyperlink)
        self.Hyperlink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataColumn_Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataColumn_Type.subclass:
            return DataColumn_Type.subclass(*args_, **kwargs_)
        else:
            return DataColumn_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ColumnNameID(self):
        return self.ColumnNameID
    def set_ColumnNameID(self, ColumnNameID):
        self.ColumnNameID = ColumnNameID
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_Label(self):
        return self.Label
    def set_Label(self, Label):
        self.Label = Label
    def get_OrigLabel(self):
        return self.OrigLabel
    def set_OrigLabel(self, OrigLabel):
        self.OrigLabel = OrigLabel
    def get_LangID(self):
        return self.LangID
    def set_LangID(self, LangID):
        self.LangID = LangID
    def get_Calendar(self):
        return self.Calendar
    def set_Calendar(self, Calendar):
        self.Calendar = Calendar
    def get_DataType(self):
        return self.DataType
    def set_DataType(self, DataType):
        self.DataType = DataType
    def get_UnitType(self):
        return self.UnitType
    def set_UnitType(self, UnitType):
        self.UnitType = UnitType
    def get_Currency(self):
        return self.Currency
    def set_Currency(self, Currency):
        self.Currency = Currency
    def get_Degree(self):
        return self.Degree
    def set_Degree(self, Degree):
        self.Degree = Degree
    def get_DisplayWidth(self):
        return self.DisplayWidth
    def set_DisplayWidth(self, DisplayWidth):
        self.DisplayWidth = DisplayWidth
    def get_DisplayOrder(self):
        return self.DisplayOrder
    def set_DisplayOrder(self, DisplayOrder):
        self.DisplayOrder = DisplayOrder
    def get_Mapped(self):
        return self.Mapped
    def set_Mapped(self, Mapped):
        self.Mapped = Mapped
    def get_Hyperlink(self):
        return self.Hyperlink
    def set_Hyperlink(self, Hyperlink):
        self.Hyperlink = Hyperlink
    def validate_ISOBoolean(self, value):
        # Validate type ISOBoolean, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [0, 1]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ISOBoolean' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DataColumn_Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataColumn_Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DataColumn_Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataColumn_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataColumn_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataColumn_Type'):
        if self.ColumnNameID is not None and 'ColumnNameID' not in already_processed:
            already_processed.add('ColumnNameID')
            outfile.write(' ColumnNameID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ColumnNameID), input_name='ColumnNameID')), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Name), input_name='Name')), ))
        if self.Label is not None and 'Label' not in already_processed:
            already_processed.add('Label')
            outfile.write(' Label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Label), input_name='Label')), ))
        if self.OrigLabel is not None and 'OrigLabel' not in already_processed:
            already_processed.add('OrigLabel')
            outfile.write(' OrigLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OrigLabel), input_name='OrigLabel')), ))
        if self.LangID is not None and 'LangID' not in already_processed:
            already_processed.add('LangID')
            outfile.write(' LangID="%s"' % self.gds_format_integer(self.LangID, input_name='LangID'))
        if self.Calendar is not None and 'Calendar' not in already_processed:
            already_processed.add('Calendar')
            outfile.write(' Calendar="%s"' % self.gds_format_integer(self.Calendar, input_name='Calendar'))
        if self.DataType is not None and 'DataType' not in already_processed:
            already_processed.add('DataType')
            outfile.write(' DataType="%s"' % self.gds_format_integer(self.DataType, input_name='DataType'))
        if self.UnitType is not None and 'UnitType' not in already_processed:
            already_processed.add('UnitType')
            outfile.write(' UnitType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UnitType), input_name='UnitType')), ))
        if self.Currency is not None and 'Currency' not in already_processed:
            already_processed.add('Currency')
            outfile.write(' Currency="%s"' % self.gds_format_integer(self.Currency, input_name='Currency'))
        if self.Degree is not None and 'Degree' not in already_processed:
            already_processed.add('Degree')
            outfile.write(' Degree="%s"' % self.gds_format_integer(self.Degree, input_name='Degree'))
        if self.DisplayWidth is not None and 'DisplayWidth' not in already_processed:
            already_processed.add('DisplayWidth')
            outfile.write(' DisplayWidth="%s"' % self.gds_format_integer(self.DisplayWidth, input_name='DisplayWidth'))
        if self.DisplayOrder is not None and 'DisplayOrder' not in already_processed:
            already_processed.add('DisplayOrder')
            outfile.write(' DisplayOrder="%s"' % self.gds_format_integer(self.DisplayOrder, input_name='DisplayOrder'))
        if self.Mapped is not None and 'Mapped' not in already_processed:
            already_processed.add('Mapped')
            outfile.write(' Mapped="%s"' % self.gds_format_integer(self.Mapped, input_name='Mapped'))
        if self.Hyperlink is not None and 'Hyperlink' not in already_processed:
            already_processed.add('Hyperlink')
            outfile.write(' Hyperlink="%s"' % self.gds_format_integer(self.Hyperlink, input_name='Hyperlink'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DataColumn_Type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ColumnNameID', node)
        if value is not None and 'ColumnNameID' not in already_processed:
            already_processed.add('ColumnNameID')
            self.ColumnNameID = value
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('Label', node)
        if value is not None and 'Label' not in already_processed:
            already_processed.add('Label')
            self.Label = value
        value = find_attr_value_('OrigLabel', node)
        if value is not None and 'OrigLabel' not in already_processed:
            already_processed.add('OrigLabel')
            self.OrigLabel = value
        value = find_attr_value_('LangID', node)
        if value is not None and 'LangID' not in already_processed:
            already_processed.add('LangID')
            self.LangID = self.gds_parse_integer(value, node, 'LangID')
        value = find_attr_value_('Calendar', node)
        if value is not None and 'Calendar' not in already_processed:
            already_processed.add('Calendar')
            self.Calendar = self.gds_parse_integer(value, node, 'Calendar')
        value = find_attr_value_('DataType', node)
        if value is not None and 'DataType' not in already_processed:
            already_processed.add('DataType')
            self.DataType = self.gds_parse_integer(value, node, 'DataType')
        value = find_attr_value_('UnitType', node)
        if value is not None and 'UnitType' not in already_processed:
            already_processed.add('UnitType')
            self.UnitType = value
        value = find_attr_value_('Currency', node)
        if value is not None and 'Currency' not in already_processed:
            already_processed.add('Currency')
            self.Currency = self.gds_parse_integer(value, node, 'Currency')
        value = find_attr_value_('Degree', node)
        if value is not None and 'Degree' not in already_processed:
            already_processed.add('Degree')
            self.Degree = self.gds_parse_integer(value, node, 'Degree')
        value = find_attr_value_('DisplayWidth', node)
        if value is not None and 'DisplayWidth' not in already_processed:
            already_processed.add('DisplayWidth')
            self.DisplayWidth = self.gds_parse_integer(value, node, 'DisplayWidth')
        value = find_attr_value_('DisplayOrder', node)
        if value is not None and 'DisplayOrder' not in already_processed:
            already_processed.add('DisplayOrder')
            self.DisplayOrder = self.gds_parse_integer(value, node, 'DisplayOrder')
        value = find_attr_value_('Mapped', node)
        if value is not None and 'Mapped' not in already_processed:
            already_processed.add('Mapped')
            self.Mapped = self.gds_parse_integer(value, node, 'Mapped')
            self.validate_ISOBoolean(self.Mapped)    # validate type ISOBoolean
        value = find_attr_value_('Hyperlink', node)
        if value is not None and 'Hyperlink' not in already_processed:
            already_processed.add('Hyperlink')
            self.Hyperlink = self.gds_parse_integer(value, node, 'Hyperlink')
            self.validate_ISOBoolean(self.Hyperlink)    # validate type ISOBoolean
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DataColumn_Type


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DataConnections_Type'
        rootClass = DataConnections_Type
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DataConnections_Type'
        rootClass = DataConnections_Type
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if mapping is None:
        mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping, nsmap_=nsmap)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DataConnections_Type'
        rootClass = DataConnections_Type
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DataConnections_Type'
        rootClass = DataConnections_Type
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from visio12_main import *\n\n')
        sys.stdout.write('import visio12_main as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://schemas.microsoft.com/visio/2006/extension': [('ISOBoolean',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'ST'),
                                                       ('Row_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('IndexedRow_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NamedRow_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NamedIndexedRow_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('GeomSection_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Cell_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ExtendableCell_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('SolutionXML_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TextCell_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('cp_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('pp_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('tp_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('fld_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('XPropsCell_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('XProp_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Text_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('XForm_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PinX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PinY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Width_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Height_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LocPinX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LocPinY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Angle_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('FlipX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('FlipY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ResizeMode_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Line_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineWeight_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineColor_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LinePattern_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Rounding_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('EndArrowSize_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('BeginArrow_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('EndArrow_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineCap_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('BeginArrowSize_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineColorTrans_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Fill_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('FillForegnd_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('FillBkgnd_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('FillPattern_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShdwForegnd_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShdwBkgnd_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShdwPattern_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('FillForegndTrans_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('FillBkgndTrans_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShdwForegndTrans_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShdwBkgndTrans_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapeShdwType_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapeShdwOffsetX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapeShdwOffsetY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapeShdwObliqueAngle_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapeShdwScaleFactor_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('XForm1D_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('BeginX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('BeginY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('EndX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('EndY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Event_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TheData_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TheText_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('EventDblClick_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('EventXFMod_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('EventDrop_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('EventMultiDrop_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('D_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('E_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LayerMem_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LayerMember_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Guide_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('X_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Y_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('A_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('StyleProp_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('EnableLineProps_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('EnableFillProps_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('EnableTextProps_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('HideForApply_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('C_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Foreign_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ImgOffsetX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ImgOffsetY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ImgWidth_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ImgHeight_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PageProps_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PageWidth_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PageHeight_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShdwOffsetX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShdwOffsetY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PageScale_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DrawingScale_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DrawingSizeType_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DrawingScaleType_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('InhibitSnap_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('UIVisibility_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShdwType_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShdwObliqueAngle_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShdwScaleFactor_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PageColor_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TextBlock_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LeftMargin_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('RightMargin_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TopMargin_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('BottomMargin_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('VerticalAlign_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TextBkgnd_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DefaultTabStop_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TextDirection_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TextBkgndTrans_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Flags_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DiacriticColor_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ExProps_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TextXForm_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TxtPinX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TxtPinY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TxtWidth_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TxtHeight_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TxtLocPinX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TxtLocPinY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TxtAngle_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Align_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('AlignLeft_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('AlignCenter_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('AlignRight_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('AlignTop_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('AlignMiddle_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('AlignBottom_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Protection_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockWidth_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockHeight_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockMoveX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockMoveY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockAspect_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockDelete_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockBegin_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockEnd_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockRotate_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockCrop_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockVtxEdit_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockTextEdit_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockFormat_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockGroup_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockCalcWH_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockSelect_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockCustProp_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockFromGroupFormat_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockThemeColors_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockThemeEffects_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Help_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('HelpTopic_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Copyright_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('B_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Misc_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NoObjHandles_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NonPrinting_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NoCtlHandles_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NoAlignBox_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('UpdateAlignBox_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('HideText_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DynFeedback_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('GlueType_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('WalkPreference_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('BegTrigger_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('EndTrigger_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ObjType_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Comment_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('IsDropSource_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NoLiveDynamics_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LocalizeMerge_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Calendar_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LangID_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapeKeywords_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DropOnPageScale_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('RulerGrid_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('XRulerDensity_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('YRulerDensity_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('XRulerOrigin_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('YRulerOrigin_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('XGridDensity_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('YGridDensity_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('XGridSpacing_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('YGridSpacing_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('XGridOrigin_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('YGridOrigin_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Hyperlink5_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Description_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Address_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('SubAddress_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ExtraInfo_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Frame_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NewWindow_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Default_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Invisible_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('SortKey_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DocProps_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('OutputFormat_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LockPreview_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('AddMarkup_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ViewMarkup_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PreviewQuality_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PreviewScope_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DocLangID_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TextFlags_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DocExProps_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Image_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Gamma_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Contrast_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Brightness_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Sharpen_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Blur_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Denoise_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Transparency_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Group_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('SelectMode_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DisplayMode_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('IsDropTarget_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('IsSnapTarget_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('IsTextEditTarget_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DontMoveChildren_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Layout_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapePermeableX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapePermeableY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapePermeablePlace_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapeFixedCode_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapePlowCode_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapeRouteStyle_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapePlaceStyle_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ConFixedCode_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ConLineJumpCode_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ConLineJumpStyle_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ConLineJumpDirX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ConLineJumpDirY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapePlaceFlip_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ConLineRouteExt_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapeSplit_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ShapeSplittable_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PageLayout_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ResizePage_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('EnableGrid_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DynamicsOff_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('CtrlAsInput_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PlaceStyle_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('RouteStyle_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PlaceDepth_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PlowCode_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineJumpCode_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineJumpStyle_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PageLineJumpDirX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PageLineJumpDirY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineToNodeX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineToNodeY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('BlockSizeX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('BlockSizeY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('AvenueSizeX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('AvenueSizeY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineToLineX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineToLineY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineJumpFactorX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineJumpFactorY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineAdjustFrom_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineAdjustTo_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PlaceFlip_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineRouteExt_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PageShapeSplit_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PrintProps_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PageLeftMargin_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PageRightMargin_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PageTopMargin_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PageBottomMargin_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ScaleX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ScaleY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PagesX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PagesY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('CenterX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('CenterY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('OnPage_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PrintGrid_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PrintPageOrientation_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PaperKind_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PaperSource_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Char_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Font_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Color_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Style_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Case_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Pos_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('FontScale_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Locale_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Size_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DblUnderline_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Overline_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Strikethru_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Highlight_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Perpendicular_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DoubleStrikethrough_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('RTLText_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('UseVertical_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Letterspace_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ColorTrans_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Hidden_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('UseKerning_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('UseNationalDigit_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NoBreak_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Outline_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NoHyphenate_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('FontDirection_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Spelling_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Grammar_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Inconsistent_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('SmartTag_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('AsianFont_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ComplexScriptFont_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LocalizeFont_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ComplexScriptSize_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('FontPosition_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Para_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('IndFirst_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('IndLeft_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('IndRight_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('SpLine_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('SpBefore_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('SpAfter_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('HorzAlign_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Bullet_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('BulletStr_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('BulletFont_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LocalizeBulletFont_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('BulletFontSize_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TextPosAfterBullet_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Tabs_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Tab_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Position_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Alignment_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Leader_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Scratch_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Connection_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DirX_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DirY_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Type_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('AutoGen_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Prompt_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ConnectionABCD_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Field_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Value_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('EditMode_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Format_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('UICat_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('UICod_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('UIFmt_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ObjectKind_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Control_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('XDyn_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('YDyn_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('XCon_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('YCon_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('CanGlue_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Geom_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NoFill_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NoLine_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NoShow_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NoSnap_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('MoveTo_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('LineTo_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ArcTo_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('InfiniteLine_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Ellipse_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('EllipticalArcTo_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('SplineStart_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('SplineKnot_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PolylineTo_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NURBSTo_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Act_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Menu_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Action_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Checked_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Disabled_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ReadOnly_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('BeginGroup_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('TagName_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ButtonFace_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Layer_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Name_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Status_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Visible_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Print_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Active_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Lock_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Snap_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Glue_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('NameUniv_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('User_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Prop_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Label_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Verify_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Hyperlink_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Reviewer_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Initials_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ReviewerID_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('CurrentIndex_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Annotation_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('MarkerIndex_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('Date_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('SmartTagDef_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('XJustify_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('YJustify_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DataConnections_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DataConnection_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DataRecordSets_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DataRecordSet_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('ADOData_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DataColumns_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('PrimaryKey_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('RowMap_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('RefreshConflict_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('AutoLinkComparison_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT'),
                                                       ('DataColumn_Type',
                                                        '1 - XML '
                                                        'Schemas\\Visio2010XSDFiles\\visio12.xsd',
                                                        'CT')]}

__all__ = [
    "ADOData_Type",
    "A_Type",
    "Act_Type",
    "Action_Type",
    "Active_Type",
    "AddMarkup_Type",
    "Address_Type",
    "AlignBottom_Type",
    "AlignCenter_Type",
    "AlignLeft_Type",
    "AlignMiddle_Type",
    "AlignRight_Type",
    "AlignTop_Type",
    "Align_Type",
    "Alignment_Type",
    "Angle_Type",
    "Annotation_Type",
    "ArcTo_Type",
    "AsianFont_Type",
    "AutoGen_Type",
    "AutoLinkComparison_Type",
    "AvenueSizeX_Type",
    "AvenueSizeY_Type",
    "B_Type",
    "BegTrigger_Type",
    "BeginArrowSize_Type",
    "BeginArrow_Type",
    "BeginGroup_Type",
    "BeginX_Type",
    "BeginY_Type",
    "BlockSizeX_Type",
    "BlockSizeY_Type",
    "Blur_Type",
    "BottomMargin_Type",
    "Brightness_Type",
    "BulletFontSize_Type",
    "BulletFont_Type",
    "BulletStr_Type",
    "Bullet_Type",
    "ButtonFace_Type",
    "C_Type",
    "Calendar_Type",
    "CanGlue_Type",
    "Case_Type",
    "Cell_Type",
    "CenterX_Type",
    "CenterY_Type",
    "Char_Type",
    "Checked_Type",
    "ColorTrans_Type",
    "Color_Type",
    "Comment_Type",
    "ComplexScriptFont_Type",
    "ComplexScriptSize_Type",
    "ConFixedCode_Type",
    "ConLineJumpCode_Type",
    "ConLineJumpDirX_Type",
    "ConLineJumpDirY_Type",
    "ConLineJumpStyle_Type",
    "ConLineRouteExt_Type",
    "ConnectionABCD_Type",
    "Connection_Type",
    "Contrast_Type",
    "Control_Type",
    "Copyright_Type",
    "CtrlAsInput_Type",
    "CurrentIndex_Type",
    "D_Type",
    "DataColumn_Type",
    "DataColumns_Type",
    "DataConnection_Type",
    "DataConnections_Type",
    "DataRecordSet_Type",
    "DataRecordSets_Type",
    "Date_Type",
    "DblUnderline_Type",
    "DefaultTabStop_Type",
    "Default_Type",
    "Denoise_Type",
    "Description_Type",
    "DiacriticColor_Type",
    "DirX_Type",
    "DirY_Type",
    "Disabled_Type",
    "DisplayMode_Type",
    "DocExProps_Type",
    "DocLangID_Type",
    "DocProps_Type",
    "DontMoveChildren_Type",
    "DoubleStrikethrough_Type",
    "DrawingScaleType_Type",
    "DrawingScale_Type",
    "DrawingSizeType_Type",
    "DropOnPageScale_Type",
    "DynFeedback_Type",
    "DynamicsOff_Type",
    "E_Type",
    "EditMode_Type",
    "Ellipse_Type",
    "EllipticalArcTo_Type",
    "EnableFillProps_Type",
    "EnableGrid_Type",
    "EnableLineProps_Type",
    "EnableTextProps_Type",
    "EndArrowSize_Type",
    "EndArrow_Type",
    "EndTrigger_Type",
    "EndX_Type",
    "EndY_Type",
    "EventDblClick_Type",
    "EventDrop_Type",
    "EventMultiDrop_Type",
    "EventXFMod_Type",
    "Event_Type",
    "ExProps_Type",
    "ExtendableCell_Type",
    "ExtraInfo_Type",
    "Field_Type",
    "FillBkgndTrans_Type",
    "FillBkgnd_Type",
    "FillForegndTrans_Type",
    "FillForegnd_Type",
    "FillPattern_Type",
    "Fill_Type",
    "Flags_Type",
    "FlipX_Type",
    "FlipY_Type",
    "FontDirection_Type",
    "FontPosition_Type",
    "FontScale_Type",
    "Font_Type",
    "Foreign_Type",
    "Format_Type",
    "Frame_Type",
    "Gamma_Type",
    "GeomSection_Type",
    "Geom_Type",
    "GlueType_Type",
    "Glue_Type",
    "Grammar_Type",
    "Group_Type",
    "Guide_Type",
    "Height_Type",
    "HelpTopic_Type",
    "Help_Type",
    "Hidden_Type",
    "HideForApply_Type",
    "HideText_Type",
    "Highlight_Type",
    "HorzAlign_Type",
    "Hyperlink5_Type",
    "Hyperlink_Type",
    "Image_Type",
    "ImgHeight_Type",
    "ImgOffsetX_Type",
    "ImgOffsetY_Type",
    "ImgWidth_Type",
    "Inconsistent_Type",
    "IndFirst_Type",
    "IndLeft_Type",
    "IndRight_Type",
    "IndexedRow_Type",
    "InfiniteLine_Type",
    "InhibitSnap_Type",
    "Initials_Type",
    "Invisible_Type",
    "IsDropSource_Type",
    "IsDropTarget_Type",
    "IsSnapTarget_Type",
    "IsTextEditTarget_Type",
    "Label_Type",
    "LangID_Type",
    "LayerMem_Type",
    "LayerMember_Type",
    "Layer_Type",
    "Layout_Type",
    "Leader_Type",
    "LeftMargin_Type",
    "Letterspace_Type",
    "LineAdjustFrom_Type",
    "LineAdjustTo_Type",
    "LineCap_Type",
    "LineColorTrans_Type",
    "LineColor_Type",
    "LineJumpCode_Type",
    "LineJumpFactorX_Type",
    "LineJumpFactorY_Type",
    "LineJumpStyle_Type",
    "LinePattern_Type",
    "LineRouteExt_Type",
    "LineToLineX_Type",
    "LineToLineY_Type",
    "LineToNodeX_Type",
    "LineToNodeY_Type",
    "LineTo_Type",
    "LineWeight_Type",
    "Line_Type",
    "LocPinX_Type",
    "LocPinY_Type",
    "Locale_Type",
    "LocalizeBulletFont_Type",
    "LocalizeFont_Type",
    "LocalizeMerge_Type",
    "LockAspect_Type",
    "LockBegin_Type",
    "LockCalcWH_Type",
    "LockCrop_Type",
    "LockCustProp_Type",
    "LockDelete_Type",
    "LockEnd_Type",
    "LockFormat_Type",
    "LockFromGroupFormat_Type",
    "LockGroup_Type",
    "LockHeight_Type",
    "LockMoveX_Type",
    "LockMoveY_Type",
    "LockPreview_Type",
    "LockRotate_Type",
    "LockSelect_Type",
    "LockTextEdit_Type",
    "LockThemeColors_Type",
    "LockThemeEffects_Type",
    "LockVtxEdit_Type",
    "LockWidth_Type",
    "Lock_Type",
    "MarkerIndex_Type",
    "Menu_Type",
    "Misc_Type",
    "MoveTo_Type",
    "NURBSTo_Type",
    "NameUniv_Type",
    "Name_Type",
    "NamedIndexedRow_Type",
    "NamedRow_Type",
    "NewWindow_Type",
    "NoAlignBox_Type",
    "NoBreak_Type",
    "NoCtlHandles_Type",
    "NoFill_Type",
    "NoHyphenate_Type",
    "NoLine_Type",
    "NoLiveDynamics_Type",
    "NoObjHandles_Type",
    "NoShow_Type",
    "NoSnap_Type",
    "NonPrinting_Type",
    "ObjType_Type",
    "ObjectKind_Type",
    "OnPage_Type",
    "Outline_Type",
    "OutputFormat_Type",
    "Overline_Type",
    "PageBottomMargin_Type",
    "PageColor_Type",
    "PageHeight_Type",
    "PageLayout_Type",
    "PageLeftMargin_Type",
    "PageLineJumpDirX_Type",
    "PageLineJumpDirY_Type",
    "PageProps_Type",
    "PageRightMargin_Type",
    "PageScale_Type",
    "PageShapeSplit_Type",
    "PageTopMargin_Type",
    "PageWidth_Type",
    "PagesX_Type",
    "PagesY_Type",
    "PaperKind_Type",
    "PaperSource_Type",
    "Para_Type",
    "Perpendicular_Type",
    "PinX_Type",
    "PinY_Type",
    "PlaceDepth_Type",
    "PlaceFlip_Type",
    "PlaceStyle_Type",
    "PlowCode_Type",
    "PolylineTo_Type",
    "Pos_Type",
    "Position_Type",
    "PreviewQuality_Type",
    "PreviewScope_Type",
    "PrimaryKey_Type",
    "PrintGrid_Type",
    "PrintPageOrientation_Type",
    "PrintProps_Type",
    "Print_Type",
    "Prompt_Type",
    "Prop_Type",
    "Protection_Type",
    "RTLText_Type",
    "ReadOnly_Type",
    "RefreshConflict_Type",
    "ResizeMode_Type",
    "ResizePage_Type",
    "ReviewerID_Type",
    "Reviewer_Type",
    "RightMargin_Type",
    "Rounding_Type",
    "RouteStyle_Type",
    "RowMap_Type",
    "Row_Type",
    "RulerGrid_Type",
    "ScaleX_Type",
    "ScaleY_Type",
    "Scratch_Type",
    "SelectMode_Type",
    "ShapeFixedCode_Type",
    "ShapeKeywords_Type",
    "ShapePermeablePlace_Type",
    "ShapePermeableX_Type",
    "ShapePermeableY_Type",
    "ShapePlaceFlip_Type",
    "ShapePlaceStyle_Type",
    "ShapePlowCode_Type",
    "ShapeRouteStyle_Type",
    "ShapeShdwObliqueAngle_Type",
    "ShapeShdwOffsetX_Type",
    "ShapeShdwOffsetY_Type",
    "ShapeShdwScaleFactor_Type",
    "ShapeShdwType_Type",
    "ShapeSplit_Type",
    "ShapeSplittable_Type",
    "Sharpen_Type",
    "ShdwBkgndTrans_Type",
    "ShdwBkgnd_Type",
    "ShdwForegndTrans_Type",
    "ShdwForegnd_Type",
    "ShdwObliqueAngle_Type",
    "ShdwOffsetX_Type",
    "ShdwOffsetY_Type",
    "ShdwPattern_Type",
    "ShdwScaleFactor_Type",
    "ShdwType_Type",
    "Size_Type",
    "SmartTagDef_Type",
    "SmartTag_Type",
    "Snap_Type",
    "SolutionXML_Type",
    "SortKey_Type",
    "SpAfter_Type",
    "SpBefore_Type",
    "SpLine_Type",
    "Spelling_Type",
    "SplineKnot_Type",
    "SplineStart_Type",
    "Status_Type",
    "Strikethru_Type",
    "StyleProp_Type",
    "Style_Type",
    "SubAddress_Type",
    "Tab_Type",
    "Tabs_Type",
    "TagName_Type",
    "TextBkgndTrans_Type",
    "TextBkgnd_Type",
    "TextBlock_Type",
    "TextCell_Type",
    "TextDirection_Type",
    "TextFlags_Type",
    "TextPosAfterBullet_Type",
    "TextXForm_Type",
    "Text_Type",
    "TheData_Type",
    "TheText_Type",
    "TopMargin_Type",
    "Transparency_Type",
    "TxtAngle_Type",
    "TxtHeight_Type",
    "TxtLocPinX_Type",
    "TxtLocPinY_Type",
    "TxtPinX_Type",
    "TxtPinY_Type",
    "TxtWidth_Type",
    "Type_Type",
    "UICat_Type",
    "UICod_Type",
    "UIFmt_Type",
    "UIVisibility_Type",
    "UpdateAlignBox_Type",
    "UseKerning_Type",
    "UseNationalDigit_Type",
    "UseVertical_Type",
    "User_Type",
    "Value_Type",
    "Verify_Type",
    "VerticalAlign_Type",
    "ViewMarkup_Type",
    "Visible_Type",
    "WalkPreference_Type",
    "Width_Type",
    "XCon_Type",
    "XDyn_Type",
    "XForm1D_Type",
    "XForm_Type",
    "XGridDensity_Type",
    "XGridOrigin_Type",
    "XGridSpacing_Type",
    "XJustify_Type",
    "XProp_Type",
    "XPropsCell_Type",
    "XRulerDensity_Type",
    "XRulerOrigin_Type",
    "X_Type",
    "YCon_Type",
    "YDyn_Type",
    "YGridDensity_Type",
    "YGridOrigin_Type",
    "YGridSpacing_Type",
    "YJustify_Type",
    "YRulerDensity_Type",
    "YRulerOrigin_Type",
    "Y_Type",
    "cp_Type",
    "fld_Type",
    "pp_Type",
    "tp_Type"
]
